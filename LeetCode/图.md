* **图总结**
   * **广度优先搜索**
      * [单词接龙](#单词接龙)
   * **深度优先搜索**
      * [岛屿的个数](#岛屿的个数)
      * [被围绕的区域](#被围绕的区域)
      * [矩阵中的最长递增路径](#矩阵中的最长递增路径)
   * **其他**
      * [课程表](#课程表)
      * [课程表II](#课程表II)
   
# 图总结
## 课程表

[LeetCode链接](https://leetcode-cn.com/problems/course-schedule/)

现在你总共有 `n` 门课需要选，记为 `0` 到 `n-1`。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: `[0,1]`

给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？

**示例 1**:
```
输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。
```

**示例 2**:
```
输入: 2, [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。
```

说明:

* 输入的先决条件是由**边缘列表**表示的图形，而不是邻接矩阵。详情请参见图的表示法。
* 你可以假定输入的先决条件中没有重复的边。

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    bool canFinish(int numCourses, vector<pair<int, int>>& prerequisites) {
        vector<vector<int >> graph(numCourses,vector<int>(0));
        vector<int> degree(numCourses,0);
        for(auto a:prerequisites)
        {
            int from=a.second;
            int to=a.first;
            graph[from].push_back(to);
            degree[to]++;
        }
        
        queue<int> que;
        for(int i=0;i<degree.size();i++)
        {
            if(degree[i]==0)
                que.push(i);
        }
        
        int cnt=0;
        while(!que.empty())
        {
            int a=que.front();
            que.pop();
            
            for(auto b:graph[a])
            {
                degree[b]--;
                if(degree[b]==0)
                    que.push(b);
            }
            cnt++;
        }
        
        if(cnt==numCourses)
            return true;
        else
            return false;
    }
};
```

## 课程表II

[LeetCode链接](https://leetcode-cn.com/problems/course-schedule-ii/)

现在你总共有 `n` 门课需要选，记为 `0` 到 `n-1`。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: `[0,1]`

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

**示例 1**:
```
输入: 2, [[1,0]] 
输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
```

**示例 2**:
```
输入: 4, [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
```

**说明**:

* 输入的先决条件是由**边缘列表**表示的图形，而不是邻接矩阵。详情请参见图的表示法。
* 你可以假定输入的先决条件中没有重复的边。

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {
        vector<vector<int >> graph(numCourses,vector<int>(0));
        vector<int> degree(numCourses,0);
        for(auto a:prerequisites)
        {
            int from=a.second;
            int to=a.first;
            graph[from].push_back(to);
            degree[to]++;
        }
        
        queue<int> que;
        for(int i=0;i<degree.size();i++)
        {
            if(degree[i]==0)
                que.push(i);
        }
        
        vector<int> res;
        int cnt=0;
        while(!que.empty())
        {
            int a=que.front();
            que.pop();
            res.push_back(a);
            
            for(auto b:graph[a])
            {
                degree[b]--;
                if(degree[b]==0)
                    que.push(b);
            }
            cnt++;
        }
        
        if(cnt==numCourses)
            return res;
        else
            return vector<int>(0);
    }
};
```
## 单词接龙

[LeetCode链接](https://leetcode-cn.com/problems/word-ladder/)

给定两个单词（*beginWord* 和 *endWord*）和一个字典，找到从 *beginWord* 到 *endWord* 的最短转换序列的长度。转换需遵循如下规则：

1. 每次转换只能改变一个字母。
2. 转换过程中的中间单词必须是字典中的单词。

**说明**:

* 如果不存在这样的转换序列，返回 0。
* 所有单词具有相同的长度。
* 所有单词只由小写字母组成。
* 字典中不存在重复的单词。
* 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。

**示例 1**:
```
输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

输出: 5

解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",
     返回它的长度 5。
```

**示例 2**:
```
输入:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

输出: 0

解释: endWord "cog" 不在字典中，所以无法进行转换。
```

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    bool isNext(string str1,string str2)
    {
        int len1=str1.size();
        int len2=str2.size();
        if(len1!=len2)
            return false;
        
        int cnt=0;
        for(int i=0;i<len1;i++)
        {
            if(str1[i]!=str2[i])
                cnt++;
        }
        if(cnt==1)
            return true;
        
        return false;
    }
    
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        if(beginWord==endWord)
            return 0;
        
        int len = wordList.size();
        queue<string> que;
        vector<int> visited(len,false);
        que.push(beginWord);
        int cnt = 1;
        string pre = beginWord;
        string next;
        while(!que.empty())
        {
            auto cur = que.front();
            que.pop();
            
            if(cur == endWord)
                return cnt;
            
            for(int i=0;i<len;i++)
            {
                auto s = wordList[i];
                if(!visited[i] && isNext(s,cur))
                {
                    que.push(s);
                    visited[i] = true;
                    next = s;
                }
            }
            
            if(cur == pre)
            {
                pre = next;
                cnt++;
            }
            
        }
        
        return 0;
    }
};
```

## 岛屿的个数

[LeetCode链接](https://leetcode-cn.com/problems/number-of-islands/)

给定一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。

**示例 1**:
```
输入:
11110
11010
11000
00000

输出: 1
```

**示例 2**:
```
输入:
11000
11000
00100
00011

输出: 3
```

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    void dfs(int h,int l,vector<vector<bool>>& vec,vector<vector<char>>& grid)
    {
        if(h<0 || h>=vec.size())
            return;
        if(l<0 || l>=vec[0].size())
            return;
        
        if(grid[h][l]=='0' || vec[h][l])
            return;
        
        vec[h][l]=true;
        dfs(h,l-1,vec,grid);
        dfs(h,l+1,vec,grid);
        dfs(h-1,l,vec,grid);
        dfs(h+1,l,vec,grid);
    }
    
    int numIslands(vector<vector<char>>& grid) {
        if(grid.size()==0)
            return 0;
        
        int res=0;
        int m=grid.size();
        int n=grid[0].size();
        vector<vector<bool>> visited(m,vector<bool>(n,false));
        for(int i=0;i<m;i++)
            for(int j=0;j<n;j++)
            {
                if(grid[i][j]=='1' && !visited[i][j])
                {
                    res++;
                    dfs(i,j,visited,grid);
                }
            }
        
        return res;
    }
};
```

## 被围绕的区域

[LeetCode链接](https://leetcode-cn.com/problems/surrounded-regions/)

给定一个二维的矩阵，包含 `'X'` 和 `'O'`（**字母 O**）。

找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。

**示例**:
```
X X X X
X O O X
X X O X
X O X X
```
运行你的函数后，矩阵变为：
```
X X X X
X X X X
X X X X
X O X X
```
**解释**:

被围绕的区间不会存在于边界上，换句话说，任何边界上的 `'O'` 都不会被填充为 `'X'`。 任何不在边界上，或不与边界上的 `'O'` 相连的 `'O'` 最终都会被填充为 `'X'`。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    void dfs(int x,int y,vector<vector<char>>& vec)
    {
        int row = vec.size();
        int col = vec[0].size();
        if(x < 0 || y < 0 || x >= row || y >= col || vec[x][y] != 'O')
            return;
        
        vec[x][y] = '$';
        
        dfs(x+1,y,vec);
        dfs(x-1,y,vec);
        dfs(x,y+1,vec);
        dfs(x,y-1,vec);
    }
    
    void solve(vector<vector<char>>& board) {
        if(board.empty()) return;
        
        int row = board.size();
        int col = board[0].size();
        
        int i=0,j=0;
        for(;j<col;j++)
        {
            if(board[i][j] == 'O')
                dfs(i,j,board);
        }
        
        j = col-1;
        for(;i<row;i++)
        {
            if(board[i][j] == 'O')
                dfs(i,j,board);
        }
        
        i = row-1;
        for(;j>=0;j--)
        {
            if(board[i][j] == 'O')
                dfs(i,j,board);
        }
        
        j=0;
        for(;i>=0;i--)
        {
            if(board[i][j] == 'O')
                dfs(i,j,board);
        }
        
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
            {
                if(board[i][j] == 'O')
                    board[i][j] = 'X';
            }
        
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
            {
                if(board[i][j] == '$')
                    board[i][j] = 'O';
            }
    }
};
```

## 矩阵中的最长递增路径

[LeetCode链接](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)

给定一个整数矩阵，找出最长递增路径的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。

**示例 1**:
```
输入: nums = 
[
  [9,9,4],
  [6,6,8],
  [2,1,1]
] 
输出: 4 
解释: 最长递增路径为 [1, 2, 6, 9]。
```

**示例 2**:
```
输入: nums = 
[
  [3,4,5],
  [3,2,6],
  [2,2,1]
] 
输出: 4 
解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。
```

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    int recursion(int x,int y,const vector<vector<int>>& vec,vector<vector<int>>& dp)
    {
        if(dp[x][y] != 0)
            return dp[x][y];
        
        int row = vec.size();
        int col = vec[0].size();
        
        dp[x][y] = 1;
        
        if(x > 0 && vec[x-1][y] > vec[x][y])
        {
            int cnt = recursion(x-1,y,vec,dp) + 1;
            dp[x][y] = max(dp[x][y],cnt);
        }
        
        if(x < row - 1 && vec[x+1][y] > vec[x][y])
        {
            int cnt = recursion(x+1,y,vec,dp) + 1;
            dp[x][y] = max(cnt,dp[x][y]);
        }
        
        if(y > 0 && vec[x][y-1] > vec[x][y])
        {
            int cnt = recursion(x,y-1,vec,dp) + 1;
            dp[x][y] = max(dp[x][y],cnt);
        }
        
        if(y < col - 1 && vec[x][y+1] > vec[x][y])
        {
            int cnt = recursion(x,y+1,vec,dp) + 1;
            dp[x][y] = max(dp[x][y],cnt);
        }
        
        return dp[x][y];
    }
    
    
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        if(matrix.empty()) return 0;
        
        int row = matrix.size();
        int col = matrix[0].size();
        
        vector<vector<int>> dp(row,vector<int>(col,0));
        int res = INT_MIN;
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
            {
                int a = recursion(i,j,matrix,dp);
                res = max(res,a);
            }
        
        return res;
    }
};
```

