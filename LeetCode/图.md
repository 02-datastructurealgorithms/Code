* **图总结**
   * **广度优先搜索**
      * [单词接龙](#单词接龙) (`medium`)
   * **深度优先搜索**
      * [岛屿的个数](#岛屿的个数) (`medium`)
      * [被围绕的区域](#被围绕的区域) (`medium`)
      * [单词搜索](#单词搜索) (`medium`)
      * [单词搜索II](#单词搜索II) (`hard` `字典树`)
      * [矩阵中的最长递增路径](#矩阵中的最长递增路径) (`hard` `动态规划`)
   * **并查集**
     * [冗余连接](#冗余连接) (`medium`)
     * [朋友圈](#朋友圈) (`medium`)
   * **其他**
      * [课程表](#课程表) (`medium` `拓扑排序`)
      * [课程表II](#课程表II) (`medium` `拓扑排序`)

# 图总结
## 课程表

[LeetCode链接](https://leetcode-cn.com/problems/course-schedule/)

现在你总共有 `n` 门课需要选，记为 `0` 到 `n-1`。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: `[0,1]`

给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？

**示例 1**:

```
输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。
```

**示例 2**:
```
输入: 2, [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。
```

说明:

* 输入的先决条件是由**边缘列表**表示的图形，而不是邻接矩阵。详情请参见图的表示法。
* 你可以假定输入的先决条件中没有重复的边。

### 解答

考察**拓扑排序**，利用课程之间的关系简历有向图，如果课程`A`之前需要完成课程`B`，那么在图中`A`指向`B`，同时定义数组`degree`统计每个节点的入度。定义队列`que`，首先将入度为0的节点加入队列，定义变量`cnt`用于计数。然后循环访问队列的队首元素`a`，并将`a`弹出队列，访问`a`指向的每个节点`b`，将`b`的入度减一，如果此时`b`的入度为0，则将`b`加入队列，然后进入下一次循环，每次循环都将`cnt`加一，知道队列为空时结束循环。最后，如果`cnt`等于课程数，说所有的课程都加入过队列，所以可以有序地完成学习，返回`true`；否则，返回`false`。

设有向图的顶点数为*v*，边数为*e*

* 时间复杂度：O(*v + e*)
* 空间复杂度：O(*v + e*)

```c++
class Solution {
public:
    bool canFinish(int numCourses, vector<pair<int, int>>& prerequisites) {
        vector<vector<int>> graph(numCourses,vector<int>());
        vector<int> degree(numCourses,0);
        for(auto a : prerequisites)
        {
            int from = a.second;
            int to = a.first;
            graph[from].push_back(to);
            degree[to]++;
        }
        
        queue<int> que;
        for(int i=0;i<degree.size();i++)
        {
            if(degree[i] == 0)
                que.push(i);
        }
        
        int cnt = 0;
        while(!que.empty())
        {
            int a = que.front();
            que.pop();
            
            for(auto b : graph[a])
            {
                degree[b]--;
                if(degree[b] == 0)
                    que.push(b);
            }
            
            cnt++;
        }
        
        if(cnt == numCourses) return true;
        
        return false;
    }
};
```



## 课程表II

[LeetCode链接](https://leetcode-cn.com/problems/course-schedule-ii/)

现在你总共有 `n` 门课需要选，记为 `0` 到 `n-1`。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: `[0,1]`

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

**示例 1**:
```
输入: 2, [[1,0]] 
输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
```

**示例 2**:
```
输入: 4, [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
```

**说明**:

* 输入的先决条件是由**边缘列表**表示的图形，而不是邻接矩阵。详情请参见图的表示法。
* 你可以假定输入的先决条件中没有重复的边。

### 解答

处理过程同 [课程表](#课程表)，只是需要加一步，在循环中每次从队列弹出队首元素的时候，将这个队首元素加入结果即可。

设有向图的顶点数为*v*，边数为*e*

- 时间复杂度：O(*v + e*)
- 空间复杂度：O(*v + e*)

```c++
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {
        vector<vector<int >> graph(numCourses,vector<int>());
        vector<int> degree(numCourses,0);
        for(auto a : prerequisites)
        {
            int from = a.second;
            int to = a.first;
            graph[from].push_back(to);
            degree[to]++;
        }
        
        queue<int> que;
        for(int i=0;i<degree.size();i++)
        {
            if(degree[i] == 0)
                que.push(i);
        }
        
        vector<int> res;
        int cnt = 0;
        while(!que.empty())
        {
            int a = que.front();
            que.pop();
            res.push_back(a);
            
            for(auto b : graph[a])
            {
                degree[b]--;
                if(degree[b] == 0)
                    que.push(b);
            }
            
            cnt++;
        }
        
        if(cnt == numCourses) return res;
        
        return vector<int>(0);
    }
};
```



## 单词接龙

[LeetCode链接](https://leetcode-cn.com/problems/word-ladder/)

给定两个单词（*beginWord* 和 *endWord*）和一个字典，找到从 *beginWord* 到 *endWord* 的最短转换序列的长度。转换需遵循如下规则：

1. 每次转换只能改变一个字母。
2. 转换过程中的中间单词必须是字典中的单词。

**说明**:

* 如果不存在这样的转换序列，返回 0。
* 所有单词具有相同的长度。
* 所有单词只由小写字母组成。
* 字典中不存在重复的单词。
* 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。

**示例 1**:

```
输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

输出: 5

解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",
     返回它的长度 5。
```

**示例 2**:

```
输入:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

输出: 0

解释: endWord "cog" 不在字典中，所以无法进行转换。
```

### 解答

考察**图的广度优先遍历**，由于是单词转换，建立图的时候，只相差一个字母的两个字符串构成相连的节点，利用这种关系可以建立**无向图**。处理过程类似 [二叉树的层序遍历](https://github.com/Making-It/Code/blob/master/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91.md#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86)，利用**队列**结构来实现 *BFS* 的过程。对于图的结构，需要定义`bool`类型的数组`visited`来记录访问过的节点，从而就避免了重复访问同一个节点。由于需要统计最短转换的步数，在 *DFS* 过程中需要进行**分层**处理，每经过一层，将计数值`cnt`加一，直到访问到 *endWord*，返回`cnt`。

设有向图的顶点数为*v*，边数为*e*

* 时间复杂度：O(*v*)
* 空间复杂度：O(*v*)

```c++
class Solution {
public:
    bool isNext(string str1,string str2)
    {
        int len1 = str1.size();
        int len2 = str2.size();
        if(len1 != len2)
            return false;
        
        int cnt = 0;
        for(int i=0;i<len1;i++)
        {
            if(str1[i] != str2[i])
                cnt++;
        }
        
        if(cnt == 1)
            return true;
        
        return false;
    }
    
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        if(beginWord == endWord)
            return 0;
        
        int len = wordList.size();
        queue<string> que;
        vector<int> visited(len,false);
        que.push(beginWord);
        int cnt = 1;
        string pre = beginWord;
        string next;
        while(!que.empty())
        {
            auto cur = que.front();
            que.pop();
            
            if(cur == endWord)
                return cnt;
            
            for(int i=0;i<len;i++)
            {
                auto s = wordList[i];
                if(!visited[i] && isNext(s,cur))
                {
                    que.push(s);
                    visited[i] = true;
                    next = s;
                }
            }
            
            if(cur == pre)
            {
                pre = next;
                cnt++;
            }
            
        }
        
        return 0;
    }
};
```



## 岛屿的个数

[LeetCode链接](https://leetcode-cn.com/problems/number-of-islands/)

给定一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。

**示例 1**:
```
输入:
11110
11010
11000
00000

输出: 1
```

**示例 2**:
```
输入:
11000
11000
00100
00011

输出: 3
```

### 解答

* 时间复杂度：O()
* 空间复杂度：O()

```c++
class Solution {
public:
    void dfs(int h,int l,vector<vector<bool>>& vec,vector<vector<char>>& grid)
    {
        if(h<0 || h>=vec.size())
            return;
        if(l<0 || l>=vec[0].size())
            return;
        
        if(grid[h][l]=='0' || vec[h][l])
            return;
        
        vec[h][l]=true;
        dfs(h,l-1,vec,grid);
        dfs(h,l+1,vec,grid);
        dfs(h-1,l,vec,grid);
        dfs(h+1,l,vec,grid);
    }
    
    int numIslands(vector<vector<char>>& grid) {
        if(grid.size()==0)
            return 0;
        
        int res=0;
        int m=grid.size();
        int n=grid[0].size();
        vector<vector<bool>> visited(m,vector<bool>(n,false));
        for(int i=0;i<m;i++)
            for(int j=0;j<n;j++)
            {
                if(grid[i][j]=='1' && !visited[i][j])
                {
                    res++;
                    dfs(i,j,visited,grid);
                }
            }
        
        return res;
    }
};
```



## 被围绕的区域

[LeetCode链接](https://leetcode-cn.com/problems/surrounded-regions/)

给定一个二维的矩阵，包含 `'X'` 和 `'O'`（**字母 O**）。

找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。

**示例**:
```
X X X X
X O O X
X X O X
X O X X
```
运行你的函数后，矩阵变为：
```
X X X X
X X X X
X X X X
X O X X
```
**解释**:

被围绕的区间不会存在于边界上，换句话说，任何边界上的 `'O'` 都不会被填充为 `'X'`。 任何不在边界上，或不与边界上的 `'O'` 相连的 `'O'` 最终都会被填充为 `'X'`。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。

### 解答

* 时间复杂度：O()
* 空间复杂度：O()

```c++
class Solution {
public:
    void dfs(int x,int y,vector<vector<char>>& vec)
    {
        int row = vec.size();
        int col = vec[0].size();
        if(x < 0 || y < 0 || x >= row || y >= col || vec[x][y] != 'O')
            return;
        
        vec[x][y] = '$';
        
        dfs(x+1,y,vec);
        dfs(x-1,y,vec);
        dfs(x,y+1,vec);
        dfs(x,y-1,vec);
    }
    
    void solve(vector<vector<char>>& board) {
        if(board.empty()) return;
        
        int row = board.size();
        int col = board[0].size();
        
        int i=0,j=0;
        for(;j<col;j++)
        {
            if(board[i][j] == 'O')
                dfs(i,j,board);
        }
        
        j = col-1;
        for(;i<row;i++)
        {
            if(board[i][j] == 'O')
                dfs(i,j,board);
        }
        
        i = row-1;
        for(;j>=0;j--)
        {
            if(board[i][j] == 'O')
                dfs(i,j,board);
        }
        
        j=0;
        for(;i>=0;i--)
        {
            if(board[i][j] == 'O')
                dfs(i,j,board);
        }
        
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
            {
                if(board[i][j] == 'O')
                    board[i][j] = 'X';
            }
        
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
            {
                if(board[i][j] == '$')
                    board[i][j] = 'O';
            }
    }
};
```



## 矩阵中的最长递增路径

[LeetCode链接](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)

给定一个整数矩阵，找出最长递增路径的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。

**示例 1**:
```
输入: nums = 
[
  [9,9,4],
  [6,6,8],
  [2,1,1]
] 
输出: 4 
解释: 最长递增路径为 [1, 2, 6, 9]。
```

**示例 2**:
```
输入: nums = 
[
  [3,4,5],
  [3,2,6],
  [2,2,1]
] 
输出: 4 
解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。
```

### 解答

* 时间复杂度：O()
* 空间复杂度：O()

```c++
class Solution {
public:
    int recursion(int x,int y,const vector<vector<int>>& vec,vector<vector<int>>& dp)
    {
        if(dp[x][y] != 0)
            return dp[x][y];
        
        int row = vec.size();
        int col = vec[0].size();
        
        dp[x][y] = 1;
        
        if(x > 0 && vec[x-1][y] > vec[x][y])
        {
            int cnt = recursion(x-1,y,vec,dp) + 1;
            dp[x][y] = max(dp[x][y],cnt);
        }
        
        if(x < row - 1 && vec[x+1][y] > vec[x][y])
        {
            int cnt = recursion(x+1,y,vec,dp) + 1;
            dp[x][y] = max(cnt,dp[x][y]);
        }
        
        if(y > 0 && vec[x][y-1] > vec[x][y])
        {
            int cnt = recursion(x,y-1,vec,dp) + 1;
            dp[x][y] = max(dp[x][y],cnt);
        }
        
        if(y < col - 1 && vec[x][y+1] > vec[x][y])
        {
            int cnt = recursion(x,y+1,vec,dp) + 1;
            dp[x][y] = max(dp[x][y],cnt);
        }
        
        return dp[x][y];
    }
    
    
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        if(matrix.empty()) return 0;
        
        int row = matrix.size();
        int col = matrix[0].size();
        
        vector<vector<int>> dp(row,vector<int>(col,0));
        int res = INT_MIN;
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
            {
                int a = recursion(i,j,matrix,dp);
                res = max(res,a);
            }
        
        return res;
    }
};
```



## 冗余连接

[LeetCode链接](https://leetcode-cn.com/problems/redundant-connection/)

在本问题中, 树指的是一个连通且无环的**无向**图。

输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组。每一个边的元素是一对`[u, v]` ，满足 `u < v`，表示连接顶点`u` 和`v`的**无向**图的边。

返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 `[u, v]` 应满足相同的格式 `u < v`。

**示例 1**：

```
输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的无向图为:
  1
 / \
2 - 3
```

**示例 2**：

```
输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
解释: 给定的无向图为:
5 - 1 - 2
    |   |
    4 - 3
```

**注意**:

- 输入的二维数组大小在 3 到 1000。
- 二维数组中的整数在1到N之间，其中N是输入数组的大小。

### 解答

- 时间复杂度：O()
- 空间复杂度：O()

```c++

```



## 朋友圈

[LeetCode链接](https://leetcode-cn.com/problems/friend-circles/)

班上有 **N** 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。

给定一个 `N * N` 的矩阵 **M**，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生**互为**朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。

**示例 1**:

```
输入: 
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出: 2 
说明：已知学生0和学生1互为朋友，他们在一个朋友圈。
第2个学生自己在一个朋友圈。所以返回2。
```

**示例 2**:

```
输入: 
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出: 1
说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。
```

**注意**：

- N 在[1,200]的范围内。
- 对于所有学生，有M[i][i] = 1。
- 如果有M[i][j] = 1，则有M[j][i] = 1。

### 解答

- 时间复杂度：O()
- 空间复杂度：O()

```c++
class UnionSet
{
public:
    UnionSet(int n)
    {
        for(int i=0;i<n;i++)
        {
            fatherMp[i] = i;
            sizeMp[i] = 1;
        }
    }
    
    bool isSameSet(int node1,int node2)
    {
        return findHead(node1) == findHead(node2);
    }
    
    void Union(int node1,int node2)
    {
        int head1 = findHead(node1);
        int head2 = findHead(node2);
        
        if(head1 == head2)
            return;
        
        if(sizeMp[head1] <= sizeMp[head2])
        {
            fatherMp[head1] = head2;
            sizeMp[head2] = sizeMp[head1] + sizeMp[head2];
            sizeMp.erase(head1);
        }
        else{
            fatherMp[head2] = head1;
            sizeMp[head1] = sizeMp[head1] + sizeMp[head2];
            sizeMp.erase(head2);
        }
    }
    
    int findHead(int node)
    {
        //递归找集合的根
        int head;
        if(fatherMp[node] == node)
            return node;
        else{
            head = findHead(fatherMp[node]);
        }
        
        return head;
    }

    
    int getSize()
    {
        return sizeMp.size();
    }
private:
    unordered_map<int,int> fatherMp,sizeMp;
};

class Solution {
public:
    int findCircleNum(vector<vector<int>>& M) {
        if(M.empty())
            return 0;
        
        int size = M[0].size();
        UnionSet st(size);
        for(int i=0;i<size;i++)
        {
            for(int j=i+1;j<size;j++)
            {
                if(M[i][j] == 1)
                {
                    st.Union(i,j);
                }
            }
        }
        
        return st.getSize();
    }
};
```



## 单词搜索

[LeetCode链接](https://leetcode-cn.com/problems/word-search)

给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例**:

```
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true.
给定 word = "SEE", 返回 true.
给定 word = "ABCB", 返回 false.
```

### 解答

遍历二维网格的每一个位置`board[i][j]`，如果`board[i][j] == word[0]`，则从`board[i][j]`开始向二维网格的**上下左右**四个方向进行深度优先搜索，同时开辟一个`bool`类型的数组`vis`，用于记录已经访问过的字母，在每一层递归搜索到一个字母`board[a][b]`，令`vis[a][b]` = `true`，然后向该字母的**上下左右**四个方向进行搜索（进入下一层递归），如果四个方向中有一个满足条件（返回`true`），本层递归的`bool`结果就为`true`，否则，返回`false`，待四个方向都搜索完成（递归返回）之后恢复`vis[a][b]` = `false`。在搜索的过程中用一个变量`idx`记录当前搜索的字母在单词中的索引。递归结束条件为：

1. 如果**字母位置越界**或者**字母已经被访问过**或者**搜索到的字母不等于`word[idx]`**，则返回`false`；
2. 如果`idx == word.size()`，则满足条件返回`true`。

最终，得到递归函数的`bool`类型即为所求。

```c++
class Solution {
public:
    bool recursion(const vector<vector<char>>& board,vector<vector<bool>>& vis,const string& word,int a,int b,int idx)
    {
        if(idx == word.size())
            return true;
        
        if(a < 0 || a >= board.size() || b < 0 || b >= board[0].size() || vis[a][b] || word[idx] != board[a][b])
            return false;
        
        
        vis[a][b] = true;
        bool res = false;
        res = recursion(board,vis,word,a - 1,b,idx + 1) || recursion(board,vis,word,a + 1,b,idx + 1) 
              || recursion(board,vis,word,a,b - 1,idx + 1) || recursion(board,vis,word,a,b + 1,idx + 1);
        
        vis[a][b] = false;
        
        return res;
    }
    
    bool exist(vector<vector<char>>& board, string word) {
        if(board.empty())
            return false;
        
        int row = board.size();
        int col = board[0].size();
        if(word.size() > row * col)
            return false;
        
        vector<vector<bool>> vis(row,vector<bool>(col,false));
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
            {
                if(board[i][j] == word[0])
                {
                    if(recursion(board,vis,word,i,j,0))
                        return true;
                }
            }
        
        return false;
    }
};
```



## 单词搜索II

[LeetCode链接](https://leetcode-cn.com/problems/word-search-ii/)

给定一个二维网格 `board` 和一个字典中的单词列表 `words`，找出所有同时在二维网格和字典中出现的单词。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

**示例**:

```
输入: 
words = ["oath","pea","eat","rain"] and board =
[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]

输出: ["eat","oath"]
```

**说明**:

你可以假设所有输入都由小写字母 `a-z` 组成。

### 解答

* 时间复杂度：O()
* 空间复杂度：O()

```c++
class node
{
public:
    node()
    {
        for(int i=0;i<26;i++)
            arr[i] = nullptr;
    }
    
    node* arr[26];
    string s;
};

class Trie
{
public:
    node* root;
    
    Trie()
    {
        root = nullptr;
    }
    
    void insert(const string& word)
    {
        if(word.empty()) return;
        if(!root) root = new node;
        auto temp = root;
        for(int i=0;i<word.size();i++)
        {
            char ch = word[i];
            int idx = ch - 'a';
            if(!temp->arr[idx])
                temp->arr[idx] = new node;
            
            temp = temp->arr[idx];
        }
        
        temp->s = word;
    }
    
    bool inTrie(const string& word)
    {
        auto temp = root;
        if(!root) return false;
        
        for(auto ch : word)
        {
            int idx = ch - 'a';
            if(temp->arr[idx])
            {
                temp = temp->arr[idx];
            }
            else
                return false;
        }
        
        return true;
    }
    
};


class Solution {
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        if(board.empty() || words.empty()) return vector<string>();
        
        vector<string> vec;
        Trie* tree = new Trie;
        for(auto word : words)
        {
            tree->insert(word);
        }
        
        int row = board.size();
        int col = board[0].size();
        vector<vector<bool>> vis(row,vector<bool>(col,false));
        
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
            {
                recursion(i,j,board,tree->root,vis,vec);
            }
        
        sort(vec.begin(),vec.end());
        return vec;
    }
    
    void recursion(int i,int j,vector<vector<char>>& board,node* tree,vector<vector<bool>>& vis,vector<string>& vec)
    {
        int row = board.size();
        int col = board[0].size();
        if(i < 0 || i >= row || j < 0 || j >= col || vis[i][j] || !tree->arr[board[i][j] - 'a'])
            return;
        
        int idx = board[i][j] - 'a';
        tree = tree->arr[idx];
        
        if( !(tree->s.empty()) )
        {
            vec.push_back(tree->s);
            tree->s.clear();
        }
        
        
        vis[i][j] = true;
        recursion(i-1,j,board,tree,vis,vec);
        recursion(i+1,j,board,tree,vis,vec);
        recursion(i,j-1,board,tree,vis,vec);
        recursion(i,j+1,board,tree,vis,vec);
        vis[i][j] = false;
    }
};
```
