* **图总结**
   * **广度优先搜索**
      * [单词接龙](#单词接龙) (`medium`)
   * **深度优先搜索**
      * [岛屿的个数](#岛屿的个数) (`medium`)
      * [被围绕的区域](#被围绕的区域) (`medium`)
      * [矩阵中的最长递增路径](#矩阵中的最长递增路径) (`hard` `动态规划`)

   * **并查集**
     * [冗余连接](#冗余连接) (`medium`)
     * [朋友圈](#朋友圈) (`medium`)

   * **其他**
      * [课程表](#课程表) (`medium` `拓扑排序`)
      * [课程表II](#课程表II) (`medium` `拓扑排序`)

# 图总结
## 课程表

[LeetCode链接](https://leetcode-cn.com/problems/course-schedule/)

现在你总共有 `n` 门课需要选，记为 `0` 到 `n-1`。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: `[0,1]`

给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？

**示例 1**:
```
输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。
```

**示例 2**:
```
输入: 2, [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。
```

说明:

* 输入的先决条件是由**边缘列表**表示的图形，而不是邻接矩阵。详情请参见图的表示法。
* 你可以假定输入的先决条件中没有重复的边。

### 解答

* 时间复杂度：O()
* 空间复杂度：O()

```c++
class Solution {
public:
    bool canFinish(int numCourses, vector<pair<int, int>>& prerequisites) {
        vector<vector<int >> graph(numCourses,vector<int>(0));
        vector<int> degree(numCourses,0);
        for(auto a:prerequisites)
        {
            int from=a.second;
            int to=a.first;
            graph[from].push_back(to);
            degree[to]++;
        }
        
        queue<int> que;
        for(int i=0;i<degree.size();i++)
        {
            if(degree[i]==0)
                que.push(i);
        }
        
        int cnt=0;
        while(!que.empty())
        {
            int a=que.front();
            que.pop();
            
            for(auto b:graph[a])
            {
                degree[b]--;
                if(degree[b]==0)
                    que.push(b);
            }
            cnt++;
        }
        
        if(cnt==numCourses)
            return true;
        else
            return false;
    }
};
```



## 课程表II

[LeetCode链接](https://leetcode-cn.com/problems/course-schedule-ii/)

现在你总共有 `n` 门课需要选，记为 `0` 到 `n-1`。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: `[0,1]`

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

**示例 1**:
```
输入: 2, [[1,0]] 
输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
```

**示例 2**:
```
输入: 4, [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
```

**说明**:

* 输入的先决条件是由**边缘列表**表示的图形，而不是邻接矩阵。详情请参见图的表示法。
* 你可以假定输入的先决条件中没有重复的边。

### 解答

* 时间复杂度：O()
* 空间复杂度：O()

```c++
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {
        vector<vector<int >> graph(numCourses,vector<int>(0));
        vector<int> degree(numCourses,0);
        for(auto a:prerequisites)
        {
            int from=a.second;
            int to=a.first;
            graph[from].push_back(to);
            degree[to]++;
        }
        
        queue<int> que;
        for(int i=0;i<degree.size();i++)
        {
            if(degree[i]==0)
                que.push(i);
        }
        
        vector<int> res;
        int cnt=0;
        while(!que.empty())
        {
            int a=que.front();
            que.pop();
            res.push_back(a);
            
            for(auto b:graph[a])
            {
                degree[b]--;
                if(degree[b]==0)
                    que.push(b);
            }
            cnt++;
        }
        
        if(cnt==numCourses)
            return res;
        else
            return vector<int>(0);
    }
};
```


## 单词接龙

[LeetCode链接](https://leetcode-cn.com/problems/word-ladder/)

给定两个单词（*beginWord* 和 *endWord*）和一个字典，找到从 *beginWord* 到 *endWord* 的最短转换序列的长度。转换需遵循如下规则：

1. 每次转换只能改变一个字母。
2. 转换过程中的中间单词必须是字典中的单词。

**说明**:

* 如果不存在这样的转换序列，返回 0。
* 所有单词具有相同的长度。
* 所有单词只由小写字母组成。
* 字典中不存在重复的单词。
* 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。

**示例 1**:
```
输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

输出: 5

解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",
     返回它的长度 5。
```

**示例 2**:
```
输入:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

输出: 0

解释: endWord "cog" 不在字典中，所以无法进行转换。
```

### 解答

* 时间复杂度：O()
* 空间复杂度：O()

```c++
class Solution {
public:
    bool isNext(string str1,string str2)
    {
        int len1=str1.size();
        int len2=str2.size();
        if(len1!=len2)
            return false;
        
        int cnt=0;
        for(int i=0;i<len1;i++)
        {
            if(str1[i]!=str2[i])
                cnt++;
        }
        if(cnt==1)
            return true;
        
        return false;
    }
    
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        if(beginWord==endWord)
            return 0;
        
        int len = wordList.size();
        queue<string> que;
        vector<int> visited(len,false);
        que.push(beginWord);
        int cnt = 1;
        string pre = beginWord;
        string next;
        while(!que.empty())
        {
            auto cur = que.front();
            que.pop();
            
            if(cur == endWord)
                return cnt;
            
            for(int i=0;i<len;i++)
            {
                auto s = wordList[i];
                if(!visited[i] && isNext(s,cur))
                {
                    que.push(s);
                    visited[i] = true;
                    next = s;
                }
            }
            
            if(cur == pre)
            {
                pre = next;
                cnt++;
            }
            
        }
        
        return 0;
    }
};
```



## 岛屿的个数

[LeetCode链接](https://leetcode-cn.com/problems/number-of-islands/)

给定一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。

**示例 1**:
```
输入:
11110
11010
11000
00000

输出: 1
```

**示例 2**:
```
输入:
11000
11000
00100
00011

输出: 3
```

### 解答

* 时间复杂度：O()
* 空间复杂度：O()

```c++
class Solution {
public:
    void dfs(int h,int l,vector<vector<bool>>& vec,vector<vector<char>>& grid)
    {
        if(h<0 || h>=vec.size())
            return;
        if(l<0 || l>=vec[0].size())
            return;
        
        if(grid[h][l]=='0' || vec[h][l])
            return;
        
        vec[h][l]=true;
        dfs(h,l-1,vec,grid);
        dfs(h,l+1,vec,grid);
        dfs(h-1,l,vec,grid);
        dfs(h+1,l,vec,grid);
    }
    
    int numIslands(vector<vector<char>>& grid) {
        if(grid.size()==0)
            return 0;
        
        int res=0;
        int m=grid.size();
        int n=grid[0].size();
        vector<vector<bool>> visited(m,vector<bool>(n,false));
        for(int i=0;i<m;i++)
            for(int j=0;j<n;j++)
            {
                if(grid[i][j]=='1' && !visited[i][j])
                {
                    res++;
                    dfs(i,j,visited,grid);
                }
            }
        
        return res;
    }
};
```



## 被围绕的区域

[LeetCode链接](https://leetcode-cn.com/problems/surrounded-regions/)

给定一个二维的矩阵，包含 `'X'` 和 `'O'`（**字母 O**）。

找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。

**示例**:
```
X X X X
X O O X
X X O X
X O X X
```
运行你的函数后，矩阵变为：
```
X X X X
X X X X
X X X X
X O X X
```
**解释**:

被围绕的区间不会存在于边界上，换句话说，任何边界上的 `'O'` 都不会被填充为 `'X'`。 任何不在边界上，或不与边界上的 `'O'` 相连的 `'O'` 最终都会被填充为 `'X'`。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。

### 解答

* 时间复杂度：O()
* 空间复杂度：O()

```c++
class Solution {
public:
    void dfs(int x,int y,vector<vector<char>>& vec)
    {
        int row = vec.size();
        int col = vec[0].size();
        if(x < 0 || y < 0 || x >= row || y >= col || vec[x][y] != 'O')
            return;
        
        vec[x][y] = '$';
        
        dfs(x+1,y,vec);
        dfs(x-1,y,vec);
        dfs(x,y+1,vec);
        dfs(x,y-1,vec);
    }
    
    void solve(vector<vector<char>>& board) {
        if(board.empty()) return;
        
        int row = board.size();
        int col = board[0].size();
        
        int i=0,j=0;
        for(;j<col;j++)
        {
            if(board[i][j] == 'O')
                dfs(i,j,board);
        }
        
        j = col-1;
        for(;i<row;i++)
        {
            if(board[i][j] == 'O')
                dfs(i,j,board);
        }
        
        i = row-1;
        for(;j>=0;j--)
        {
            if(board[i][j] == 'O')
                dfs(i,j,board);
        }
        
        j=0;
        for(;i>=0;i--)
        {
            if(board[i][j] == 'O')
                dfs(i,j,board);
        }
        
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
            {
                if(board[i][j] == 'O')
                    board[i][j] = 'X';
            }
        
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
            {
                if(board[i][j] == '$')
                    board[i][j] = 'O';
            }
    }
};
```



## 矩阵中的最长递增路径

[LeetCode链接](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)

给定一个整数矩阵，找出最长递增路径的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。

**示例 1**:
```
输入: nums = 
[
  [9,9,4],
  [6,6,8],
  [2,1,1]
] 
输出: 4 
解释: 最长递增路径为 [1, 2, 6, 9]。
```

**示例 2**:
```
输入: nums = 
[
  [3,4,5],
  [3,2,6],
  [2,2,1]
] 
输出: 4 
解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。
```

### 解答

* 时间复杂度：O()
* 空间复杂度：O()

```c++
class Solution {
public:
    int recursion(int x,int y,const vector<vector<int>>& vec,vector<vector<int>>& dp)
    {
        if(dp[x][y] != 0)
            return dp[x][y];
        
        int row = vec.size();
        int col = vec[0].size();
        
        dp[x][y] = 1;
        
        if(x > 0 && vec[x-1][y] > vec[x][y])
        {
            int cnt = recursion(x-1,y,vec,dp) + 1;
            dp[x][y] = max(dp[x][y],cnt);
        }
        
        if(x < row - 1 && vec[x+1][y] > vec[x][y])
        {
            int cnt = recursion(x+1,y,vec,dp) + 1;
            dp[x][y] = max(cnt,dp[x][y]);
        }
        
        if(y > 0 && vec[x][y-1] > vec[x][y])
        {
            int cnt = recursion(x,y-1,vec,dp) + 1;
            dp[x][y] = max(dp[x][y],cnt);
        }
        
        if(y < col - 1 && vec[x][y+1] > vec[x][y])
        {
            int cnt = recursion(x,y+1,vec,dp) + 1;
            dp[x][y] = max(dp[x][y],cnt);
        }
        
        return dp[x][y];
    }
    
    
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        if(matrix.empty()) return 0;
        
        int row = matrix.size();
        int col = matrix[0].size();
        
        vector<vector<int>> dp(row,vector<int>(col,0));
        int res = INT_MIN;
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
            {
                int a = recursion(i,j,matrix,dp);
                res = max(res,a);
            }
        
        return res;
    }
};
```



## 冗余连接

[LeetCode链接](https://leetcode-cn.com/problems/redundant-connection/)

在本问题中, 树指的是一个连通且无环的**无向**图。

输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组。每一个边的元素是一对`[u, v]` ，满足 `u < v`，表示连接顶点`u` 和`v`的**无向**图的边。

返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 `[u, v]` 应满足相同的格式 `u < v`。

**示例 1**：

```
输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的无向图为:
  1
 / \
2 - 3
```

**示例 2**：

```
输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
解释: 给定的无向图为:
5 - 1 - 2
    |   |
    4 - 3
```

**注意**:

- 输入的二维数组大小在 3 到 1000。
- 二维数组中的整数在1到N之间，其中N是输入数组的大小。

### 解答

- 时间复杂度：O()
- 空间复杂度：O()

```c++

```



## 朋友圈

[LeetCode链接](https://leetcode-cn.com/problems/friend-circles/)

班上有 **N** 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。

给定一个 `N * N` 的矩阵 **M**，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生**互为**朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。

**示例 1**:

```
输入: 
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出: 2 
说明：已知学生0和学生1互为朋友，他们在一个朋友圈。
第2个学生自己在一个朋友圈。所以返回2。
```

**示例 2**:

```
输入: 
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出: 1
说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。
```

**注意**：

- N 在[1,200]的范围内。
- 对于所有学生，有M[i][i] = 1。
- 如果有M[i][j] = 1，则有M[j][i] = 1。

### 解答

- 时间复杂度：O()
- 空间复杂度：O()

```c++
class UnionSet
{
public:
    UnionSet(int n)
    {
        for(int i=0;i<n;i++)
        {
            fatherMp[i] = i;
            sizeMp[i] = 1;
        }
    }
    
    bool isSameSet(int node1,int node2)
    {
        return findHead(node1) == findHead(node2);
    }
    
    void Union(int node1,int node2)
    {
        int head1 = findHead(node1);
        int head2 = findHead(node2);
        
        if(head1 == head2)
            return;
        
        if(sizeMp[head1] <= sizeMp[head2])
        {
            fatherMp[head1] = head2;
            sizeMp[head2] = sizeMp[head1] + sizeMp[head2];
            sizeMp.erase(head1);
        }
        else{
            fatherMp[head2] = head1;
            sizeMp[head1] = sizeMp[head1] + sizeMp[head2];
            sizeMp.erase(head2);
        }
    }
    
    int findHead(int node)
    {
        //递归找集合的根
        int head;
        if(fatherMp[node] == node)
            return node;
        else{
            head = findHead(fatherMp[node]);
        }
        
        return head;
    }

    
    int getSize()
    {
        return sizeMp.size();
    }
private:
    unordered_map<int,int> fatherMp,sizeMp;
};

class Solution {
public:
    int findCircleNum(vector<vector<int>>& M) {
        if(M.empty())
            return 0;
        
        int size = M[0].size();
        UnionSet st(size);
        for(int i=0;i<size;i++)
        {
            for(int j=i+1;j<size;j++)
            {
                if(M[i][j] == 1)
                {
                    st.Union(i,j);
                }
            }
        }
        
        return st.getSize();
    }
};
```

