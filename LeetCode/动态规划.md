* **动态规划总结**
   * [爬楼梯](#爬楼梯) (`easy`)
   * [买卖股票的最佳时机](#买卖股票的最佳时机) (`easy`)
   * [最大子序和](#最大子序和) (`easy`)
   * [打家劫舍](#打家劫舍) (`easy`)
   * [最小路径和](#最小路径和) (`medium`)
   * [不同路径](#不同路径) (`medium`)
   * [判断子序列](#判断子序列) (`medium` `双指针`)
   * [三角形最小路径和](#三角形最小路径和) (`medium`)
   * [最大上升子序列](#最大上升子序列) (`medium` `贪心`)
   * [最大正方形](#最大正方形) (`medium`)
   * [摆动序列](#摆动序列) (`medium` `贪心`)
   * [零钱兑换](#零钱兑换) (`medium`)
   * [最大回文子串](#最大回文子串) (`medium`)
   * [戳气球](#戳气球) (`hard`)
   * [买卖股票的最佳时机III](#买卖股票的最佳时机III) (`hard`)
   * [俄罗斯套娃信封问题](#俄罗斯套娃信封问题) (`hard`)

     
# 动态规划总结
## 爬楼梯

[LeetCode链接](https://leetcode-cn.com/problems/climbing-stairs)

* python代码

```python
class Solution:
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 0:
            return 0
        elif n == 1:
            return 1
        elif n == 2:
            return 2
        
        dp = list()
        dp.append(1)
        dp.append(2)
        
        for i in range(2,n):
            dp.append(dp[i-1] + dp[i-2])
            
        return dp[-1]
```

## 买卖股票的最佳时机 

[LeetCode链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)

**解答**：[方法详解](https://leetcode-cn.com/articles/best-time-to-buy-and-sell-stock/)

* c++代码

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        
        int len = prices.size();
        vector<int> dp(len,0);
        int max = 0;
        int min = prices[0];
        for(int i=1;i<len;i++)
        {
            dp[i] = prices[i]-min;
            if(prices[i]<min)
            {
                 min = prices[i];
            }
	    
            if(max < dp[i]) max = dp[i];
        }
	
        return max;
    }
};
```

* 空间优化

* c++代码

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        
        int len = prices.size();
        int maxp = 0;
        int minp = prices[0];
        for(int i=1;i<len;i++)
        {
            if(prices[i] - minp > maxp)
            {
                maxp = prices[i] - minp;
            }
            else if(prices[i] < minp)
            {
                 minp = prices[i];
            }
            
        }
        return maxp;
    }
};
```

## 最大子序和

[LeetCode链接](https://leetcode-cn.com/problems/maximum-subarray)

**解答**：

方法1：动态规划，dp[i]表示已数字nums[i]结尾的连续子数组的最大子序和，动态转移方程为：
  1. 若dp[i-1] < 0,则dp[i] = nums[i]
  2. 若dp[i-1] > 0,则dp[i] = dp[i-1] + nums[i]
其中nums[i]表示遍历到的元素（`i范围是0~nums.size()-1`），求出dp数组元素的**最大值**就是整个数组的最大子序和。因为需要开辟数组dp，空间复杂度O(n)，而时间复杂度为O(n)

方法2：优化空间复杂度，sum变量表示**可能的最大子序和**，Max变量表示**最大子序和**。遍历数组，每遍历到一个元素nums[i],先判断sum的值的正负，分两种情况：
   1. sum < 0，重新赋值sum = nums[i]
   2. sum >= 0，累加sum += nums[i]
   
每遍历一个元素nums[i],都将sum和Max比较，赋值Max为两者较大值，即Max = max(Max,sum)，最终Max就是整个数组的最大子序和。此方法不需要开辟数组dp，只需要用两个变量sum和Max，空间复杂度为O(1),时间复杂度为O(n)

这里举例说明：例如-2,1,2,-3组成的数组，当遍历到1的时候，sum = -1为负，那么在当前元素2加上之前元素累加得到的负数sum不可能是最大子序和，在这种情况下，令sum = 当前元素，忽略前面已经累加得到的负值；否则，直接在sum上累加当前元素

* 方法一c++代码

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int len=nums.size();
        if(len==0)
            return 0;
        
        vector<int> dp(len,0);
        dp[0]=nums[0];
        int max=nums[0];
        for(int i=1;i<len;i++)
        {
            if(dp[i-1]<0)
                dp[i]=nums[i];
            else
                dp[i]=dp[i-1]+nums[i];
            
            if(dp[i]>max)
                max=dp[i];
        }
        return max;
    } 
};
```

* 方法二（空间优化）c++代码
```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if(nums.empty()) return 0;
        
        int len = nums.size();
        int sum = 0;
        int Max = INT_MIN;
        for(int i=0;i<len;i++)
        {
            if(sum < 0)
            {
                sum = nums[i];
            }
            else
                sum += nums[i];
            
            Max = max(sum,Max);
        }
        
        return Max;
    }
};
```



## 打家劫舍
[LeetCode链接](https://leetcode-cn.com/problems/house-robber)

**解答**：[参考博客](https://www.cnblogs.com/grandyang/p/4383632.html)

* c++代码

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.empty()) return 0;
        
        int len = nums.size();
        if(len == 1) return nums[0];
        
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        dp[1] = max(nums[1],nums[0]);
       //int res = max(dp[0],dp[1]);
        for(int i=2;i<len;i++)
        {
            dp[i]  =max(dp[i-1] , nums[i] + dp[i-2]);
            
            //res = max(res,dp[i]);
        }
        
        return dp.back();
    }
};
```

* python代码

```python
class Solution:
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        
        sum_odd = 0
        sum_even = 0
        for i,num in enumerate(nums):
            if i%2 == 0:
                sum_even = max(num + sum_even , sum_odd)
            else:
                sum_odd = max(num + sum_odd , sum_even)
        
        return max(sum_odd,sum_even)
```

## 最小路径和
[LeetCode链接](https://leetcode-cn.com/problems/minimum-path-sum)

**解答**：

经典dp最小路径问题，dp[i][j]表示到位置grid[i][j]的最小路径和

动态转移方程：dp[i][j] = min{dp[i-1][j],dp[i][j-1]} + dp[i-1][j-1],时间复杂度O(n^2),空间复杂度O(n^2)

* c++代码

```c++
class Solution {
public:
    int getMin(int a,int b)
    {
        return a<b?a:b;
    }
    
    int minPathSum(vector<vector<int>>& grid) {
        int h=grid.size();
        int l=grid[0].size();
        vector<vector<int>> dp(h,vector<int>(l,0));
        
        dp[0][0]=grid[0][0];
        for(int i=1;i<h;i++)
        {
            dp[i][0]=dp[i-1][0]+grid[i][0];
        }
        for(int i=0;i<l;i++)
        {
            dp[0][i]=dp[0][i-1]+grid[0][i];
        }
        
        for(int i=1;i<h;i++)
        {
            for(int j=1;j<l;j++)
            {
                dp[i][j]=getMin(dp[i-1][j],dp[i][j-1])+grid[i][j];
            }
        }
        
        return dp[h-1][l-1];
    }
};
```

## 不同路径
[LeetCode链接](https://leetcode-cn.com/problems/unique-paths)

**解答**：

类同路径和问题，设dp[i][j]表示到网格中i行j列位置的路径数：

动态转移方程：dp[i][j] = dp[i-1][j] + dp[i][j-1],时间复杂度O(m*n),空间复杂度O(m*n)

* c++代码

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        if(m==0 || n==0)
            return 0;
        
        vector<vector<int>> dp(n,vector<int>(m,0));
        for(int i=0;i<m;i++)
            dp[0][i]=1;
        for(int j=1;j<n;j++)
            dp[j][0]=1;
        
        for(int i=1;i<n;i++)
        {
            for(int j=1;j<m;j++)
            {
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[n-1][m-1];
    }
};
```

## 判断子序列
[LeetCode链接](https://leetcode-cn.com/problems/is-subsequence)

**解答**:

方法1：双指针

方法2：动态规划

* 方法一c++代码

```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int len = s.size();
        int len1 = t.size();
        
        if(len > len1) return false;
        int i=0,j=0;
        while(i < len && j < len1)
        {
            if(s[i] == t[j])
            {
                i++;
               
            }
            
            j++;
        }
        
        if(i == len) return true;
        return false;
    }
};
```

## 三角形最小路径和
[LeetCode链接](https://leetcode-cn.com/problems/triangle)

**解答**:

方法1：设dp[i][j]表示从底部到点triangle[i][j]走过的最短路径和

动态转移方程为：dp[i][j] = triangle[i][j] + min(dp[i+1][j],dp[i+1][j+1]) (i = 0~row-1 );

时间复杂度O(n^2),空间复杂度O(n^2)

方法2：空间优化，自下向上计算的时候，因为当计算出dp[i][j]之后，dp[i+1][j]就不用了，所以可以重复利用大小为n的数组，只需要开辟一维数组dp

动态转移方程为： dp[j] = triangle[i][j] + min( dp[j] , dp[j+1]) ( i = 0~row-1 )

时间复杂度O(n^2),空间复杂度O(n)

* 方法一c++代码

```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        if(triangle.empty()) return 0;
        
        int row = triangle.size();
        int col = triangle[0].size();
        vector<vector<int>> dp;
        dp.resize(row);
        for(int i=1;i<=row;i++)
        {
            dp[i-1].resize(i,0);
        }
        
        for(int i=0;i<row;i++)
        {
            dp[row-1][i] = triangle[row-1][i];
        }
        
        for(int i=row-2;i>=0;i--)
        {
            for(int j=0;j<=i;j++)
            {
                dp[i][j] = triangle[i][j] + min(dp[i+1][j],dp[i+1][j+1]); 
            }
        }
        
        return dp[0][0];
        
    }
};
```

* 方法二c++代码

```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        if(triangle.empty()) return 0;
        
        int row = triangle.size();
        vector<int> dp(row,0);
        for(int i=0;i<row;i++)
        {
            dp[i] = triangle[row-1][i];
        }
        
        for(int i=row-2;i>=0;i--)
        {
            for(int j=0;j<=i;j++)
            {
                dp[j] = triangle[i][j] + min(dp[j],dp[j+1]);
            }
        }
        
        return dp[0];
        
    }
};
```


## 最大上升子序列
[LeetCode链接](https://leetcode-cn.com/problems/longest-increasing-subsequence)

**解答**：

方法1：设dp[i]表示以arr[i]这个数结尾的情况下，以arr[0]~arr[i]中的某个数开头的最大递增子序列长度

动态转移方程：dp[i] = max{ dp[j]+1(j=0~(i-1)),且arr[i]>arr[j] }

时间复杂度O(n^2)，空间复杂度O(n)

方法2：贪心法 + 二分查找，时间复杂度O(nlogn)（只能找出最大长度，不能找出正确的最长上升子序列）

  新建一个low数组，数组low的长度就表示**以low[i](`它在数组nums中对应的元素`)为结尾元素的LIS的长度**，那么low[i]就是**长度为i+1的LIS结尾元素的最小值**。对于一个上升子序列，显然其结尾元素越小，越有利于在后面接其他的元素，也就越可能变得更长。因此，我们只需要维护low数组，对于每一个a[i]，如果a[i] > low[当前最长的LIS长度]，就把a[i]接到当前最长的LIS后面，即low[++当前最长的LIS长度] = a[i]。

  那么，怎么维护low数组呢？ 对于遍历nums的每一个元素a[i]，如果a[i]能接到LIS后面，就接上去；否则，就用a[i]去更新low数组更新的方法是，在low数组中找到第一个大于等于a[i]的元素low[j]，用a[i]去更新low[j]。那么为什么这里要这样更新呢？尽管这样没有改变当前low数组的大小，但是会让low数组更有“潜力”在它后面接上更多的元素，也就越可能变得更长。(`这种方法的缺点：得到的low不一定是LIS对应的元素序列，只是长度相等`)。另外，如果从头到尾扫一遍low数组的话，时间复杂度仍是O(n^2)。我们注意到low数组内部一定是单调不降的，所以我们可以二分查找low数组，找出第一个大于等于a[i]的元素，直接利用STL的lower_bound函数。二分查找一次low数组的时间复杂度的O(logn)，所以总的时间复杂度是O(nlogn)。

方法3：树状数组(`待续。。。`)

* 方法一c++代码

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size() < 2) return nums.size();
        
        int len = nums.size();
        vector<int> dp(len,1);
        //dp[0] = nums[0];
        int Max = INT_MIN;
        for(int i=1;i<len;i++)
        {
            for(int j=0;j<i;j++)
            {
                if(nums[j] < nums[i])
                {
                    dp[i] = max(dp[j]+1,dp[i]);
                }
            }
            
            Max = max(Max,dp[i]);
        }
        
        return Max;
    }
};
```

* 方法二c++代码

```c++
class Solution {
public:
     void Replace(vector<int>& vec,int a)
    {
        int l=0;
        int r=vec.size()-1;
        while(l<r)
        {
            int m=l+(r-l)/2;
            if(vec[m]>a)
                r=m;
            else if(vec[m]<a)
                l=m+1;
            else return;
        }
        vec[l]=a;
    }
    
    int lengthOfLIS(vector<int>& nums) {
        //int len=nums.size();
        if(nums.size()==0) 
            return 0;
        
        vector<int> low;
        low.push_back(nums[0]);
        for(int i=1;i<nums.size();i++)
        {
            /*if(nums[i]>low.back())
                low.push_back(nums[i]);
            else{
                Replace(low,nums[i]);
            }*/
            auto iter=lower_bound(low.begin(),low.end(),nums[i]);//lower_bound 底层是使用二分查找
            if(iter==low.end())
                low.push_back(nums[i]);
            else
                *iter=nums[i];
        }
        return low.size();
    }
};
```


## 最大正方形
[LeetCode链接](https://leetcode-cn.com/problems/maximal-square/)

方法1：暴力dp,时间复杂度O(n^3)

开辟三维数组dp，设dp[i][j][d]表示以matrix[i][j]为起点，边长为d的正方形的面积（只要区域中含有‘0’，面积就是0）

动态转移方程：
  1. 当dp[i][j][d-1] > 0 且 区域外围都为‘1’ ==>  dp[i][j][d] = d * d
  2. 其他情况都为dp[i][j][d] = 0
 
方法2：优化dp，时间复杂度O(n^2)

开辟二维数组dp，设dp[i][j] 表示以点matrix[i][j]为右下角时，所含有的充满‘1’的正方形的最大边长

动态转移方程：dp[i][j] = min( dp[i-1][j-1] , min( dp[i-1][j] , dp[i][j-1] ) ) (`这个转移方程不太容易想到，可以举例加深理解`)

最后得到dp数组中的最大元素res就是最大正方形的边长，那么最大面积就是res*res

* 方法一c++代码

```c++
class Solution {
public:
    bool is_ok(int x,int y,int d,const vector<vector<char>>& matrix)
    {
        for(int i=x;i<x+d;i++)
        {
            if(matrix[i][y+d-1] == '0')
                return false;
        }
        
        for(int i=y;i<y+d;i++)
        {
            if(matrix[x+d-1][i] == '0')
                return false;
        }
        
        return true;
    }
    
    int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.empty()) return 0;
        
        const int row = matrix.size();
        const int col = matrix[0].size();
        int res = 0;
        
        const int dmax = min(col,row);
        vector<vector<vector<int>>> dp;
        dp.resize(row);
	    for(int i=0;i<row;i++)
	   {
		  dp[i].resize(col);
	   }

	   for(int i=0;i<row;i++)
	   {
		 for(int j=0;j<col;j++)
		 {
			dp[i][j].resize(dmax+1,0);
		 }
	   }
        
        for(int i=0;i<row;i++)
           for(int j=0;j<col;j++)
            {
                dp[i][j][1] = matrix[i][j] == '1' ? 1 : 0;
                res = max(res,dp[i][j][1]);
            }
        
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
                for(int k=2;k<=min(row-i,col-j);k++)
                {
                    if(dp[i][j][k-1] > 0 && is_ok(i,j,k,matrix))
                        dp[i][j][k] = k*k;
                    else
                        dp[i][j][k] = 0;
                    
                    res = max(dp[i][j][k],res);
                }
        
        return res;
    }
};
```

* 方法二c++代码

```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.empty()) return 0;
        
        const int row = matrix.size();
        const int col = matrix[0].size();
        int res = 0;
        
        vector<vector<int>> dp(row,vector<int>(col,0));
        for(int i=0;i<row;i++)
        {
            if(matrix[i][0] == '1')
            {
                res = 1;
                dp[i][0] = 1;
            }
        }
        
        for(int j=0;j<col;j++)
        {
            if(matrix[0][j] == '1')
            {
                res = 1;
                dp[0][j] = 1;
            }
            
        }
        
        for(int i=1;i<row;i++)
            for(int j=1;j<col;j++)
            {
                if(matrix[i][j] == '1')
                {
                    dp[i][j] = min( dp[i-1][j-1] , min(dp[i-1][j],dp[i][j-1]) ) + 1;
                    res = max(res,dp[i][j]);
                }
            }
        
        return res*res;
    }
};
```

## 摆动序列
[LeetCode链接](https://leetcode-cn.com/problems/wiggle-subsequence/submissions/)

**解答**：

方法1：动态规划

开辟两个dp数组dp1和dp2，其中dp[i]表示**到位置i时包含的以正差值结尾的摆动子序列的最大长度**，dp2表示**到位置i时包含的以负差值结尾的摆动子序列的最大长度**，我们从i=1开始遍历数组，然后对于每个遍历到的数字，再从开头位置遍历到这个数字，然后比较nums[i]和nums[j]，分别更新对应的位置。 

动态转移方程：  
dp1[i] = max{dp2[j]+1 (0 =< j <= i-1 且 nums[i] > nums[j])}  
dp2[i] = max{dp1[j]+1 (0 =< j <= i-1 且 nums[i] > nums[j])}

整个数组的最长摆动子序列就是max(dp1.back(),dp2.back())。**时间复杂度O(n^2)，空间复杂度O(n)**

方法2：贪心法

基于dp的方法，优化空间，改用两个变量p和q，p表示**遍历到当前元素num[i]以正差值结尾的摆动子序列的最大长度**，q表示**遍历到当前元素num[i]以负差值结尾的摆动子序列的最大长度**。分两种情况处理：

  1. 当num[i] > num[i-1]时，p = q+1
  2. 当num[i] < num[i-1]时，q = p+1
  
整个数组的最长摆动子序列就是max(p,q)。**时间复杂度O(n)，空间复杂度O(1)**
 
* 方法一c++代码

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if(nums.empty()) return 0;
        
        vector<int> dp1(nums.size(), 1);
        vector<int> dp2(nums.size(), 1);
        for(int i = 1; i < nums.size();i++) 
        {
            for (int j = 0; j < i; j++) 
            {
                if (nums[i] > nums[j]) dp1[i] = max(dp1[i], dp2[j] + 1);
                else if (nums[i] < nums[j]) dp2[i] = max(dp2[i], dp1[j] + 1);
            }
        }
        
        return max(dp1.back(), dp2.back());
    }
};
```

* 方法二c++代码

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int p = 1, q = 1, n = nums.size();
        if(n <= 1) return n;
        
        for (int i = 1; i < n; ++i) {
            if (nums[i] > nums[i - 1]) p = q + 1;
            else if (nums[i] < nums[i - 1]) q = p + 1;
        }
        
        return max(p,q);
        //return min(n, max(p, q));
    }
};
```


## 零钱兑换
[LeetCode链接](https://leetcode-cn.com/problems/coin-change)

**解答**：动态规划
开辟一维数组，大小为amount+1(`因为数组dp是从零开始，金额最大值是amount`),设dp[i]为兑换金额i所需的最小硬币数，遍历每一个硬币，如果硬币coins[j]的金额数小于等于i
取dp = min{ dp[i - coins[j]] + 1,j = 0~coins.size()-1 },状态转移方程为：

dp[i] = min{ dp[i - coins[j]] + 1 , coins[j] <= i} (0 <= j <= coins.size())

数组初始化：dp[0] = 0,其他元素为INT_MAX

最后，dp[amount]即为所求

* c++代码

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
       if(coins.size() == 0 || amount == 0) return 0;
        
        vector<int> dp(amount+1,INT_MAX);
        dp[0]=0;
      
        for(int i=1;i<amount+1;i++)
        {
            for(int j=0;j<coins.size();j++)
            {
                if(coins[j] <= i && dp[i - coins[j]] != INT_MAX)
                {
                    dp[i] = min(dp[i],dp[i - coins[j]] + 1);
                }
            }
        }
        
        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};
```

## 最大回文子串
[LeetCode链接](https://leetcode-cn.com/problems/longest-palindromic-substring)

**解答**：

方法1：转换为公共子串问题，时间复杂度O(n<sup>2</sup>),空间复杂度O(n<sup>2</sup>)

设原来的字符串s，反转后的字符串s1，利用动态规划找出s和s1的最长公共子串即为s的最长回文子串，设dp[i][j]表示以s[0]~s[i]组成的字符串和以s1[0]~s1[j]组成的字符串并且是**以S[i]和s[j]结尾**的公共子串的长度

动态转移方程：

  1. 如果 s[i] = s[j], 那么 dp[i][j] = dp[i-1][j-1] + 1
  2. 如果 s[i] = s[j]，那么 dp[i][j] = 0

数组初始化代码如下
```
if(s[i]==s1[j])     dp[i][j]=dp[i-1][j-1]
else                  dp[i][j]=0

//数组初始化
for(int i=0;i<len;++)
{
if(s[0]==s1[i])    dp[0][i]=1;
if(s[i]==s1[0])     dp[i][0]=1; 
}
```

这种方法有一个问题：找到的公共子串不一定是回文，例如：  
s="abacdfgdcaba" , s1 = "abacdgfdcaba"  
找到的最长子串“abacd”,显然不是回文，因此需要在程序中弥补这个缺陷。  
弥补方法很简单：每次找到一个比之前更长的的公共子串时，都判断一次是否是回文

方法2：直接动态规划,时间复杂度O(n<sup>2</sup>)，空间复杂度O(n<sup>2</sup>)

开辟二维数组dp，类型bool，设dp[i][j]表示s[i]~s[j]组成的字符串是否为回文子串

动态转移方程：dp[i][j] = (s[i] == s[j]) && dp[i+1][j-1] 

初始化：先初始化一个字母和两个字母的字符串,初始化公式：

  1. 一字母：dp[i][i] = true  
  2. 两字母：dp[i][i+1] = (s[i] == s[i+1]) 

其他的按照动态转移方程类推 

[**参考详解方法三**](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/)

方法3：中心扩展算法

在数组中选取中心元素向两边扩展，直到扩展到两边的元素不相等或者到达边界，就换其他元素进行中心扩展。由于回文串的长度有奇数和偶数两种情况，因此扩展分为两种情况：

   1. 长度为奇数：以一个元素为中心，向两边扩展
   2. 长度为偶数：以两个元素为中心，向两边扩展
   
找到长度最长的那个回文子串即为所求。时间复杂度O(n<sup>2</sup>)，空间复杂度O(1)

方法4：Manacher算法(`待续。。`)


* 方法一c++代码
```c++

```

* 方法二c++代码

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        if(s.empty()) return "";
        
        int len = s.size();
        string res;
        int start = 0;
        int Max = 1;
        vector<vector<bool>> dp(len,vector<bool>(len,false));
        
        //初始化一字母
        for(int i=0;i<len;i++)
        {
            dp[i][i] = true;
        }
        
        //初始化两字母
        for(int i=0;i<len-1;i++)
        {
            if(s[i] == s[i+1])
            {
                dp[i][i+1] = true;
                start = i;
                Max = 2;
            }
        }
        
        for(int d=3;d<=len;d++)
            for(int i=0,j=i+d-1;i<len && j<len;i++,j++)
            {
                if(dp[i+1][j-1] && s[i] == s[j])
                {
                    dp[i][j] = true;
                    if(d > Max)
                    {
                        start = i;
                        Max = d;
                    }
                }
            }
        
        res = s.substr(start,Max);
        return res;
    }
};
```

* 方法三c++代码

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.size();
        if(len == 0)
            return string();
        
        string res;
        int start = 0;
        int Max = 1;
        for(int i=0;i<len;i++)
        {
            int cnt = 1;
            int l=i-1;
            int r=i+1;
            while(l >=0 && r < len && s[l] == s[r])
            {
                l--;
                r++;
                cnt += 2;
            }
            
            if(cnt > Max)
            {
                Max = cnt;
                start = l+1;
            }
        }
        
        for(int i=0;i<len-1;i++)
        {
            int cnt = 0;
            int l = i;
            int r = i+1;
            while(l >= 0 && r < len && s[l] == s[r])
            {
                l--;
                r++;
                cnt += 2;
            }
            
            if(cnt > Max)
            {
                Max = cnt;
                start = l+1;
            }
        }
        
        res = s.substr(start,Max);
        
        return res;
    }
};
```

## 戳气球
[LeetCode链接](https://leetcode-cn.com/problems/burst-balloons/)

**解答**：

开辟二维数组dp，根据题目假设nums[-1] = nums[len] = 1,所以dp长度设为len+1，并在nums数组首尾都添加1。设dp[i][j]为**戳破编号i~j的气球能获得的最大硬币数**，设k(i <= k <= j)是戳完i~j这一段气球的最后一个气球，那么dp[i][j]的可能值就是  
dp[i][k-1] + dp[k+1][j] + nums[i-1] * nums[k] * nums[j+1]，从i到j遍历所有的k，取这个结果的最大值就是dp[i][j]，动态转移方程为：

dp[i][j] = max { dp[i][k-1] + dp[k+1][j] + nums[i-1] * nums[k] * nums[j+1] }  ( i <= k <= j)

dp数组初始化：以气球段的长度为1为起始状态

dp[i][i] = nums[i-1] * nums[i] * nums[i+1] 

往后逐渐递增长度，根据状态转移方程类推即可。时间复杂度O(n<sup>3</sup>),空间复杂度O(n)

(`边界问题：注意k=start的时候，相当于start~end范围内的最左边气球最后被戳破，它右边的气球都先于它被戳破`)

* c++代码

```c++
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int len = nums.size();
        nums.push_back(1);
        nums.insert(nums.begin(),1);
        
        vector<vector<int>> dp(len+2,vector<int>(len+2,0));
        for(int i=1;i<=len;i++)
        {
            dp[i][i] = nums[i-1]*nums[i]*nums[i+1];
        }
        
        for(int l=2;l<=len;l++)
        {
            for(int start=1;start<=len-l+1;start++)
            {
                int end = start+l-1;
                for(int k=start;k<=end;k++)
                {
                    int old = dp[start][end];
                    int now = nums[start-1]*nums[k]*nums[end+1] + dp[start][k-1] + dp[k+1][end];
                    dp[start][end] = max(old,now);
                }
            }
        }
        
        return dp[1][len];
    }
};
```

## 买卖股票的最佳时机III
[LeetCode链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

**解答**：

方法1：动态规划



方法2：分治 + 贪心  
找出交易一次能获得最大利润的区间范围[b,e]（参考[买卖股票的最佳时机](#买卖股票的最佳时机)），设最大利润为max_all，再找出这个区间内交易一次亏损最多的区间[bmid,emid]，设最大亏损为max_mid < 0。同样的方法，找出左边区间[0,b-1]内交易一次能获得的最大利润max_left和右边区间[e+1,len-1]内交易一次能获得的的最大利润max_right。找出三者的最大值max(max_left,max_right,-max_mid)，那么买卖两次股票能获得最大利润有可能是以下三种情况：

  1. -max_mid最大，那么两次交易对应的区间为[b,bmid]和[emid,e]
  2. max_left最大，那么两次交易对应的区间为[0,bmid]和[emid,e]
  3. max_right最大,那么两次交易对应的区间为[b,bmid]和[emid,len-1]
  
因此找出三者的最大值max(max_left,max_right,max_mid)，两次交易的的最大利润就是max_all + max(max_left,max_right,max_mid)，时间复杂度O(n),空间复杂度O(1)

* 方法一c++代码

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        
        int len = prices.size();
        vector<vector<int>> global(3,vector<int>(len,0));
        vector<vector<int>> local(3,vector<int>(len,0));
        for(int i=1;i<=2;i++)
            for(int j=1;j<len;j++){
                int diff = prices[j] - prices[j-1];
                local[i][j] = max(global[i-1][j-1] + max(diff,0), local[i][j-1] + diff);
                global[i][j] = max(local[i][j] , global[i][j-1]);
            }
        
        return global[2][len-1];
        
    }
};
```

* 方法二c++代码

```c++
class sub
{
public:
   int b;
   int e;
};


class Solution {
public:
    int max_sub(vector<int> vec,int l,int r,sub& sub)
    {
        if(l>=r) return 0;
        
        int min=l;
        int max=0;
        for(int i=l+1;i<=r;i++)
        {
            if(vec[i]>vec[min])
            {
                int tmp=vec[i]-vec[min];
                //max=max>tmp?max:tmp;
                if(tmp>max)
                {
                    max=tmp;
                    sub.b=min;
                    sub.e=i;
                }
               
            }
            else{
                min=i;
            }
        }
        return max;
    }
    
    int min_sub(vector<int> vec,int l,int r,sub& sub)
    {
        if(l>=r) return 0;
        
        int max=l;
        int min=0;
        
        for(int i=l+1;i<=r;i++)
        {
            if(vec[i]<vec[max])
            {
                int tmp=vec[i]-vec[max];
                if(tmp<min)
                {
                    min=tmp;
                    sub.b=max;
                    sub.e=i;
                }
               
            }
            else{
                max=i;
            }
        }
        return min;
    }
    
    int maxProfit(vector<int>& prices) {
        int len=prices.size();
        if(len==0) return 0;
        
        sub sub_all,sub_mid,sub_left,sub_right;
        int max_all = max_sub(prices,0,len-1,sub_all);
        
        int max_mid = -min_sub(prices,sub_all.b,sub_all.e,sub_mid);
        int max_left = max_sub(prices,0,sub_all.b-1,sub_left);
        int max_right = max_sub(prices,sub_all.e+1,len-1,sub_right);
        
        if(max_all == 0) return 0;
        
        return max(max(max_left,max_mid),max_right) + max_all;
        
    }
};
```

## 俄罗斯套娃信封问题

方法1：dp
方法2：贪心
此题是最长上升子序列的进阶
[方法详解](https://www.jianshu.com/p/9d9495ef4372)

c++代码
```c++
class Solution {
public:
    int maxEnvelopes(vector<pair<int, int>>& envelopes) {
        if(envelopes.empty()) return 0;
        
        int n = envelopes.size();
        sort(envelopes.begin(),envelopes.end(),[](const pair<int,int>& pr1,const pair<int,int>& pr2)
             {return pr1.first < pr2.first || (pr1.first == pr2.first && pr1.second > pr2.second);});
        
        vector<int> vec;
        for(auto a : envelopes)
        {
            int tmp = a.second;
            auto it = lower_bound(vec.begin(),vec.end(),tmp);
            if(it == vec.end())
            {
                vec.push_back(tmp);
            }
            else{
                *it = tmp;
            }
        }
        
        return vec.size();
    }
};
```


