* **动态规划总结**
   * [爬楼梯](#爬楼梯) (`easy`)
   * [买卖股票的最佳时机](#买卖股票的最佳时机) (`easy`)
   * [买卖股票的最佳时机III](#买卖股票的最佳时机III) (`hard` `分治`)
   * [最大子序和](#最大子序和) (`easy`)
   * [打家劫舍](#打家劫舍) (`easy`)
   * [最小路径和](#最小路径和) (`medium`)
   * [不同路径](#不同路径) (`medium`)
   * [三角形最小路径和](#三角形最小路径和) (`medium`)
   * [最大上升子序列](#最大上升子序列) (`medium` `贪心`)
   * [俄罗斯套娃信封问题](#俄罗斯套娃信封问题) (`hard` `贪心`)
   * [最大正方形](#最大正方形) (`medium`)
   * [摆动序列](#摆动序列) (`medium` `贪心`)
   * [零钱兑换](#零钱兑换) (`medium` `背包问题`)
   * [最大回文子串](#最大回文子串) (`medium`)
   * [无重复字符的最长子串](#无重复字符的最长子串) (`medium` `hash` `滑动窗口`)
   * [戳气球](#戳气球) (`hard`)
   
   

     
# 动态规划总结
## 爬楼梯
[LeetCode链接](https://leetcode-cn.com/problems/climbing-stairs)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意**：给定 n 是一个正整数。

**示例 1**：
```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2**：
```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

### 解答

* python代码

```python
class Solution:
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 0:
            return 0
        elif n == 1:
            return 1
        elif n == 2:
            return 2
        
        dp = list()
        dp.append(1)
        dp.append(2)
        
        for i in range(2,n):
            dp.append(dp[i-1] + dp[i-2])
            
        return dp[-1]
```

## 买卖股票的最佳时机 
[LeetCode链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

**示例 1**:
```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```
**示例 2**:
```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

### 解答

[方法详解](https://leetcode-cn.com/articles/best-time-to-buy-and-sell-stock/)

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        
        int len = prices.size();
        vector<int> dp(len,0);
        int max = 0;
        int min = prices[0];
        for(int i=1;i<len;i++)
        {
            dp[i] = prices[i]-min;
            if(prices[i]<min)
            {
                 min = prices[i];
            }
	    
            if(max < dp[i]) max = dp[i];
        }
	
        return max;
    }
};
```

* 空间优化

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        
        int len = prices.size();
        int maxp = 0;
        int minp = prices[0];
        for(int i=1;i<len;i++)
        {
            if(prices[i] - minp > maxp)
            {
                maxp = prices[i] - minp;
            }
            else if(prices[i] < minp)
            {
                 minp = prices[i];
            }
            
        }
        return maxp;
    }
};
```

## 最大子序和
[LeetCode链接](https://leetcode-cn.com/problems/maximum-subarray)

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例**:
```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**进阶**:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

### 解答

#### 方法1:

动态规划，dp[i]表示已数字nums[i]结尾的连续子数组的最大子序和，动态转移方程为：
  1. 若dp[i-1] < 0,则dp[i] = nums[i]
  2. 若dp[i-1] > 0,则dp[i] = dp[i-1] + nums[i]
其中nums[i]表示遍历到的元素（`i范围是0~nums.size()-1`），求出dp数组元素的**最大值**就是整个数组的最大子序和。因为需要开辟数组dp

* 空间复杂度O(n)
* 时间复杂度为O(n)

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int len=nums.size();
        if(len==0)
            return 0;
        
        vector<int> dp(len,0);
        dp[0]=nums[0];
        int max=nums[0];
        for(int i=1;i<len;i++)
        {
            if(dp[i-1]<0)
                dp[i]=nums[i];
            else
                dp[i]=dp[i-1]+nums[i];
            
            if(dp[i]>max)
                max=dp[i];
        }
        return max;
    } 
};
```

#### 方法2:

优化空间复杂度，sum变量表示**可能的最大子序和**，Max变量表示**最大子序和**。遍历数组，每遍历到一个元素nums[i],先判断sum的值的正负，分两种情况：
   1. sum < 0，重新赋值sum = nums[i]
   2. sum >= 0，累加sum += nums[i]

每遍历一个元素nums[i],都将sum和Max比较，赋值Max为两者较大值，即Max = max(Max,sum)，最终Max就是整个数组的最大子序和。此方法不需要开辟数组dp，只需要用两个变量sum和Max

这里举例说明：例如-2,1,2,-3组成的数组，当遍历到1的时候，sum = -1为负，那么在当前元素2加上之前元素累加得到的负数sum不可能是最大子序和，在这种情况下，令sum = 当前元素，忽略前面已经累加得到的负值；否则，直接在sum上累加当前元素

* 空间复杂度为O(1)
* 时间复杂度为O(n)

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if(nums.empty()) return 0;
        
        int len = nums.size();
        int sum = 0;
        int Max = INT_MIN;
        for(int i=0;i<len;i++)
        {
            if(sum < 0)
            {
                sum = nums[i];
            }
            else
                sum += nums[i];
            
            Max = max(sum,Max);
        }
        
        return Max;
    }
};
```



## 打家劫舍
[LeetCode链接](https://leetcode-cn.com/problems/house-robber)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

**示例 1**:
```
输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2**:
```
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

### 解答

[参考博客](https://www.cnblogs.com/grandyang/p/4383632.html)

* c++代码

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.empty()) return 0;
        
        int len = nums.size();
        if(len == 1) return nums[0];
        
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        dp[1] = max(nums[1],nums[0]);
       //int res = max(dp[0],dp[1]);
        for(int i=2;i<len;i++)
        {
            dp[i]  =max(dp[i-1] , nums[i] + dp[i-2]);
            
            //res = max(res,dp[i]);
        }
        
        return dp.back();
    }
};
```

* python代码

```python
class Solution:
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        
        sum_odd = 0
        sum_even = 0
        for i,num in enumerate(nums):
            if i%2 == 0:
                sum_even = max(num + sum_even , sum_odd)
            else:
                sum_odd = max(num + sum_odd , sum_even)
        
        return max(sum_odd,sum_even)
```

## 最小路径和
[LeetCode链接](https://leetcode-cn.com/problems/minimum-path-sum)

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

**示例**:
```
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```

### 解答

经典dp最小路径问题，dp[i][j]表示到位置grid[i][j]的最小路径和

动态转移方程：dp[i][j] = min{dp[i-1][j],dp[i][j-1]} + dp[i-1][j-1]

* 时间复杂度O(n<sup>2</sup>)
* 空间复杂度O(n<sup>2</sup>)

```c++
class Solution {
public:
    int getMin(int a,int b)
    {
        return a<b?a:b;
    }
    
    int minPathSum(vector<vector<int>>& grid) {
        int h=grid.size();
        int l=grid[0].size();
        vector<vector<int>> dp(h,vector<int>(l,0));
        
        dp[0][0]=grid[0][0];
        for(int i=1;i<h;i++)
        {
            dp[i][0]=dp[i-1][0]+grid[i][0];
        }
        for(int i=0;i<l;i++)
        {
            dp[0][i]=dp[0][i-1]+grid[0][i];
        }
        
        for(int i=1;i<h;i++)
        {
            for(int j=1;j<l;j++)
            {
                dp[i][j]=getMin(dp[i-1][j],dp[i][j-1])+grid[i][j];
            }
        }
        
        return dp[h-1][l-1];
    }
};
```

## 不同路径
[LeetCode链接](https://leetcode-cn.com/problems/unique-paths)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

![1](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

例如，上图是一个7 x 3 的网格。有多少可能的路径？

说明：m 和 n 的值均不超过 100。

**示例 1**:
```
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```

**示例 2**:
```
输入: m = 7, n = 3
输出: 28
```

### 解答

类同路径和问题，设dp[i][j]表示到网格中i行j列位置的路径数：

动态转移方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]

* 时间复杂度O(m * n)
* 空间复杂度O(m * n)

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        if(m==0 || n==0)
            return 0;
        
        vector<vector<int>> dp(n,vector<int>(m,0));
        for(int i=0;i<m;i++)
            dp[0][i]=1;
        for(int j=1;j<n;j++)
            dp[j][0]=1;
        
        for(int i=1;i<n;i++)
        {
            for(int j=1;j<m;j++)
            {
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[n-1][m-1];
    }
};
```


## 三角形最小路径和
[LeetCode链接](https://leetcode-cn.com/problems/triangle)

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：
```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
```

自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

**说明**：

如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。

### 解答
#### 方法1:

设dp[i][j]表示从底部到点triangle[i][j]走过的最短路径和

动态转移方程为：dp[i][j] = triangle[i][j] + min(dp[i+1][j],dp[i+1][j+1]) (i = 0~row-1 );

* 时间复杂度O(n<sup>2</sup>)
* 空间复杂度O(n<sup>2</sup>)

```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        if(triangle.empty()) return 0;
        
        int row = triangle.size();
        int col = triangle[0].size();
        vector<vector<int>> dp;
        dp.resize(row);
        for(int i=1;i<=row;i++)
        {
            dp[i-1].resize(i,0);
        }
        
        for(int i=0;i<row;i++)
        {
            dp[row-1][i] = triangle[row-1][i];
        }
        
        for(int i=row-2;i>=0;i--)
        {
            for(int j=0;j<=i;j++)
            {
                dp[i][j] = triangle[i][j] + min(dp[i+1][j],dp[i+1][j+1]); 
            }
        }
        
        return dp[0][0];
        
    }
};
```

#### 方法2:

空间优化，自下向上计算的时候，因为当计算出dp[i][j]之后，dp[i+1][j]就不用了，所以可以重复利用大小为n的数组，只需要开辟一维数组dp

动态转移方程为： dp[j] = triangle[i][j] + min( dp[j] , dp[j+1]) ( i = 0~row-1 )

* 时间复杂度O(n<sup>2</sup>)
* 空间复杂度O(n)


```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        if(triangle.empty()) return 0;
        
        int row = triangle.size();
        vector<int> dp(row,0);
        for(int i=0;i<row;i++)
        {
            dp[i] = triangle[row-1][i];
        }
        
        for(int i=row-2;i>=0;i--)
        {
            for(int j=0;j<=i;j++)
            {
                dp[j] = triangle[i][j] + min(dp[j],dp[j+1]);
            }
        }
        
        return dp[0];
        
    }
};
```


## 最大上升子序列
[LeetCode链接](https://leetcode-cn.com/problems/longest-increasing-subsequence)

给定一个无序的整数数组，找到其中最长上升子序列的长度。

**示例**:
```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

**说明**:

* 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
* 你算法的时间复杂度应该为 O(n2) 。

**进阶**: 你能将算法的时间复杂度降低到 O(n log n) 吗?

### 解答

#### 方法1:

设dp[i]表示以arr[i]这个数结尾的情况下，以arr[0]~arr[i]中的某个数开头的最大递增子序列长度

动态转移方程：dp[i] = max{ dp[j]+1(j=0~(i-1)),且arr[i]>arr[j] }

* 时间复杂度O(n<sup>2</sup>)
* 空间复杂度O(n)

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size() < 2) return nums.size();
        
        int len = nums.size();
        vector<int> dp(len,1);
        //dp[0] = nums[0];
        int Max = INT_MIN;
        for(int i=1;i<len;i++)
        {
            for(int j=0;j<i;j++)
            {
                if(nums[j] < nums[i])
                {
                    dp[i] = max(dp[j]+1,dp[i]);
                }
            }
            
            Max = max(Max,dp[i]);
        }
        
        return Max;
    }
};
```

#### 方法2:

贪心法 + 二分查找，时间复杂度O(nlogn)（只能找出最大长度，不能找出正确的最长上升子序列）

  新建一个low数组，数组low的长度就表示**以low[i](`它在数组nums中对应的元素`)为结尾元素的LIS的长度**，那么low[i]就是**长度为i+1的LIS结尾元素的最小值**。对于一个上升子序列，显然其结尾元素越小，越有利于在后面接其他的元素，也就越可能变得更长。因此，我们只需要维护low数组，对于每一个a[i]，如果a[i] > low[当前最长的LIS长度]，就把a[i]接到当前最长的LIS后面，即low[++当前最长的LIS长度] = a[i]。

  那么，怎么维护low数组呢？ 对于遍历nums的每一个元素a[i]，如果a[i]能接到LIS后面，就接上去；否则，就用a[i]去更新low数组更新的方法是，在low数组中找到第一个大于等于a[i]的元素low[j]，用a[i]去更新low[j]。那么为什么这里要这样更新呢？尽管这样没有改变当前low数组的大小，但是会让low数组更有“潜力”在它后面接上更多的元素，也就越可能变得更长。(`这种方法的缺点：得到的low不一定是LIS对应的元素序列，只是长度相等`)。另外，如果从头到尾扫一遍low数组的话，时间复杂度仍是O(n^2)。我们注意到low数组内部一定是单调不降的，所以我们可以二分查找low数组，找出第一个大于等于a[i]的元素，直接利用STL的lower_bound函数。二分查找一次low数组的时间复杂度的O(logn)，所以总的时间复杂度是O(nlogn)。

* 时间复杂度O(nlogn)
* 空间复杂度O(n)

```c++
class Solution {
public:
     void Replace(vector<int>& vec,int a)
    {
        int l=0;
        int r=vec.size()-1;
        while(l<r)
        {
            int m=l+(r-l)/2;
            if(vec[m]>a)
                r=m;
            else if(vec[m]<a)
                l=m+1;
            else return;
        }
        vec[l]=a;
    }
    
    int lengthOfLIS(vector<int>& nums) {
        //int len=nums.size();
        if(nums.size()==0) 
            return 0;
        
        vector<int> low;
        low.push_back(nums[0]);
        for(int i=1;i<nums.size();i++)
        {
            /*if(nums[i]>low.back())
                low.push_back(nums[i]);
            else{
                Replace(low,nums[i]);
            }*/
            auto iter=lower_bound(low.begin(),low.end(),nums[i]);//lower_bound 底层是使用二分查找
            if(iter==low.end())
                low.push_back(nums[i]);
            else
                *iter=nums[i];
        }
        return low.size();
    }
};
```

#### 方法3：树状数组(`待续。。。`)

```c++

```

## 最大正方形
[LeetCode链接](https://leetcode-cn.com/problems/maximal-square/)

在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

**示例**:
```
输入: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出: 4
```

### 解答
#### 方法1

暴力dp，开辟三维数组dp，设dp[i][j][d]表示以matrix[i][j]为起点，边长为d的正方形的面积（只要区域中含有‘0’，面积就是0）

动态转移方程：
  1. 当dp[i][j][d-1] > 0 且 区域外围都为‘1’ ==>  dp[i][j][d] = d * d
  2. 其他情况都为dp[i][j][d] = 0

* 时间复杂度O(n<sup>3</sup>)
* 空间复杂度O(n<sup>3</sup>)

```c++
class Solution {
public:
    bool is_ok(int x,int y,int d,const vector<vector<char>>& matrix)
    {
        for(int i=x;i<x+d;i++)
        {
            if(matrix[i][y+d-1] == '0')
                return false;
        }
        
        for(int i=y;i<y+d;i++)
        {
            if(matrix[x+d-1][i] == '0')
                return false;
        }
        
        return true;
    }
    
    int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.empty()) return 0;
        
        const int row = matrix.size();
        const int col = matrix[0].size();
        int res = 0;
        
        const int dmax = min(col,row);
        vector<vector<vector<int>>> dp;
        dp.resize(row);
	    for(int i=0;i<row;i++)
	   {
		  dp[i].resize(col);
	   }

	   for(int i=0;i<row;i++)
	   {
		 for(int j=0;j<col;j++)
		 {
			dp[i][j].resize(dmax+1,0);
		 }
	   }
        
        for(int i=0;i<row;i++)
           for(int j=0;j<col;j++)
            {
                dp[i][j][1] = matrix[i][j] == '1' ? 1 : 0;
                res = max(res,dp[i][j][1]);
            }
        
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
                for(int k=2;k<=min(row-i,col-j);k++)
                {
                    if(dp[i][j][k-1] > 0 && is_ok(i,j,k,matrix))
                        dp[i][j][k] = k*k;
                    else
                        dp[i][j][k] = 0;
                    
                    res = max(dp[i][j][k],res);
                }
        
        return res;
    }
};
```



#### 方法2

优化dp,开辟二维数组dp，设dp[i][j] 表示以点matrix[i][j]为右下角时，所含有的充满‘1’的正方形的最大边长

动态转移方程：dp[i][j] = min( dp[i-1][j-1] , min( dp[i-1][j] , dp[i][j-1] ) ) (`这个转移方程不太容易想到，可以举例加深理解`)

最后得到dp数组中的最大元素res就是最大正方形的边长，那么最大面积就是res*res

* 时间复杂度O(n<sup>2</sup>)
* 空间复杂度O(n<sup>2</sup>)

```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.empty()) return 0;
        
        const int row = matrix.size();
        const int col = matrix[0].size();
        int res = 0;
        
        vector<vector<int>> dp(row,vector<int>(col,0));
        for(int i=0;i<row;i++)
        {
            if(matrix[i][0] == '1')
            {
                res = 1;
                dp[i][0] = 1;
            }
        }
        
        for(int j=0;j<col;j++)
        {
            if(matrix[0][j] == '1')
            {
                res = 1;
                dp[0][j] = 1;
            }
            
        }
        
        for(int i=1;i<row;i++)
            for(int j=1;j<col;j++)
            {
                if(matrix[i][j] == '1')
                {
                    dp[i][j] = min( dp[i-1][j-1] , min(dp[i-1][j],dp[i][j-1]) ) + 1;
                    res = max(res,dp[i][j]);
                }
            }
        
        return res*res;
    }
};
```

## 摆动序列
[LeetCode链接](https://leetcode-cn.com/problems/wiggle-subsequence/submissions/)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

**示例 1**:
```
输入: [1,7,4,9,2,5]
输出: 6 
解释: 整个序列均为摆动序列。
```

**示例 2**:
```
输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
```

**示例 3**:
```
输入: [1,2,3,4,5,6,7,8,9]
输出: 2
```

**进阶**:

你能否用 O(n) 时间复杂度完成此题?

### 解答

#### 方法1：动态规划

开辟两个dp数组dp1和dp2，其中dp[i]表示**到位置i时包含的以正差值结尾的摆动子序列的最大长度**，dp2表示**到位置i时包含的以负差值结尾的摆动子序列的最大长度**，我们从i=1开始遍历数组，然后对于每个遍历到的数字，再从开头位置遍历到这个数字，然后比较nums[i]和nums[j]，分别更新对应的位置。 

动态转移方程：  
dp1[i] = max{dp2[j]+1 (0 =< j <= i-1 且 nums[i] > nums[j])}  
dp2[i] = max{dp1[j]+1 (0 =< j <= i-1 且 nums[i] > nums[j])}

整个数组的最长摆动子序列就是max(dp1.back(),dp2.back())。

* 时间复杂度O(n<sup>2</sup>)
* 空间复杂度O(n)

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if(nums.empty()) return 0;
        
        vector<int> dp1(nums.size(), 1);
        vector<int> dp2(nums.size(), 1);
        for(int i = 1; i < nums.size();i++) 
        {
            for (int j = 0; j < i; j++) 
            {
                if (nums[i] > nums[j]) dp1[i] = max(dp1[i], dp2[j] + 1);
                else if (nums[i] < nums[j]) dp2[i] = max(dp2[i], dp1[j] + 1);
            }
        }
        
        return max(dp1.back(), dp2.back());
    }
};
```

#### 方法2：贪心法

基于dp的方法，优化空间，改用两个变量p和q，p表示**遍历到当前元素num[i]以正差值结尾的摆动子序列的最大长度**，q表示**遍历到当前元素num[i]以负差值结尾的摆动子序列的最大长度**。分两种情况处理：

  1. 当num[i] > num[i-1]时，p = q+1
  2. 当num[i] < num[i-1]时，q = p+1

整个数组的最长摆动子序列就是max(p,q)

* 时间复杂度O(n)
* 空间复杂度O(1)

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int p = 1, q = 1, n = nums.size();
        if(n <= 1) return n;
        
        for (int i = 1; i < n; ++i) {
            if (nums[i] > nums[i - 1]) p = q + 1;
            else if (nums[i] < nums[i - 1]) q = p + 1;
        }
        
        return max(p,q);
        //return min(n, max(p, q));
    }
};
```


## 零钱兑换
[LeetCode链接](https://leetcode-cn.com/problems/coin-change)

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

**示例 1**:
```
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```

**示例 2**:
```
输入: coins = [2], amount = 3
输出: -1
```

**说明**:

你可以认为每种硬币的数量是无限的。

### 解答

动态规划，开辟一维数组，大小为amount+1(`因为数组dp是从零开始，金额最大值是amount`),设dp[i]为兑换金额i所需的最小硬币数，遍历每一个硬币，如果硬币coins[j]的金额数小于等于i
取dp = min{ dp[i - coins[j]] + 1,j = 0~coins.size()-1 },状态转移方程为：

dp[i] = min{ dp[i - coins[j]] + 1 , coins[j] <= i} (0 <= j <= coins.size())

数组初始化：dp[0] = 0,其他元素为INT_MAX

最后，dp[amount]即为所求

* 时间复杂度O(n<sup>2</sup>)
* 空间复杂度O(n)

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
       if(coins.size() == 0 || amount == 0) return 0;
        
        vector<int> dp(amount+1,INT_MAX);
        dp[0]=0;
      
        for(int i=1;i<amount+1;i++)
        {
            for(int j=0;j<coins.size();j++)
            {
                if(coins[j] <= i && dp[i - coins[j]] != INT_MAX)
                {
                    dp[i] = min(dp[i],dp[i - coins[j]] + 1);
                }
            }
        }
        
        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};
```

## 最大回文子串
[LeetCode链接](https://leetcode-cn.com/problems/longest-palindromic-substring)

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

**示例 1**：
```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

**示例 2**：
```
输入: "cbbd"
输出: "bb"
```

### 解答

#### 方法1：

转换为公共子串问题。设原来的字符串s，反转后的字符串s1，利用动态规划找出s和s1的最长公共子串即为s的最长回文子串，设dp[i][j]表示以s[0]~s[i]组成的字符串和以s1[0]~s1[j]组成的字符串并且是**以S[i]和s[j]结尾**的公共子串的长度

动态转移方程：

  1. 如果 s[i] = s[j], 那么 dp[i][j] = dp[i-1][j-1] + 1
  2. 如果 s[i] = s[j]，那么 dp[i][j] = 0

数组初始化代码如下
```
if(s[i]==s1[j])     dp[i][j]=dp[i-1][j-1]
else                  dp[i][j]=0

//数组初始化
for(int i=0;i<len;++)
{
if(s[0]==s1[i])    dp[0][i]=1;
if(s[i]==s1[0])     dp[i][0]=1; 
}
```

这种方法有一个问题：找到的公共子串不一定是回文，例如：  
s="abacdfgdcaba" , s1 = "abacdgfdcaba"  
找到的最长子串“abacd”,显然不是回文，因此需要在程序中弥补这个缺陷。  
弥补方法很简单：每次找到一个比之前更长的的公共子串时，都判断一次是否是回文

* 时间复杂度O(n<sup>2</sup>)
* 空间复杂度O(n<sup>2</sup>)

```c++

```


### 方法2：直接动态规划

开辟二维数组dp，类型bool，设dp[i][j]表示s[i]~s[j]组成的字符串是否为回文子串

动态转移方程：dp[i][j] = (s[i] == s[j]) && dp[i+1][j-1] 

初始化：先初始化一个字母和两个字母的字符串,初始化公式：

  1. 一字母：dp[i][i] = true  
  2. 两字母：dp[i][i+1] = (s[i] == s[i+1]) 

其他的按照动态转移方程类推 

[**参考详解方法三**](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/)

* 时间复杂度O(n<sup>2</sup>)
* 空间复杂度O(n<sup>2</sup>)

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        if(s.empty()) return "";
        
        int len = s.size();
        string res;
        int start = 0;
        int Max = 1;
        vector<vector<bool>> dp(len,vector<bool>(len,false));
        
        //初始化一字母
        for(int i=0;i<len;i++)
        {
            dp[i][i] = true;
        }
        
        //初始化两字母
        for(int i=0;i<len-1;i++)
        {
            if(s[i] == s[i+1])
            {
                dp[i][i+1] = true;
                start = i;
                Max = 2;
            }
        }
        
        for(int d=3;d<=len;d++)
            for(int i=0,j=i+d-1;i<len && j<len;i++,j++)
            {
                if(dp[i+1][j-1] && s[i] == s[j])
                {
                    dp[i][j] = true;
                    if(d > Max)
                    {
                        start = i;
                        Max = d;
                    }
                }
            }
        
        res = s.substr(start,Max);
        return res;
    }
};
```

#### 方法3：中心扩展算法

在数组中选取中心元素向两边扩展，直到扩展到两边的元素不相等或者到达边界，就换其他元素进行中心扩展。由于回文串的长度有奇数和偶数两种情况，因此扩展分为两种情况：

   1. 长度为奇数：以一个元素为中心，向两边扩展
   2. 长度为偶数：以两个元素为中心，向两边扩展

找到长度最长的那个回文子串即为所求

* 时间复杂度O(n<sup>2</sup>)
* 空间复杂度O(1)

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.size();
        if(len == 0)
            return string();
        
        string res;
        int start = 0;
        int Max = 1;
        for(int i=0;i<len;i++)
        {
            int cnt = 1;
            int l=i-1;
            int r=i+1;
            while(l >=0 && r < len && s[l] == s[r])
            {
                l--;
                r++;
                cnt += 2;
            }
            
            if(cnt > Max)
            {
                Max = cnt;
                start = l+1;
            }
        }
        
        for(int i=0;i<len-1;i++)
        {
            int cnt = 0;
            int l = i;
            int r = i+1;
            while(l >= 0 && r < len && s[l] == s[r])
            {
                l--;
                r++;
                cnt += 2;
            }
            
            if(cnt > Max)
            {
                Max = cnt;
                start = l+1;
            }
        }
        
        res = s.substr(start,Max);
        
        return res;
    }
};
```

#### 方法4：Manacher算法(`待续。。`)

```c++

```

## 无重复字符的最长子串
[LeetCode链接](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1**:
```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2**:

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3**:

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

### 解答

#### 方法1：动态规划
思路：`dp[i]`表示以`i`为下标的字符结尾的最长不重复子串的长度,分两种情况处理
1. 如果`str[i]`在前面没出现，则`dp[i] = dp[i-1] + 1`；
2. 如果`str[i]`在前面出现，设在前面出现的位置为`j`，计算距离`d = i - j`
   * 如果`d > dp[i-1]`，则`dp[i] = dp[i-1] + 1`;
   * 如果`d < dp[i-1]`，则`dp[i] = d`;




* 时间复杂度O(*n<sup>2</sup>*)
* 空间复杂度O(1)

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.empty()) return 0;
        
        vector<int> dp(s.size(),0);
        dp[0] = 1;
        
        int res = 1;
        for(int i=1;i<s.size();++i)
        {
            int idx = i-1;
            while(idx >= 0 && s[idx] != s[i]) --idx;
            
            if(idx < 0) dp[i] = dp[i-1] +1;
            else{
                int d = i - idx;
                if(d > dp[i-1]) dp[i] = dp[i-1] + 1;
                else dp[i] = d;
            }
            
            res = max(dp[i],res);
        }
        
        return res;
    }
};
```

#### 方法2：动态规划+hash表
思路和 **方法1** 一样，动态规划。同时利用结构`unordered_map`作为**哈希表**，统计字符目前为止最后一次出现的**位置**(假设递推公式计算到`dp[i]`，那么哈希表统计的是`s[i]`在*0~i-1*最后出现的位置)。这样在递推计算`dp[i]`的时候，避免了在 *0~i-1* 查找`s[i]`的过程，空间换时间，降低了时间复杂度。



* 时间复杂度O(*n*)
* 空间复杂度O(*n*)

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.empty()) return 0;
        
        unordered_map<char,int> mp;
        vector<int> dp(s.size(),0);
        dp[0] = 1;
        mp[s[0]] = 0;
        
        int res = 1;
        for(int i=1;i<s.size();++i)
        {
            if(mp.count(s[i]) == 0) dp[i] = dp[i-1] +1;
            else{
                int d = i - mp[s[i]];
                if(d > dp[i-1]) dp[i] = dp[i-1] + 1;
                else dp[i] = d;
            }
            
            mp[s[i]] = i;
            
            res = max(dp[i],res);
        }
        
        return res;
    }
};
```

#### 方法3：滑动窗口+set/哈希表

[详见阅读详解方法二和方法三](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/)

1）**解法一**：滑动窗口 + `set` 



* 时间复杂度：O(*2n*) = O(*n*)，最坏情况`i`和`j`都被索引了`n`次
* 空间复杂度：O(*n*)

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.empty()) return 0;
        
        int i = 0,j = 0;
        unordered_set<char> st;
        int res = 1;
        while(i < s.size() && j < s.size())
        {
            if(st.count(s[j]) == 0)
            {
                res = max(res,j-i+1);
                st.insert(s[j++]);
            }
            else
            {
                st.erase(s[i++]);
            }
        }
        
        return res;
    }
};
```

2）**解法2**：滑动窗口 + `unordered_map`(**哈希表**)



* 时间复杂度O(*n*)，只有`j`被索引了`n`次
* 空间复杂度O(*n*)

```
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.empty()) return 0;
        
        int i = 0,j = 0;
        unordered_map<char,int> mp;
        int res = 1;
        for(int j=0;j<s.size();++j)
        {
            if(mp.count(s[j]) > 0)
            {
                i = max(mp[s[j]]+1,i);
            }
            
            mp[s[j]] = j;
            res = max(res,j-i+1);
        }
        
        return res;
    }
};
```



## 戳气球

[LeetCode链接](https://leetcode-cn.com/problems/burst-balloons/)

有 `n` 个气球，编号为 `0` 到 `n-1`，每个气球上都标有一个数字，这些数字存在数组 `nums` 中。

现在要求你戳破所有的气球。每当你戳破一个气球 `i` 时，你可以获得 `nums[left] * nums[i] * nums[right]` 个硬币。 这里的 `left` 和 `right` 代表和 `i` 相邻的两个气球的序号。注意当你戳破了气球 `i` 后，气球 `left` 和气球 `right` 就变成了相邻的气球。

求所能获得硬币的最大数量。

**说明**:

你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。
0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100

**示例**:
```
输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
```

### 解答

开辟二维数组dp，根据题目假设nums[-1] = nums[len] = 1,所以dp长度设为len+1，并在nums数组首尾都添加1。设dp[i][j]为**戳破编号i~j的气球能获得的最大硬币数**，设k(i <= k <= j)是戳完i~j这一段气球的最后一个气球，那么dp[i][j]的可能值就是  
dp[i][k-1] + dp[k+1][j] + nums[i-1] * nums[k] * nums[j+1]，从i到j遍历所有的k，取这个结果的最大值就是dp[i][j]，动态转移方程为：

dp[i][j] = max { dp[i][k-1] + dp[k+1][j] + nums[i-1] * nums[k] * nums[j+1] }  ( i <= k <= j)

dp数组初始化：以气球段的长度为1为起始状态

dp[i][i] = nums[i-1] * nums[i] * nums[i+1] 

往后逐渐递增长度，根据状态转移方程类推即可。

(`边界问题：注意k=start的时候，相当于start~end范围内的最左边气球最后被戳破，它右边的气球都先于它被戳破`)

* 时间复杂度O(n<sup>3</sup>)
* 空间复杂度O(n)

```c++
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int len = nums.size();
        nums.push_back(1);
        nums.insert(nums.begin(),1);
        
        vector<vector<int>> dp(len+2,vector<int>(len+2,0));
        for(int i=1;i<=len;i++)
        {
            dp[i][i] = nums[i-1]*nums[i]*nums[i+1];
        }
        
        for(int l=2;l<=len;l++)
        {
            for(int start=1;start<=len-l+1;start++)
            {
                int end = start+l-1;
                for(int k=start;k<=end;k++)
                {
                    int old = dp[start][end];
                    int now = nums[start-1]*nums[k]*nums[end+1] + dp[start][k-1] + dp[k+1][end];
                    dp[start][end] = max(old,now);
                }
            }
        }
        
        return dp[1][len];
    }
};
```

## 买卖股票的最佳时机III
[LeetCode链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 *两笔* 交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1**:
```
输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3
```

**示例 2**:
```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3**:
```
输入: [7,6,4,3,1] 
输出: 0 
解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。
```

### 解答
#### 方法1：动态规划

开辟两个二维数组global和local，定义global[i][j]表示到第j天最多交易i次获得的最大收益，为全局最优。local[i][j]表示到第j天最多交易i次并且最后一次交易在最后一天能获得的最大收益，为局部最优。那么动态转移方程为：

local[i][j] = max(global[i-1][j-1] + max(diff,0), local[i][j-1] + diff) (`diff表示第i天和前一天股票价格的差值`)  
global[i][j] = max(local[i][j] , global[i][j-1])

这种方法可以求出交易k次能获得最大收益global[k][len-1]，取k=2就能求出交易两次所获得的最大收益global[2][len-1]  

* 时间复杂度O(n)
* 空间复杂度O(n<sup>2</sup>)

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        
        int len = prices.size();
        vector<vector<int>> global(3,vector<int>(len,0));
        vector<vector<int>> local(3,vector<int>(len,0));
        for(int i=1;i<=2;i++)
            for(int j=1;j<len;j++){
                int diff = prices[j] - prices[j-1];
                local[i][j] = max(global[i-1][j-1] + max(diff,0), local[i][j-1] + diff);
                global[i][j] = max(local[i][j] , global[i][j-1]);
            }
        
        return global[2][len-1];
        
    }
};
```

#### 方法2：分治 + 贪心 （`优化空间复杂度`）

找出交易一次能获得最大利润的区间范围[b,e]（参考[买卖股票的最佳时机](#买卖股票的最佳时机)），设最大利润为max_all，再找出这个区间内交易一次亏损最多的区间[bmid,emid]，设最大亏损为max_mid < 0。同样的方法，找出左边区间[0,b-1]内交易一次能获得的最大利润max_left和右边区间[e+1,len-1]内交易一次能获得的的最大利润max_right。找出三者的最大值max(max_left,max_right,-max_mid)，那么买卖两次股票能获得最大利润有可能是以下三种情况：

  1. -max_mid最大，那么两次交易对应的区间为[b,bmid]和[emid,e]
  2. max_left最大，那么两次交易对应的区间为[0,bmid]和[emid,e]
  3. max_right最大,那么两次交易对应的区间为[b,bmid]和[emid,len-1]

因此找出三者的最大值max(max_left,max_right,max_mid)，两次交易的的最大利润就是max_all + max(max_left,max_right,max_mid)  

* 时间复杂度O(n)
* 空间复杂度O(1)

```c++
class sub
{
public:
   int b;
   int e;
};


class Solution {
public:
    int max_sub(vector<int> vec,int l,int r,sub& sub)
    {
        if(l>=r) return 0;
        
        int min=l;
        int max=0;
        for(int i=l+1;i<=r;i++)
        {
            if(vec[i]>vec[min])
            {
                int tmp=vec[i]-vec[min];
                //max=max>tmp?max:tmp;
                if(tmp>max)
                {
                    max=tmp;
                    sub.b=min;
                    sub.e=i;
                }
               
            }
            else{
                min=i;
            }
        }
        return max;
    }
    
    int min_sub(vector<int> vec,int l,int r,sub& sub)
    {
        if(l>=r) return 0;
        
        int max=l;
        int min=0;
        
        for(int i=l+1;i<=r;i++)
        {
            if(vec[i]<vec[max])
            {
                int tmp=vec[i]-vec[max];
                if(tmp<min)
                {
                    min=tmp;
                    sub.b=max;
                    sub.e=i;
                }
               
            }
            else{
                max=i;
            }
        }
        return min;
    }
    
    int maxProfit(vector<int>& prices) {
        int len=prices.size();
        if(len==0) return 0;
        
        sub sub_all,sub_mid,sub_left,sub_right;
        int max_all = max_sub(prices,0,len-1,sub_all);
        
        int max_mid = -min_sub(prices,sub_all.b,sub_all.e,sub_mid);
        int max_left = max_sub(prices,0,sub_all.b-1,sub_left);
        int max_right = max_sub(prices,sub_all.e+1,len-1,sub_right);
        
        if(max_all == 0) return 0;
        
        return max(max(max_left,max_mid),max_right) + max_all;
        
    }
};
```

## 俄罗斯套娃信封问题
[LeetCode链接](https://leetcode-cn.com/problems/russian-doll-envelopes/)

给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 `(w, h)` 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

**说明**:
不允许旋转信封。

**示例**:
```
输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出: 3 
解释: 最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
```

### 解答
#### 方法1：动态规划

首先将envelopes按照信封的宽度从小到大原地排序，原问题就转化为求当前数组的最长上升子序列的长度，就是求出当前数组envelopes中高度组成的最长上升子序列的长度。但是要注意一个特殊情况：当宽度相等的情况下，是不符合信封套娃要求的，所以排序的时候**将宽度相等的信封按照高度从大到小排序**，可以避免错误地被算进上升子序列。上升子序列问题详见[最大上升子序列](#最大上升子序列)

* 时间复杂度O(n<sup>2</sup>)
* 空间复杂度O(n)

```c++
class Solution {
public:
    int maxEnvelopes(vector<pair<int, int>>& envelopes) {
        if(envelopes.empty()) return 0;
        
        int len = envelopes.size();
        sort(envelopes.begin(),envelopes.end(),[](const pair<int,int>& pr1,const pair<int,int>& pr2)
             {return pr1.first < pr2.first || (pr1.first == pr2.first && pr1.second > pr2.second);});
        
        vector<int> dp(len,1);
        dp[0] = 1;
        int Max = 1;
        for(int i=1;i<len;i++)
        {
            int tmp = envelopes[i].second;
            for(int j=0;j<i;j++)
            {
                if(tmp > envelopes[j].second)
                {
                    dp[i] = max(dp[i],dp[j]+1);
                }
            }
            
            Max = max(Max,dp[i]);
        }
        
        return Max;
    }
};
```

#### 方法2：贪心

同方法1，转化成求上升子序列问题的贪心解法(`二分查找`)，详见[最大上升子序列](#最大上升子序列)

* 时间复杂度O(nlogn)
* 空间复杂度O(n)


```c++
class Solution {
public:
    int maxEnvelopes(vector<pair<int, int>>& envelopes) {
        if(envelopes.empty()) return 0;
        
        int n = envelopes.size();
        sort(envelopes.begin(),envelopes.end(),[](const pair<int,int>& pr1,const pair<int,int>& pr2)
             {return pr1.first < pr2.first || (pr1.first == pr2.first && pr1.second > pr2.second);});
        
        vector<int> vec;
        for(auto a : envelopes)
        {
            int tmp = a.second;
            auto it = lower_bound(vec.begin(),vec.end(),tmp);
            if(it == vec.end())
            {
                vec.push_back(tmp);
            }
            else{
                *it = tmp;
            }
        }
        
        return vec.size();
    }
};
```


