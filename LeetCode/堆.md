* **堆总结**
   * [数组中的第K个最大元素](#数组中的第K个最大元素) (`medium` `排序`)
   * [合并K个排序链表](#合并K个排序链表) (`hard` `优先级队列`)
   * [数据流的中位数](#数据流的中位数) (`hard` )

# 堆总结
## 数组中的第K个最大元素

[LeetCode链接](https://leetcode-cn.com/problems/kth-largest-element-in-an-array)

在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

**示例 1**:

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**示例 2**:

```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

**说明**:

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

### 解答

#### 方法1:堆

维护一个最小堆`min`，将`nums`前`k`个元素放入`min`中，然后遍历第`k`个元素之后的元素`nums[i]`(*k <= i <= len*)，比较`nums[i]`和堆顶元素`tmp`：

1. 如果`nums[i] > tmp`，则从堆中弹出堆顶元素，同时将`num[i]`放入堆中；
2. 否则，跳过

最终，遍历完`nums`所有元素之后，堆顶元素即为数组`nums`的第`k`个最大元素。

* 时间复杂度O(*n log k*)
* 空间复杂度O(*k*)

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int len=nums.size();
        if(k<=0 || len==0 || len<k)
            return 0;
        
        vector<int> min(nums.begin(),nums.begin()+k);
        make_heap(min.begin(),min.end(),greater<int>());
        
        for(int i=k;i<len;i++)
        {
            int tmp = min.front();
            if(nums[i] > tmp)
            {
                pop_heap(min.begin(),min.end(),greater<int>());
                min.pop_back();
                
                min.push_back(nums[i]);
                push_heap(min.begin(),min.end(),greater<int>());
            }
        }
        
        return min[0];
    }
};
```

#### 方法2：红黑树

利用红黑树自动排序的功能，思路和**堆的解法**类似，利用**STL**的`multiset`结构(**底层红黑树实现**),排序方式定义为`less<int>`(**从小到大**)，最终遍历完`nums`元素之后，红黑树的第一个元素即为数组第`k`个最大元素。

* 时间复杂度O(*n log k*)
* 空间复杂度O(*k*)

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int len=nums.size();
        if(k<=0 || len==0 || len<k)
            return 0;
        
        //红黑树实现
        multiset<int,less<int>> st(nums.begin(),nums.begin()+k,less<int>());
        
        for(auto it=nums.begin()+k;it!=nums.end();it++)
        {
            auto iter = st.begin();
            if(*iter < *it)
            {
                st.erase(iter);
                st.insert(*it);
            }
        }
        
        return *(st.begin());
    }
};
```

#### 方法3：快排

利用**快速排序**中的`partition`,`partition`根据所选的主元`pivot`，数组被分为三段：`< pivot`,`= piovot`,`> pivot`，设`= pivot`段的左端为`l`，右端为`r`，维护两个指针`start`和`end`，初始化`start = 0`，`end = len-1`，然后`partition`每处理一次，就比较`k-1`和`l`大小以及`k-1`和`r`大小，处理情况如下：

1. 如果`l > k-1`，则第`k`个最大元素位于`< pivot`段，令`end = l`；
2. 如果`r < k-1`，则第`k`个最大元素位于`> pivot`段，令`start = r`；
3. 如果`l <= k-1 <= r`，则找到了第`k`个最大元素，返回`nums[k-1]`。

- 时间复杂度O(*n*)
- 空间复杂度O(1)

```c++
class Solution {
public:
    pair<int,int> partition(vector<int>& vec,int l,int r)
    {
        int m = l + (r -l)/2;
        if(vec[l] > vec[r])
            swap(vec[l],vec[r]);
        if(vec[l] > vec[m])
            swap(vec[l],vec[m]);
        if(vec[m] > vec[r])
            swap(vec[m],vec[r]);
        
        swap(vec[l],vec[m]);
        int pivot=vec[l];
        int len=vec.size();
        int more=l;
        int cur=l+1;
        int less=r+1;
       
        while(cur<less)
        {
            if(vec[cur] > pivot)
            {
                swap(vec[++more],vec[cur++]);
            }
            else if(vec[cur] < pivot)
            {
                swap(vec[--less],vec[cur]);
            }
            else
                cur++;
        }
        
        swap(vec[l],vec[more]);
        more--;
        
        return make_pair(more+1,less-1);
    }
    
    int findKthLargest(vector<int>& nums, int k) {
        //快排partition实现
        int len=nums.size();
        if(k<=0 || len==0 || len<k)
            return 0;
        
       pair<int,int> pr = partition(nums,0,len-1);
        
	   int start = 0;
	   int end = len - 1;
        while(k-1 < pr.first || k-1 > pr.second)
        {
            if(k-1 < pr.first)
			{
				end = pr.first - 1;
                pr = partition(nums,start,end);
			}
            else if(k-1 > pr.second)
			{
				start = pr.second + 1;
                pr = partition(nums,start,end);
			}
        }
        
        return nums[k-1];
    }
};
```

## 合并K个排序链表

[LeetCode链接](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

**示例**:

```
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```

### 解答

要对k个链表进行合并排序，可以维护一个最小堆。步骤如下：

1. 首先将每个非空链表的表头加入最小堆；
2. 每次弹出一个堆顶元素作为链表的下一个节点，如果堆顶元素的下一个节点非空，将它加入最小堆
3. 重复步骤2，直到最小堆为空

**注意**：最小堆的元素类型是链表节点指针`ListNode*`

假设所有链表的节点总数为n

- 时间复杂度O(n logk)
- 空间复杂度O(k)

#### 方法1

使用封装的优先级队列`priority_queue`

> priority_queue的接口使用可以参考**C++ Primer第五版** 或者 **STL源码剖析**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    static bool comp(ListNode* p1,ListNode* p2)
    {
        return p1->val > p2->val;
    }
    
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode*,vector<ListNode*>,decltype(comp)*> que(comp);
        
        for(auto p : lists)
        {
            if(p) que.push(p);
        }  
        
        ListNode* dummy = new ListNode(-1);
        ListNode* cur = dummy;
        while(!que.empty())
        {
            auto tmp = que.top();
            que.pop();
            
            if(tmp->next) que.push(tmp->next);
            
            cur->next = tmp;
            cur = cur->next;
        }
        
        return dummy->next;
        
    }
};
```

#### 方法2

使用堆`heap`的接口函数`make_heap`、`push_heap`和`pop_heap`。

> heap接口的使用参考**STL源码剖析**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

inline bool comp(const ListNode* p1,const ListNode* p2)
{
    return p1->val > p2->val;
}

class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.empty())
            return nullptr;
        
        vector<ListNode*> min;
        for(auto p : lists)
        {
            if(p) min.push_back(p);
        }
        
        make_heap(min.begin(),min.end(),comp);
        
        ListNode head(0);
        ListNode* tail = &head;
        while(!min.empty())
        {
            auto cur = min.front();
            pop_heap(min.begin(),min.end(),comp);
            min.pop_back();
            
            tail->next = cur;
            tail = cur;
            
            if(cur->next)
            {
                min.push_back(cur->next);
                push_heap(min.begin(),min.end(),comp);
            }
        }
        
        return head.next;
    }
};
```

## 数据流的中位数

[LeetCode链接](https://leetcode-cn.com/problems/find-median-from-data-stream/)

中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

* void addNum(int num) - 从数据流中添加一个整数到数据结构中。
* double findMedian() - 返回目前所有元素的中位数。

**示例**：
```
addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3) 
findMedian() -> 2
```

**进阶**:

* 如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？
* 如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class MedianFinder {
public:
    /** initialize your data structure here. */
    MedianFinder() {
        
    }
    
    void addNum(int num) {
        if(max.empty())
            max.push(num);
        else{
            if(num > max.top())
                min.push(num);
            else
                max.push(num);
        }
        
        int len_max = max.size();
        int len_min = min.size();
        if(len_max - len_min > 1)
        {
            int a = max.top();
            max.pop();
            
            min.push(a);
        }
        else if(len_min - len_max > 1)
        {
            int a = min.top();
            min.pop();
            
            max.push(a);
        }
    }
    
    double findMedian() {
        int len1 = max.size();
        int len2 = min.size();
        double res;
        if(len1 == len2)
        {
            res = static_cast<double>(((double)(max.top()) + (double)(min.top()))/2.0);
        }
        else if(len1 > len2){
            res = (double)(max.top());
        }
        else 
            res = (double)(min.top());
        
        return res;
    }
    
priority_queue<int> max;
priority_queue<int,vector<int>,greater<int>> min;
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```


