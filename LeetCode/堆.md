* **堆总结**
   * [数组中的第K个最大元素](#数组中的第K个最大元素)
   * [前K个高频元素](#前K个高频元素)
   * [分割数组为连续子序列](#分割数组为连续子序列)
   * [合并K个排序链表](#合并K个排序链表)
   * [滑动窗口最大值](#滑动窗口最大值)
   * [数据流的中位数](#数据流的中位数)
   
# 堆总结
## 数组中的第K个最大元素

[LeetCode链接](https://leetcode-cn.com/problems/kth-largest-element-in-an-array)

在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

**示例 1**:
```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**示例 2**:
```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

**说明**:

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 前K个高频元素

[LeetCode链接](https://leetcode-cn.com/problems/top-k-frequent-elements/)

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

**示例 1**:
```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2**:
```
输入: nums = [1], k = 1
输出: [1]
```

**说明**：

* 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
* 你的算法的时间复杂度**必须**优于 O(*n log n*) , n 是数组的大小。

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 分割数组为连续子序列

[LeetCode链接](https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/)

输入一个按升序排序的整数数组（可能包含重复数字），你需要将它们分割成几个子序列，其中每个子序列至少包含三个连续整数。返回你是否能做出这样的分割？

**示例 1**：
```
输入: [1,2,3,3,4,5]
输出: True
解释:
你可以分割出这样两个连续子序列 : 
1, 2, 3
3, 4, 5
```

**示例 2**：
```
输入: [1,2,3,3,4,4,5,5]
输出: True
解释:
你可以分割出这样两个连续子序列 : 
1, 2, 3, 4, 5
3, 4, 5
```

**示例 3**：
```
输入: [1,2,3,4,4,5]
输出: False
```

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 合并K个排序链表

[LeetCode链接](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

**示例**:
```
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 滑动窗口最大值

[LeetCode链接]()

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 数据流的中位数

[LeetCode链接]()

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```


