* **堆总结**
   * [数组中的第K个最大元素](#数组中的第K个最大元素)
   * [前K个高频元素](#前K个高频元素)
   * [分割数组为连续子序列](#分割数组为连续子序列)
   * [合并K个排序链表](#合并K个排序链表)
   * [滑动窗口最大值](#滑动窗口最大值)
   * [数据流的中位数](#数据流的中位数)
   
# 堆总结
## 数组中的第K个最大元素

[LeetCode链接](https://leetcode-cn.com/problems/kth-largest-element-in-an-array)

在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

**示例 1**:
```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**示例 2**:
```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

**说明**:

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 前K个高频元素

[LeetCode链接](https://leetcode-cn.com/problems/top-k-frequent-elements/)

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

**示例 1**:
```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2**:
```
输入: nums = [1], k = 1
输出: [1]
```

**说明**：

* 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
* 你的算法的时间复杂度**必须**优于 O(*n log n*) , n 是数组的大小。

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 分割数组为连续子序列

[LeetCode链接](https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/)

输入一个按升序排序的整数数组（可能包含重复数字），你需要将它们分割成几个子序列，其中每个子序列至少包含三个连续整数。返回你是否能做出这样的分割？

**示例 1**：
```
输入: [1,2,3,3,4,5]
输出: True
解释:
你可以分割出这样两个连续子序列 : 
1, 2, 3
3, 4, 5
```

**示例 2**：
```
输入: [1,2,3,3,4,4,5,5]
输出: True
解释:
你可以分割出这样两个连续子序列 : 
1, 2, 3, 4, 5
3, 4, 5
```

**示例 3**：
```
输入: [1,2,3,4,4,5]
输出: False
```

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 合并K个排序链表

[LeetCode链接](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

**示例**:
```
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 滑动窗口最大值

[LeetCode链接](https://leetcode-cn.com/problems/sliding-window-maximum/)

给定一个数组 `nums`，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k 内的数字。滑动窗口每次只向右移动一位。

返回滑动窗口最大值。

**示例**:
```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```
 
**注意**：

你可以假设 k 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。

**进阶**：

你能在线性时间复杂度内解决此题吗？

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 数据流的中位数

[LeetCode链接](https://leetcode-cn.com/problems/find-median-from-data-stream/)

中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

* void addNum(int num) - 从数据流中添加一个整数到数据结构中。
* double findMedian() - 返回目前所有元素的中位数。

**示例**：
```
addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3) 
findMedian() -> 2
```

**进阶**:

* 如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？
* 如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```


