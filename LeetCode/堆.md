* **堆总结**
   * [数组中的第K个最大元素](#数组中的第K个最大元素) (`medium` `排序`)
   * [合并K个排序链表](#合并K个排序链表) (`hard`)
   * [数据流的中位数](#数据流的中位数) (`hard`)

# 堆总结
## 数组中的第K个最大元素

[LeetCode链接](https://leetcode-cn.com/problems/kth-largest-element-in-an-array)

在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

**示例 1**:

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**示例 2**:
```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

**说明**:

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

### 解答

#### 方法1:堆



* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int len=nums.size();
        if(k<=0 || len==0 || len<k)
            return 0;
        
        vector<int> min(nums.begin(),nums.begin()+k);
        make_heap(min.begin(),min.end(),greater<int>());
        
        for(int i=k;i<len;i++)
        {
            int tmp = min.front();
            if(nums[i] > tmp)
            {
                pop_heap(min.begin(),min.end(),greater<int>());
                min.pop_back();
                
                min.push_back(nums[i]);
                push_heap(min.begin(),min.end(),greater<int>());
            }
        }
        
        return min[0];
    }
};
```

#### 方法2：红黑树



* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int len=nums.size();
        if(k<=0 || len==0 || len<k)
            return 0;
        
        //红黑树实现
        multiset<int,less<int>> st(nums.begin(),nums.begin()+k,less<int>());
        
        for(auto it=nums.begin()+k;it!=nums.end();it++)
        {
            auto iter = st.begin();
            if(*iter < *it)
            {
                st.erase(iter);
                st.insert(*it);
            }
        }
        
        return *(st.begin());
    }
};
```

#### 方法3：快排



- 时间复杂度O()
- 空间复杂度O()

```c++
class Solution {
public:
    pair<int,int> partition(vector<int>& vec,int l,int r)
    {
        int m = l + (r -l)/2;
        if(vec[l] > vec[r])
            swap(vec[l],vec[r]);
        if(vec[l] > vec[m])
            swap(vec[l],vec[m]);
        if(vec[m] > vec[r])
            swap(vec[m],vec[r]);
        
        swap(vec[l],vec[m]);
        int pivot=vec[l];
        int len=vec.size();
        int more=l;
        int cur=l+1;
        int less=r+1;
       
        while(cur<less)
        {
            if(vec[cur] > pivot)
            {
                swap(vec[++more],vec[cur++]);
            }
            else if(vec[cur] < pivot)
            {
                swap(vec[--less],vec[cur]);
            }
            else
                cur++;
        }
        
        swap(vec[l],vec[more]);
        more--;
        
        return make_pair(more+1,less-1);
    }
    
    int findKthLargest(vector<int>& nums, int k) {
        //快排partition实现
        int len=nums.size();
        if(k<=0 || len==0 || len<k)
            return 0;
        
       pair<int,int> pr = partition(nums,0,len-1);
        
	   int start = 0;
	   int end = len - 1;
        while(k-1 < pr.first || k-1 > pr.second)
        {
            if(k-1 < pr.first)
			{
				end = pr.first - 1;
                pr = partition(nums,start,end);
			}
            else if(k-1 > pr.second)
			{
				start = pr.second + 1;
                pr = partition(nums,start,end);
			}
        }
        
        return nums[k-1];
    }
};
```

## 合并K个排序链表

[LeetCode链接](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

**示例**:

```
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    static bool comp(ListNode* p1,ListNode* p2)
    {
        return p1->val > p2->val;
    }
    
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode*,vector<ListNode*>,decltype(comp)*> que(comp);
        
        for(auto p : lists)
        {
            if(p) que.push(p);
        }  
        
        ListNode* dummy = new ListNode(-1);
        ListNode* cur = dummy;
        while(!que.empty())
        {
            auto tmp = que.top();
            que.pop();
            
            if(tmp->next) que.push(tmp->next);
            
            cur->next = tmp;
            cur = cur->next;
        }
        
        return dummy->next;
        
    }
};
```

## 数据流的中位数

[LeetCode链接](https://leetcode-cn.com/problems/find-median-from-data-stream/)

中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

* void addNum(int num) - 从数据流中添加一个整数到数据结构中。
* double findMedian() - 返回目前所有元素的中位数。

**示例**：
```
addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3) 
findMedian() -> 2
```

**进阶**:

* 如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？
* 如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class MedianFinder {
public:
    /** initialize your data structure here. */
    MedianFinder() {
        
    }
    
    void addNum(int num) {
        if(max.empty())
            max.push(num);
        else{
            if(num > max.top())
                min.push(num);
            else
                max.push(num);
        }
        
        int len_max = max.size();
        int len_min = min.size();
        if(len_max - len_min > 1)
        {
            int a = max.top();
            max.pop();
            
            min.push(a);
        }
        else if(len_min - len_max > 1)
        {
            int a = min.top();
            min.pop();
            
            max.push(a);
        }
    }
    
    double findMedian() {
        int len1 = max.size();
        int len2 = min.size();
        //int sum = len1 + len2;
        double res;
        if(len1 == len2)
        {
            res = static_cast<double>(((double)(max.top()) + (double)(min.top()))/2.0);
        }
        else if(len1 > len2){
            res = (double)(max.top());
        }
        else 
            res = (double)(min.top());
        
        return res;
    }
    
priority_queue<int> max;
priority_queue<int,vector<int>,greater<int>> min;
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```


