* **栈和队列总结**
   * **栈**
      * [最小栈](#最小栈) (`easy`)
      * [有效的括号](#有效的括号) (`easy`)
      * [逆波兰表达式求值](#逆波兰表达式求值) (`medium`)
      * [简化路径](#简化路径) (`medium`)
   * **队列**
      * [设计循环队列](#设计循环队列) (`medium`)
      * [设计循环双端队列](#设计循环双端队列) (`medium`)
   
# 栈和队列总结
## 最小栈

[LeetCode链接](https://leetcode-cn.com/problems/min-stack/)

设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。

* push(x) -- 将元素 x 推入栈中。
* pop() -- 删除栈顶的元素。
* top() -- 获取栈顶元素。
* getMin() -- 检索栈中的最小元素。

**示例**:
```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 有效的括号
[LeetCode链接](https://leetcode-cn.com/problems/valid-parentheses/)

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

**注意**:空字符串可被认为是有效字符串。

**示例 1**:
```
输入: "()[]{}"
输出: true
```

**示例 2**:
```
输入: "(]"
输出: false
```

**示例 3**:
```
输入: "([)]"
输出: false
```

### 解答

定义一个栈`sta`，遍历字符串，每当遇到`[`或`(`或`{`，则入栈；每当遇到`]`或`)`或`}`,就从栈中弹出一个字符，判断是否和当前字符匹配。

* 时间复杂度O(n)
* 空间复杂度O(n)

```c++
class Solution {
public:
    bool isValid(string s) {
        if(s.empty())
            return true;
        
        stack<char> sta;
        for(auto ch:s)
        {
            if(ch=='(' || ch=='[' || ch=='{')
                sta.push(ch);
            
            if(ch==']' || ch==')' || ch=='}')
            {
                if(sta.empty())
                    return false;
                char tmp=sta.top();
                sta.pop();
                if((ch==']' && tmp!='[')||(ch==')' && tmp!='(')||(ch=='}' && tmp!='{'))
                    return false;
            }
        }
        
        if(!sta.empty())
            return false;
        
        return true;
    }
};
```

## 逆波兰表达式求值

[LeetCode链接](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

根据[逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437)，求表达式的值。

有效的运算符包括 `+`, `-`, `*`, `/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

**说明**：

* 整数除法只保留整数部分。
* 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

**示例 1**：
```
输入: ["2", "1", "+", "3", "*"]
输出: 9
解释: ((2 + 1) * 3) = 9
```
**示例 2**：
```
输入: ["4", "13", "5", "/", "+"]
输出: 6
解释: (4 + (13 / 5)) = 6
```
**示例 3**：
```
输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
输出: 22
解释: 
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 简化路径
[LeetCode链接](https://leetcode-cn.com/problems/simplify-path/)

以 Unix 风格给出一个文件的**绝对路径**，你需要简化它。或者换句话说，将其转换为规范路径。

在 Unix 风格的文件系统中，一个点（`.`）表示当前目录本身；此外，两个点 （`..`） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径

请注意，返回的规范路径必须始终以斜杠 `/` 开头，并且两个目录名之间必须只有一个斜杠 `/`。最后一个目录名（如果存在）不能以 `/` 结尾。此外，规范路径必须是表示绝对路径的最短字符串。

**示例 1**:
```
输入："/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。
```

**示例 2**:
```
输入："/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。
```

**示例 3**:
```
输入："/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
```

**示例 4**：
```
输入："/a/./b/../../c/"
输出："/c"
```

### 解答

首先将字符串`path`末尾的所有`/`清除，维护一个栈结构（类型为`string`），然后从前往后遍历`path`，遍历过程中分几种情况处理：

1. 遇到两个`/`之间的字符串，则将它压入栈；
2. 遇到`..`，则栈中弹出一个元素；
3. 其他情况，例如遇到`/`和`.`,则不处理，继续向前。

最后将栈中剩下的字符串通过`/`连接起来，就得到了结果。

**特殊情况**：多个`/`连续；`/../`

* 时间复杂度O(n)
* 空间复杂度O(n)

```c++
class Solution {
public:
    string simplifyPath(string path) {
        if(path.size() == 0) return "";
        if(path.size() == 1) return "/";
        
        while(path.back() == '/') 
            path.pop_back();
        
        if(path.size() == 0 || path.size() == 1) return "/";
        
        int len = path.size();
        vector<string> vec;
        string res("");
        
        int idx = 0;
        while(idx < len && path[idx] == '/') idx++;
        
        string tmp;
        while(idx < len)
        {
            char ch = path[idx];
            if(ch != '/')
            {
                tmp += ch;
                idx++;
            }
            else if(ch == '/')
            {
                while(idx < len && path[idx] == '/') idx++;
                
                if(tmp == "..")
                {
                    if(!vec.empty())
                    {
                        vec.pop_back();
                    }
                }
                else if(tmp != ".")
                {
                    vec.push_back(tmp);
                }
                
                tmp.clear();
            }
        }
        
        if(tmp == "..")
        {
            if(!vec.empty())
                vec.pop_back();
        }
        else if(tmp != ".")
        {
            vec.push_back(tmp);
        }
        
        if(vec.empty())
            return "/";
        else{
            for(int i=0;i<vec.size();i++)
            {
                res += "/" + vec[i];
            }
        }
        
        return res;
    }
};
```

## 设计循环队列

[LeetCode链接](https://leetcode-cn.com/problems/design-circular-queue/)

设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。
循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。
你的实现应该支持如下操作：

* MyCircularQueue(k): 构造器，设置队列长度为 k 。
* Front: 从队首获取元素。如果队列为空，返回 -1 。
* Rear: 获取队尾元素。如果队列为空，返回 -1 。
* enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。
* deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。
* isEmpty(): 检查循环队列是否为空。
* isFull(): 检查循环队列是否已满。

**示例**：
```
MyCircularQueue circularQueue = new MycircularQueue(3); // 设置长度为3

circularQueue.enQueue(1);  // 返回true

circularQueue.enQueue(2);  // 返回true

circularQueue.enQueue(3);  // 返回true

circularQueue.enQueue(4);  // 返回false,队列已满

circularQueue.Rear();  // 返回3

circularQueue.isFull();  // 返回true

circularQueue.deQueue();  // 返回true

circularQueue.enQueue(4);  // 返回true

circularQueue.Rear();  // 返回4
```

**注意**：

* 所有的值都在 1 至 1000 的范围内；
* 操作数将在 1 至 1000 的范围内；
* 请不要使用内置的队列库。

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 设计循环双端队列

[LeetCode链接](https://leetcode-cn.com/problems/design-circular-deque/)

设计实现双端队列。
你的实现需要支持以下操作：

* MyCircularDeque(k)：构造函数,双端队列的大小为k。
* insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。
* insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。
* deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。
* deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。
* getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。
* getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。
* isEmpty()：检查双端队列是否为空。
* isFull()：检查双端队列是否满了。

**示例**：
```
MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3
circularDeque.insertLast(1);			        // 返回 true
circularDeque.insertLast(2);			        // 返回 true
circularDeque.insertFront(3);			        // 返回 true
circularDeque.insertFront(4);			        // 已经满了，返回 false
circularDeque.getRear();  				// 返回 2
circularDeque.isFull();				        // 返回 true
circularDeque.deleteLast();			        // 返回 true
circularDeque.insertFront(4);			        // 返回 true
circularDeque.getFront();				// 返回 4
```

**注意**：

* 所有值的范围为 [1, 1000]
* 操作次数的范围为 [1, 1000]
* 请不要使用内置的双端队列库。

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```
