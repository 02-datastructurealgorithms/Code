* **栈和队列总结**
   * **栈**
      * [最小栈](#最小栈) (`easy`)
      * [有效的括号](#有效的括号) (`easy`)
      * [逆波兰表达式求值](#逆波兰表达式求值) (`medium`)
      * [简化路径](#简化路径) (`medium`)
   * **队列**
      * [设计循环队列](#设计循环队列) (`medium`)
      * [设计循环双端队列](#设计循环双端队列) (`medium`)
   
# 栈和队列总结
## 最小栈

[LeetCode链接]()

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 有效的括号
[LeetCode链接](https://leetcode-cn.com/problems/valid-parentheses/)

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

**注意**:空字符串可被认为是有效字符串。

**示例 1**:
```
输入: "()[]{}"
输出: true
```

**示例 2**:
```
输入: "(]"
输出: false
```

**示例 3**:
```
输入: "([)]"
输出: false
```

### 解答

定义一个栈`sta`，遍历字符串，每当遇到`[`或`(`或`{`，则入栈；每当遇到`]`或`)`或`}`,就从栈中弹出一个字符，判断是否和当前字符匹配。

* 时间复杂度O(n)
* 空间复杂度O(n)

```c++
class Solution {
public:
    bool isValid(string s) {
        if(s.empty())
            return true;
        
        stack<char> sta;
        for(auto ch:s)
        {
            if(ch=='(' || ch=='[' || ch=='{')
                sta.push(ch);
            
            if(ch==']' || ch==')' || ch=='}')
            {
                if(sta.empty())
                    return false;
                char tmp=sta.top();
                sta.pop();
                if((ch==']' && tmp!='[')||(ch==')' && tmp!='(')||(ch=='}' && tmp!='{'))
                    return false;
            }
        }
        
        if(!sta.empty())
            return false;
        
        return true;
    }
};
```

## 逆波兰表达式求值

[LeetCode链接]()

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 简化路径
[LeetCode链接](https://leetcode-cn.com/problems/simplify-path/)

以 Unix 风格给出一个文件的**绝对路径**，你需要简化它。或者换句话说，将其转换为规范路径。

在 Unix 风格的文件系统中，一个点（`.`）表示当前目录本身；此外，两个点 （`..`） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径

请注意，返回的规范路径必须始终以斜杠 `/` 开头，并且两个目录名之间必须只有一个斜杠 `/`。最后一个目录名（如果存在）不能以 `/` 结尾。此外，规范路径必须是表示绝对路径的最短字符串。

**示例 1**:
```
输入："/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。
```

**示例 2**:
```
输入："/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。
```

**示例 3**:
```
输入："/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
```

**示例 4**：
```
输入："/a/./b/../../c/"
输出："/c"
```

### 解答

首先将字符串`path`末尾的所有`/`清除，维护一个栈结构（类型为`string`），然后从前往后遍历`path`，遍历过程中分几种情况处理：

1. 遇到两个`/`之间的字符串，则将它压入栈；
2. 遇到`..`，则栈中弹出一个元素；
3. 其他情况，例如遇到`/`和`.`,则不处理，继续向前。

最后将栈中剩下的字符串通过`/`连接起来，就得到了结果。

**特殊情况**：多个`/`连续；`/../`

* 时间复杂度O(n)
* 空间复杂度O(n)

```c++
class Solution {
public:
    string simplifyPath(string path) {
        if(path.size() == 0) return "";
        if(path.size() == 1) return "/";
        
        while(path.back() == '/') 
            path.pop_back();
        
        if(path.size() == 0 || path.size() == 1) return "/";
        
        int len = path.size();
        vector<string> vec;
        string res("");
        
        int idx = 0;
        while(idx < len && path[idx] == '/') idx++;
        
        string tmp;
        while(idx < len)
        {
            char ch = path[idx];
            if(ch != '/')
            {
                tmp += ch;
                idx++;
            }
            else if(ch == '/')
            {
                while(idx < len && path[idx] == '/') idx++;
                
                if(tmp == "..")
                {
                    if(!vec.empty())
                    {
                        vec.pop_back();
                    }
                }
                else if(tmp != ".")
                {
                    vec.push_back(tmp);
                }
                
                tmp.clear();
            }
        }
        
        if(tmp == "..")
        {
            if(!vec.empty())
                vec.pop_back();
        }
        else if(tmp != ".")
        {
            vec.push_back(tmp);
        }
        
        if(vec.empty())
            return "/";
        else{
            for(int i=0;i<vec.size();i++)
            {
                res += "/" + vec[i];
            }
        }
        
        return res;
    }
};
```

## 设计循环队列

[LeetCode链接]()

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 设计循环双端队列

[LeetCode链接]()

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```
