* **线段树总结**
   * [区间和检索-数组可修改](#区间和检索-数组可修改)
   * [计算右侧小于当前元素的个数](#计算右侧小于当前元素的个数)
   
# 线段树总结
## 区间和检索-数组可修改

[LeetCode链接](https://leetcode-cn.com/problems/range-sum-query-mutable/)

给定一个整数数组 `nums`，求出数组从索引 `i` 到 `j  (i ≤ j)` 范围内元素的总和，包含 `i`,  `j` 两点。

`update(i, val)` 函数可以通过将下标为 `i` 的数值更新为 `val`，从而对数列进行修改。

**示例**:
```
Given nums = [1, 3, 5]

sumRange(0, 2) -> 9
update(1, 2)
sumRange(0, 2) -> 8
```

**说明**:

1. 数组仅可以在 `update` 函数下进行修改。
2. 你可以假设 `update` 函数与 `sumRange` 函数的调用次数是均匀分布的。

## 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class segTree
{
public:
    segTree(int l,int r)
    {
        start=l;
        end=r;
        sum=0;
        left=right=nullptr;
    }
    
    int start,end,sum;
    segTree* left;
    segTree* right;
};

void update_node(segTree*& root,int i,int val)
{
    if(root->start == root->end && root->start == i)
    {
        root->sum = val;
        return;
    }
    
    int m = root->start + (root->end - root->start)/2;
    if(i <= m && i >= root->start)
    {
        update_node(root->left,i,val);
    }
    else if(i>=m+1 && i <= root->end)
    {
        update_node(root->right,i,val);
    }
    
    root->sum = root->left->sum + root->right->sum;
}

segTree* build(int l,int r,vector<int>& vec)
{
    if(l == r)
    {
        segTree* tmp = new segTree(l,r);
        tmp->sum = vec[l];
        return tmp;
    }
    
    segTree* res=new segTree(l,r);
    int m=l+(r-l)/2;
    res->left = build(l,m,vec);
    res->right = build(m+1,r,vec);
    
    res->sum = res->left->sum + res->right->sum;
    return res;
}

int getSum(int l,int r,segTree* root)
{
    if(l == root->start && r == root->end)
        return root->sum;
    
    int m = root->start + (root->end - root->start)/2;
    int sum_l=0;
    int sum_r=0;
    if(l <= m)
    {
        if(r<=m)
            sum_l = getSum(l,r,root->left);
        else
            sum_l = getSum(l,m,root->left);
    }
    
    if(r > m)
    {
        if(l > m)
            sum_r = getSum(l,r,root->right);
        else
            sum_r = getSum(m+1,r,root->right);
            
    }
        
    return (sum_l + sum_r);
}

class NumArray {
public:
    NumArray(vector<int> nums) {
        if(nums.empty())
            return;
        
        vec = nums;
        root = build(0,nums.size()-1,nums);
    }
    
    void update(int i, int val) {
        update_node(root,i,val);
    }
    
    int sumRange(int i, int j) {
        return getSum(i,j,root);
    }
    
private:
    segTree* root;
    vector<int> vec;
};

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * obj.update(i,val);
 * int param_2 = obj.sumRange(i,j);
 */
```

## 计算右侧小于当前元素的个数

[LeetCode链接](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)

给定一个整数数组 `nums`，按要求返回一个新数组 `counts`。

数组 `counts` 有该性质：  
`counts[i]` 的值是  `nums[i]` 右侧小于 `nums[i]` 的元素的数量。

**示例**:
```
输入: [5,2,6,1]
输出: [2,1,1,0] 
解释:
5 的右侧有 2 个更小的元素 (2 和 1).
2 的右侧仅有 1 个更小的元素 (1).
6 的右侧有 1 个更小的元素 (1).
1 的右侧有 0 个更小的元素.
```

## 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class segNode
{
public:
    segNode(int l,int r)
    {
        start = l;
        end = r;
        sum = 0;
        left = right = nullptr;
    }

    segNode* left,*right;
    int start,end,sum;
};


segNode* build(int l,int r,vector<int>& vec)
{
    if(l == r)
    {
        segNode* tmp = new segNode(l,r);
        tmp->sum = vec[l];
        return tmp;
    }
    
    int m = l + (r - l)/2;
    segNode* res = new segNode(l,r);
    res->left = build(l,m,vec);
    res->right = build(m+1,r,vec);
    res->sum = res->left->sum + res->right->sum;
    
    return res;
}

int query(int l,int r,segNode* root)
{
    if(l > r)
        return 0;
    
    if(l == root->start && r == root->end)
        return root->sum;
    
    int m = root->start + (root->end - root->start)/2;
    int sum_l = 0;
    int sum_r = 0;
    if(l <= m)
    {
        if(r<=m)
            sum_l = query(l,r,root->left);
        else
            sum_l = query(l,m,root->left);
    }
    
    if(r > m)
    {
        if(l > m)
            sum_r = query(l,r,root->right);
        else
            sum_r = query(m+1,r,root->right);
    }
    
    return (sum_l + sum_r);
}

void updateNode(int i,int val,segNode* root)
{
    if(i == root->start && i == root->end)
    {
        root->sum = val;
        return;
    }
    
    int m = root->start + (root->end - root->start)/2;
    if(i <= m)
    {
        updateNode(i,val,root->left);
    }
    else{
        updateNode(i,val,root->right);
    }
    
    root->sum = root->left->sum + root->right->sum;
    return;
}

class Solution {
public:
    vector<int> countSmaller(vector<int>& nums) {
        if(nums.empty())
            return vector<int>();
        
        int num_max = INT_MIN;
        int num_min = INT_MAX;
        vector<int> res;
        for(auto a : nums)
        {
            num_max = max(a,num_max);
            num_min = min(a,num_min);
        }
        
        vector<int> count(num_max - num_min + 1,0);
        root = build(0,count.size()-1,count);
        
        for(int i=nums.size()-1;i>=0;i--)
        {
            int index = nums[i] - num_min;
            res.push_back(query(0,index-1,root));
            
            
            int old_val = query(index,index,root);
            updateNode(index,old_val+1,root);
        }
        
        reverse(res.begin(),res.end());
        
        return res;
    }
 
private:
    segNode* root;
};
```


