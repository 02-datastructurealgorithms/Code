* **排序类总结**
   * [颜色分类](#颜色分类) (`medium`)
   * [排序链表](#排序链表) (`medium` `归并` `堆排序`)

# 排序总结
## 颜色分类
[LeetCode链接](https://leetcode-cn.com/problems/sort-colors)

给定一个包含红色、白色和蓝色，一共 `n` 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

**注意**:不能使用代码库中的排序函数来解决这道题。

**示例**:
```
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

**进阶**：

* 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
* 你能想出一个仅使用常数空间的一趟扫描算法吗？

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int len=nums.size();
        if(len==0)
            return;
        
        vector<int> hash(3,0);
        for(int i=0;i<len;i++)
        {
            hash[nums[i]]++;
        }
        
        int j=0;
        for(int i=0;i<3;i++)
        {
            while(hash[i]>0)
            {
                nums[j++]=i;
                hash[i]--;
            }
        }
        
        
    }
};
```

## 排序链表
[LeetCode链接](https://leetcode-cn.com/problems/sort-list)

在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

**示例 1**:
```
输入: 4->2->1->3
输出: 1->2->3->4
```

**示例 2**:
```
输入: -1->5->3->4->0
输出: -1->0->3->4->5
```

### 解答
#### 方法1：
归并排序 + 链表
* 时间复杂度O(nlogn)
* 空间复杂度O(n)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
         if(!head || !head->next) return head;
        
        ListNode *slow = head,*fast = head;
        while(fast && fast->next && fast->next->next)
        {
            slow = slow->next;
            fast = fast->next->next;
        }
        
        ListNode *p1 = head,*p2 = slow->next;
        slow->next = nullptr;
        
        p1 = sortList(p1);
        p2 = sortList(p2);
        
        ListNode node(0),*head1 = &node;
        while(p1 && p2)
        {
            if(p1->val < p2->val)
            {
                head1->next = p1;
                head1 = p1;
                p1 = p1->next;
            }
            else{
                head1->next = p2;
                head1 = p2;
                
                p2 = p2->next;
            }
        }
        
        if(p1)
            head1->next = p1;
        if(p2)
            head1->next = p2;
        
        return node.next;
    }
};
```

#### 方法2

堆排序（优先级队列） + 链表

* 时间复杂度O(nlogn)
* 空间复杂度O(n)

1. 优先级队列（底层用堆实现）
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
inline bool comp(const ListNode* p1,const ListNode* p2)
{
    return p1->val > p2->val;
}

class Solution {
public:
    ListNode* sortList(ListNode* head) {
        priority_queue<ListNode*,vector<ListNode*>,decltype(comp)*> que(comp);
        ListNode* p = head;
        while(p)
        {
            que.push(p);
            p = p->next;
        }
        
        ListNode node(0),*head1 = &node;
        while(!que.empty())
        {
            auto tmp = que.top();
            que.pop();
            
            head1->next = tmp;
            head1 = head1->next;
        }
        
        head1->next = nullptr;
        
        return node.next;
    }
};
```

2. 直接用堆结构
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
inline bool comp(const ListNode* p1,const ListNode* p2)
{
    return p1->val > p2->val;
}

class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector<ListNode*> vec;
        ListNode* p = head;
        while(p)
        {
            vec.push_back(p);
            p = p->next;
        }
        
        make_heap(vec.begin(),vec.end(),comp);
        
        ListNode node(0),*head1 = &node;
        while(!vec.empty())
        {
            auto tmp = vec.front();
            pop_heap(vec.begin(),vec.end(),comp);
            vec.pop_back();
            
            head1->next = tmp;
            head1 = head1->next;
        }
        
        head1->next = nullptr;
        
        return node.next;
    }
};
```
