* **排序类总结**
   * [颜色分类](#颜色分类) (`medium` `快排`)
   * [排序链表](#排序链表) (`medium` `归并` `堆排序`)
   * [前K个高频元素](#前K个高频元素) (`medium` `桶排序` `堆排序`)
   * [最大间距](#最大间距) (`hard`)


# 排序总结
## 颜色分类

[LeetCode链接](https://leetcode-cn.com/problems/sort-colors)

给定一个包含红色、白色和蓝色，一共 `n` 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

**注意**:不能使用代码库中的排序函数来解决这道题。

**示例**:

```
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

**进阶**：

* 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
* 你能想出一个仅使用常数空间的一趟扫描算法吗？

### 解答

#### 方法1：计数排序

哈希表统计每个颜色代表的数字出现的次数，然后更新原数组，按照`0`,`1`,`2`各自的个数按照顺序赋值。



* 时间复杂度O(*n*)
* 空间复杂度O(*n*)
  
```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int len=nums.size();
        if(len==0)
            return;
        
        vector<int> hash(3,0);
        for(int i=0;i<len;i++)
        {
            hash[nums[i]]++;
        }
        
        int j=0;
        for(int i=0;i<3;i++)
        {
            while(hash[i]>0)
            {
                nums[j++]=i;
                hash[i]--;
            }
        }
        
        
    }
};
```

#### 方法2：荷兰国旗问题

定义两个指针，指针`r`指向数组开头前一个位置(`代表红色`)，指针`b`指向数组末尾后一个位置(`代表蓝色`)，然后从前向后遍历数组，对于遍历的每一个元素`nums[w]`(`w`起始位置为0)，处理情况如下：

1. 如果`nums[w] == 0`，则`r`后移一个位置，然后交换`nums[r]`和`nums[w]`的值，`w`后移一个位置；
2. 如果`nums[w] == 2`，则`b`前移一个位置，然后交换`nums[b]`和`nums[w]`的值，`w`位置不变；
3. 如果`nums[w] == 1`，则`w`后移一个位置。

直到`w == b`时，结束遍历。



* 时间复杂度：O(*n*)
* 空间复杂度：O(1)

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int r = -1,w = 0,b = nums.size();
        while(w < b)
        {
            if(nums[w] == 0)
            {
                swap(nums[++r],nums[w++]);
            }
            else if(nums[w] == 2)
            {
                swap(nums[--b],nums[w]);
            }
            else
            {
                ++w;
            }
        }
        
    }
};
```



## 排序链表

[LeetCode链接](https://leetcode-cn.com/problems/sort-list)

在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

**示例 1**:
```
输入: 4->2->1->3
输出: 1->2->3->4
```

**示例 2**:
```
输入: -1->5->3->4->0
输出: -1->0->3->4->5
```

### 解答
#### 方法1：
归并排序 + 链表



* 时间复杂度O(*n log n*)
* 空间复杂度O(*n*)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
         if(!head || !head->next) return head;
        
        ListNode *slow = head,*fast = head;
        while(fast && fast->next && fast->next->next)
        {
            slow = slow->next;
            fast = fast->next->next;
        }
        
        ListNode *p1 = head,*p2 = slow->next;
        slow->next = nullptr;
        
        p1 = sortList(p1);
        p2 = sortList(p2);
        
        ListNode node(0),*head1 = &node;
        while(p1 && p2)
        {
            if(p1->val < p2->val)
            {
                head1->next = p1;
                head1 = p1;
                p1 = p1->next;
            }
            else{
                head1->next = p2;
                head1 = p2;
                
                p2 = p2->next;
            }
        }
        
        if(p1)
            head1->next = p1;
        if(p2)
            head1->next = p2;
        
        return node.next;
    }
};
```

#### 方法2

堆排序（优先级队列） + 链表



* 时间复杂度O(*n log n*)
* 空间复杂度O(*n*)



1. 使用优先级队列`priority_queue`（底层用**堆**实现）
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
inline bool comp(const ListNode* p1,const ListNode* p2)
{
    return p1->val > p2->val;
}

class Solution {
public:
    ListNode* sortList(ListNode* head) {
        priority_queue<ListNode*,vector<ListNode*>,decltype(comp)*> que(comp);
        ListNode* p = head;
        while(p)
        {
            que.push(p);
            p = p->next;
        }
        
        ListNode node(0),*head1 = &node;
        while(!que.empty())
        {
            auto tmp = que.top();
            que.pop();
            
            head1->next = tmp;
            head1 = head1->next;
        }
        
        head1->next = nullptr;
        
        return node.next;
    }
};
```

2. 直接用**STL**中`heap`的接口：`make_heap`, `push_heap` ,`pop_heap`。
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
inline bool comp(const ListNode* p1,const ListNode* p2)
{
    return p1->val > p2->val;
}

class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector<ListNode*> vec;
        ListNode* p = head;
        while(p)
        {
            vec.push_back(p);
            p = p->next;
        }
        
        make_heap(vec.begin(),vec.end(),comp);
        
        ListNode node(0),*head1 = &node;
        while(!vec.empty())
        {
            auto tmp = vec.front();
            pop_heap(vec.begin(),vec.end(),comp);
            vec.pop_back();
            
            head1->next = tmp;
            head1 = head1->next;
        }
        
        head1->next = nullptr;
        
        return node.next;
    }
};
```



## 前K个高频元素

[LeetCode链接](https://leetcode-cn.com/problems/top-k-frequent-elements/)

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

**示例 1**:

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2**:

```
输入: nums = [1], k = 1
输出: [1]
```

**说明**：

- 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
- 你的算法的时间复杂度**必须**优于 O(*n log n*) , n 是数组的大小。

### 解答

- 时间复杂度O()
- 空间复杂度O()

```c++

```

## 最大间距

[LeetCode链接](https://leetcode-cn.com/problems/maximum-gap/)

给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。

如果数组元素个数小于 2，则返回 0。

**示例 1**:
```
输入: [3,6,9,1]
输出: 3
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。
```
**示例 2**:
```
输入: [10]
输出: 0
解释: 数组元素个数小于 2，因此返回 0。
```
**说明**:

* 你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。
* 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```
