* **排序类总结**
   * [有效的字母异位词](#有效的字母异位词) (`easy`)
   * [颜色分类](#颜色分类) (`medium` `快排`)
   * [排序链表](#排序链表) (`medium` `归并` `堆排序`)
   * [前K个高频元素](#前K个高频元素) (`medium` `桶排序` `堆排序`)
   * [最大间距](#最大间距) (`hard`)


# 排序总结
## 有效的字母异位词

[LeetCode链接](https://leetcode-cn.com/problems/valid-anagram/)

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。

**示例 1**:
```
输入: s = "anagram", t = "nagaram"
输出: true
```
**示例 2**:
```
输入: s = "rat", t = "car"
输出: false
```
**说明**:

你可以假设字符串只包含小写字母。

**进阶**:

如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 颜色分类
[LeetCode链接](https://leetcode-cn.com/problems/sort-colors)

给定一个包含红色、白色和蓝色，一共 `n` 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

**注意**:不能使用代码库中的排序函数来解决这道题。

**示例**:
```
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

**进阶**：

* 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
* 你能想出一个仅使用常数空间的一趟扫描算法吗？

### 解答

* 时间复杂度O()
* 空间复杂度O()
  
```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int len=nums.size();
        if(len==0)
            return;
        
        vector<int> hash(3,0);
        for(int i=0;i<len;i++)
        {
            hash[nums[i]]++;
        }
        
        int j=0;
        for(int i=0;i<3;i++)
        {
            while(hash[i]>0)
            {
                nums[j++]=i;
                hash[i]--;
            }
        }
        
        
    }
};
```

## 排序链表
[LeetCode链接](https://leetcode-cn.com/problems/sort-list)

在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

**示例 1**:
```
输入: 4->2->1->3
输出: 1->2->3->4
```

**示例 2**:
```
输入: -1->5->3->4->0
输出: -1->0->3->4->5
```

### 解答
#### 方法1：
归并排序 + 链表
* 时间复杂度O(nlogn)
* 空间复杂度O(n)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
         if(!head || !head->next) return head;
        
        ListNode *slow = head,*fast = head;
        while(fast && fast->next && fast->next->next)
        {
            slow = slow->next;
            fast = fast->next->next;
        }
        
        ListNode *p1 = head,*p2 = slow->next;
        slow->next = nullptr;
        
        p1 = sortList(p1);
        p2 = sortList(p2);
        
        ListNode node(0),*head1 = &node;
        while(p1 && p2)
        {
            if(p1->val < p2->val)
            {
                head1->next = p1;
                head1 = p1;
                p1 = p1->next;
            }
            else{
                head1->next = p2;
                head1 = p2;
                
                p2 = p2->next;
            }
        }
        
        if(p1)
            head1->next = p1;
        if(p2)
            head1->next = p2;
        
        return node.next;
    }
};
```

#### 方法2

堆排序（优先级队列） + 链表

* 时间复杂度O(nlogn)
* 空间复杂度O(n)

1. 优先级队列（底层用堆实现）
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
inline bool comp(const ListNode* p1,const ListNode* p2)
{
    return p1->val > p2->val;
}

class Solution {
public:
    ListNode* sortList(ListNode* head) {
        priority_queue<ListNode*,vector<ListNode*>,decltype(comp)*> que(comp);
        ListNode* p = head;
        while(p)
        {
            que.push(p);
            p = p->next;
        }
        
        ListNode node(0),*head1 = &node;
        while(!que.empty())
        {
            auto tmp = que.top();
            que.pop();
            
            head1->next = tmp;
            head1 = head1->next;
        }
        
        head1->next = nullptr;
        
        return node.next;
    }
};
```

2. 直接用堆结构
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
inline bool comp(const ListNode* p1,const ListNode* p2)
{
    return p1->val > p2->val;
}

class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector<ListNode*> vec;
        ListNode* p = head;
        while(p)
        {
            vec.push_back(p);
            p = p->next;
        }
        
        make_heap(vec.begin(),vec.end(),comp);
        
        ListNode node(0),*head1 = &node;
        while(!vec.empty())
        {
            auto tmp = vec.front();
            pop_heap(vec.begin(),vec.end(),comp);
            vec.pop_back();
            
            head1->next = tmp;
            head1 = head1->next;
        }
        
        head1->next = nullptr;
        
        return node.next;
    }
};
```

## 前K个高频元素

[LeetCode链接](https://leetcode-cn.com/problems/top-k-frequent-elements/)

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

**示例 1**:

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2**:

```
输入: nums = [1], k = 1
输出: [1]
```

**说明**：

- 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
- 你的算法的时间复杂度**必须**优于 O(*n log n*) , n 是数组的大小。

### 解答

- 时间复杂度O()
- 空间复杂度O()

```c++

```

## 最大间距

[LeetCode链接](https://leetcode-cn.com/problems/maximum-gap/)

给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。

如果数组元素个数小于 2，则返回 0。

**示例 1**:
```
输入: [3,6,9,1]
输出: 3
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。
```
**示例 2**:
```
输入: [10]
输出: 0
解释: 数组元素个数小于 2，因此返回 0。
```
**说明**:

* 你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。
* 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```
