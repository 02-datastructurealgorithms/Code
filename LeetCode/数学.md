- **数学类总结**
  - [Excel表列序号](#Excel表列序号) (`easy`)
  - [回文数 ](#回文数) (`easy`)
  - [快乐数](#快乐数) (`easy`)
  - [2的幂](#2的幂) (`easy`)
  - [3的幂](#3的幂) (`easy`)
  - [加一](#加一) (`easy`)
  - [阶乘后的零](#阶乘后的零) (`easy`)
  - [x的平方根](#x的平方根) (`easy`)
  - [整数反转](#整数反转) (`easy`)
  - [计数质数](#计数质数) (`easy`)
  - [Pow(x,n)](#Powxn) (`medium`)
  - [分数到小数](#分数到小数) (`medium`)
  - [两数相除](#两数相除) (`medium`)

# 数学类总结

## Excel表列序号

[LeetCode链接](https://leetcode-cn.com/problems/excel-sheet-column-number/)

给定一个Excel表格中的列名称，返回其相应的列序号。

例如，

```
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
```

**示例 1:**

```
输入: "A"
输出: 1
```

**示例 2:**

```
输入: "AB"
输出: 28
```

**示例 3:**

```
输入: "ZY"
输出: 701
```

### 解答

类似于十进制、二进制运算，由于字母有26个，相当于进行26进制运算得出结果。

- 时间复杂度O(*n*)
- 空间复杂度O(1)

```c++
class Solution {
public:
    int titleToNumber(string s) {
        int n = s.size();
        int res = 0;
        
        for(int i=0;i<n;i++)
        {
            int a = s[i] - 'A' + 1;
            res = 26 * res + a;
        }
        
        return res;
    }
};
```



## 回文数

[LeetCode链接](https://leetcode-cn.com/problems/palindrome-number/)

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

**示例 1:**

```
输入: 121
输出: true
```

**示例 2:**

```
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3:**

```
输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
```

**进阶:**

你能不将整数转为字符串来解决这个问题吗？

### 解答

```c++
class Solution {
public:
    bool isPalindrome(int x) {
        if(x < 9 && x >= 0)
            return true;
        if(x < 0)
            return false;
        
        vector<int> vec;
        while(x)
        {
            int a = x % 10;
            x /= 10;
            vec.push_back(a);
        }
        
        int l = 0;
        int r = vec.size() - 1;
        while(l < r)
        {
            if(vec[l++] != vec[r--])
                return false;
        }
        
        return true;
    }
};
```



## 快乐数

[LeetCode链接](https://leetcode-cn.com/problems/happy-number/)

编写一个算法来判断一个数是不是“快乐数”。

一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。

**示例:** 

```
输入: 19
输出: true
```

**解释**: 

1<sup>2</sup> + 92<sup>2</sup> = 82
8<sup>2</sup> + 2<sup>2</sup> = 68
6<sup>2</sup> + 8<sup>2</sup> = 100
1<sup>2</sup>+ 0<sup>2</sup> + 0<sup>2</sup> = 1

### 解答

我们来看一个不是快乐数的情况，比如数字11有如下的计算过程：

1<sup>2</sup> + 1<sup>2</sup> = 2
2<sup>2</sup> = 4
4<sup>2</sup> = 16
1<sup>2</sup> + 6<sup>2</sup> = 37
3<sup>2</sup> + 7<sup>2</sup> = 58
5<sup>2</sup> + 8<sup>2</sup> = 89
8<sup>2</sup> + 9<sup>2</sup> = 145
1<sup>2</sup> + 4<sup>2</sup> + 5<sup>2</sup> = 42
4<sup>2</sup> + 2<sup>2</sup> = 20
2<sup>2</sup> + 0<sup>2</sup> = 4

可以看到数字4又出现了一次，那么就会循环前面的计算过程，这个循环中没有1，那么就不是快乐数。那么可以找出规律，在计算过程中如果出现重复的数字并且不是1，那么这个数就不是快乐数。用一个`unordered_set`记录之前计算所出现的数字，如果当前计算的数字在`unordered_set`中已经存在(重复出现)，那么数字就不是快乐数；否则，在计算过程中，肯定会得到1，那么数字就是快乐数。

```c++
class Solution {
public:
    bool isHappy(int n) {
        if(n <= 0)
            return false;
        
        unordered_set<int> st;
        while(1)
        {
            if(n == 1)
                return true;
            
            string str = to_string(n);
            int tmp = 0;
            for(auto a : str)
            {
                tmp += (a - '0')*(a - '0');
            }
            
            if(st.find(tmp) == st.end())
            {
                st.insert(tmp);
            }
            else
                break;
            
            n = tmp;
        }
        
        return false;
    }
};
```



## 2的幂

[LeetCode链接](https://leetcode-cn.com/problems/power-of-two/)

给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

**示例 1:**

```
输入: 1
输出: true
解释: 20 = 1
```

**示例 2:**

```
输入: 16
输出: true
解释: 24 = 16
```

**示例 3:**

```
输入: 218
输出: false
```

### 解答

根据位运算的规律，如果整数是2的幂，那么它对应的二进制只有一位有1。



**注意**：负数肯定不是2的幂。



```C++
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if(n <= 0)
            return false;
        
        return (n & (n - 1)) == 0;
    }
};
```



## 3的幂

[LeetCode链接](https://leetcode-cn.com/problems/power-of-three/)

给定一个整数，写一个函数来判断它是否是 3 的幂次方。

**示例 1:**

```
输入: 27
输出: true
```

**示例 2:**

```
输入: 45
输出: false
```

**进阶：**
你能不使用循环或者递归来完成本题吗？

### 解答

#### 方法1

将整数`n`不停地除以3，直到`n % 3 != 0`，看计算得到的商是否为1。

```c++
class Solution {
public:
    bool isPowerOfThree(int n) {
        if(n <= 0) return false;
        
        while(n % 3 == 0)
        {
            n /= 3;
        }
        
        return n == 1;
    }
};
```

#### 方法2

直接计算*log<sub>3</sub>n*(**以3为底n的对数**)，如果结果为整数，就是3的幂。

```C++
class Solution {
public:
    bool isPowerOfThree(int n) {
        double a = log10(n) / log10(3);
        int tmp = (int)a;
        return (a - tmp) == 0 ? true :false;
    }
};
```



## 加一

[LeetCode链接](https://leetcode-cn.com/problems/plus-one/)

给定一个由**整数**组成的**非空**数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

**示例 1:**

```
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
```

**示例 2:**

```
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
```



### 解答



- 时间复杂度O()
- 空间复杂度O()



```C++
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        vector<int> res;
        int len=digits.size();
        int a=0;
        int b=0;
        int tmp=0;
        for(int i=len-1;i>=0;i--)
        {
            if(i==len-1)
                tmp=digits[i]+1;
            else
                tmp=digits[i]+a;
            
            a=tmp/10;
            b=tmp%10;
            res.push_back(b);
        }
        if(a>0)
            res.push_back(a);
        
        reverse(res.begin(),res.end());
        return res;
        
    }
};
```



## 阶乘后的零

[LeetCode链接](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

给定一个整数 *n*，返回 *n*! 结果尾数中零的数量。

**示例 1:**

```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```

**示例 2:**

```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

**说明:** 你算法的时间复杂度应为 *O*(log *n*) 。

### 解答



- 时间复杂度O()
- 空间复杂度O()



```python
class Solution:
    def trailingZeroes(self, n):
        """
        :type n: int
        :rtype: int
        """
        cnt = 0
        while n >= 5:
            cnt += int(n/5)
            n /= 5
            
        return cnt
```



## x的平方根

[LeetCode链接](https://leetcode-cn.com/problems/sqrtx/)

实现 `int sqrt(int x)` 函数。

计算并返回 *x* 的平方根，其中 *x* 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

**示例 1:**

```
输入: 4
输出: 2
```

**示例 2:**

```
输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
```

### 解答



- 时间复杂度O()
- 空间复杂度O()



```python
class Solution:
    def mySqrt(self, x):
        """
        :type x: int
        :rtype: int
        """
        if x <= 1:
            return x
        
        l = 0
        r = x
        while l < r:
            m = int((l + r) / 2)
            if int(x/m) >= m:
                l = m+1
            else:
                r = m
                
        return r-1
        
```



## 整数反转

[LeetCode链接](https://leetcode-cn.com/problems/reverse-integer/)

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

**示例 1:**

```
输入: 123
输出: 321
```

 **示例 2:**

```
输入: -123
输出: -321
```

**示例 3:**

```
输入: 120
输出: 21
```

**注意:**

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2<sup>31</sup>,  2<sup>31</sup> − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

### 解答



- 时间复杂度O()
- 空间复杂度O()



```C++
class Solution {
public:
    vector<int> NumToVec(int num)
    {
        vector<int> res;
        
        while(num)
        {
            int a=num%10;
            num/=10;
            res.push_back(a);
        }
        return res;
    }
    
    int VecToNum(vector<int>& vec,bool flag)
    {
        long long sum=0;
        for(int i=0;i<vec.size();i++)
        {
            int a=vec[i];
            
            if (sum > INT_MAX/10 || (sum == INT_MAX / 10 && a > 6)) return 0;
            if (sum < INT_MIN/10 || (sum == INT_MIN / 10 && a > 5)) return 0;
            
            sum=10*sum+a;
        }
        return sum;
    }
    
    int reverse(int x) {
        if(x<9 && x>-9)
            return x;
        
        bool flag=false;
        if(x<0)
            flag=true;
        
        int num=abs(x);
        vector<int> vec=NumToVec(num);
        int sum=VecToNum(vec,flag);
        if(flag)
            sum=-sum;
        
        return sum;
    }
};
```

## 计数质数

[LeetCode链接](https://leetcode-cn.com/problems/count-primes/)

统计所有小于非负整数 *n* 的质数的数量。

**示例:**

```
输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```

### 解答



- 时间复杂度O()
- 空间复杂度O()



```C++
class Solution {
public:
    int countPrimes(int n) {
        if(n<=2)
            return 0;
        if(n==3)
            return 1;
        
        vector<bool> flag(n,false);
        int cnt=0;
        for(int i=2;i*i<n;i++)
        {
            if(flag[i])
                continue;
            int tmp=i+i;
            while(tmp<n)
            {
                flag[tmp]=true;
                tmp+=i;
            }
        }
        
        for(int i=2;i<n;i++)
        {
            if(!flag[i])
            {
                cnt++;
            }
        }
        
        return cnt;
    }
};
```



## Pow(x,n)

[LeetCode链接](https://leetcode-cn.com/problems/powx-n/)

实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数。

**示例 1:**

```
输入: 2.00000, 10
输出: 1024.00000
```

**示例 2:**

```
输入: 2.10000, 3
输出: 9.26100
```

**示例 3:**

```
输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
```

**说明:**

- -100.0 < *x* < 100.0
- *n* 是 32 位有符号整数，其数值范围是 [−2<sup>31</sup>, 2<sup>31</sup> − 1] 。

### 解答



- 时间复杂度O()
- 空间复杂度O()

```c++
class Solution {
public:
    double get_val(double base,int n)
    {
        if(n == 0)
            return 1.0;
        if(n == 1)
            return base;
        
        double res = 1.0;
        res *= get_val(base,n>>1);
        res *= res;
        if((n & 0x1) == 1)
            res *= base;
        
        return res;
    }
    
    double myPow(double x, int n) {
        if(n == 0)
        {
            if(x == 0)
            {
                return -1;
            }
            else
                return 1.0;
        }
        
        double res;
        bool flag = false;
        if(n < 0)
            flag = true;
        
        if(flag && x == 0)
            return -1;
        
        int n1;
        if(n == INT_MIN)
            n1 = INT_MAX;
       else 
           n1 = abs(n);
        
        res = get_val(x,n1);
        
        if(flag)
        {
            if(n == INT_MIN)
                res *= x;
            res = (double)(1 / res);
        }
        
        return res;
    }
};
```



## 分数到小数

[LeetCode链接](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/)

给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。

如果小数部分为循环小数，则将循环的部分括在括号内。

**示例 1:**

```
输入: numerator = 1, denominator = 2
输出: "0.5"
```

**示例 2:**

```
输入: numerator = 2, denominator = 1
输出: "2"
```

**示例 3:**

```
输入: numerator = 2, denominator = 3
输出: "0.(6)"
```

### 解答



- 时间复杂度O()
- 空间复杂度O()



```c++
class Solution {
public:
    string fractionToDecimal(int numerator, int denominator) {
        if(denominator == 0) return "";
        
        if(numerator == 0) return "0";
        
        int neg = (numerator < 0) ^ (denominator < 0);
        long a = abs((long)numerator);
        long b = abs((long)denominator);
        string res;
        if(neg > 0)
        {
            res = "-";
        }
        
        res += to_string(a/b);
        if(a%b)
        {
            res += ".";
        }
        
        a = a%b;
        
        unordered_map<int,int> mp;
        while(a > 0 && mp.find(a) == mp.end())
        {
            mp[a] = res.size();
            a = a * 10;
            long tmp = a/b;
            res += to_string(tmp);
            
            a = a%b;
        }
        
        if(a > 0)
        {
            int idx = mp[a];
            res = res.substr(0,idx) + "(" + res.substr(idx) + ")";
        }
        
        return res;
    }
};
```

## 两数相除

[LeetCode链接](https://leetcode-cn.com/problems/divide-two-integers/)

给定两个整数，被除数 `dividend` 和除数 `divisor`。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 `dividend` 除以除数 `divisor` 得到的商。

**示例 1:**

```
输入: dividend = 10, divisor = 3
输出: 3
```

**示例 2:**

```
输入: dividend = 7, divisor = -3
输出: -2
```

**说明:**

- 被除数和除数均为 32 位有符号整数。
- 除数不为 0。
- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2<sup>31</sup>,  2<sup>31</sup> − 1]。本题中，如果除法结果溢出，则返回 2<sup>31</sup> − 1。

### 解答



- 时间复杂度O()
- 空间复杂度O()



```c++
class Solution {
public:
    int divide(int dividend, int divisor) {
        if(divisor==0)
            return -1;
        int sign=(dividend<0)^(divisor<0)?-1:1;
        
        long dvd=abs((long)dividend);
        long dvs=abs((long)divisor);
        long res=0;
        while(dvd>=dvs)
        {
            int sum=1;
            long tmp=dvs;
            while(dvd>=(tmp<<1))
            {
                sum<<=1;
                tmp<<=1;
            }
            
            dvd-=tmp;
            res+=sum;
        }
        
        res*=sign;
        if(res==INT_MAX+1)
            return INT_MAX;
        return res;
        
    }
};
```

