* **数学类总结**

[TOC]



# 数学类总结

## Excel表列序号

[LeetCode链接](https://leetcode-cn.com/problems/excel-sheet-column-number/)

给定一个Excel表格中的列名称，返回其相应的列序号。

例如，

```
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
```

**示例 1:**

```
输入: "A"
输出: 1
```

**示例 2:**

```
输入: "AB"
输出: 28
```

**示例 3:**

```
输入: "ZY"
输出: 701
```

### 解答



- 时间复杂度O()
- 空间复杂度O()



```c++
class Solution {
public:
    int titleToNumber(string s) {
        int n=s.size();
        int res=0;
        
        for(int i=0;i<n;i++)
        {
            int a=s[i]-'A'+1;
            res=26*res+a;
        }
        
        return res;
    }
};
```



## 回文数

[LeetCode链接](https://leetcode-cn.com/problems/palindrome-number/)

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

**示例 1:**

```
输入: 121
输出: true
```

**示例 2:**

```
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3:**

```
输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
```

**进阶:**

你能不将整数转为字符串来解决这个问题吗？

### 解答



- 时间复杂度O()
- 空间复杂度O()



```c++
class Solution {
public:
    bool isPalindrome(int x) {
        if(x<9 && x>=0)
            return true;
        if(x<0)
            return false;
        
        vector<int> vec;
        while(x)
        {
            int a=x%10;
            x/=10;
            vec.push_back(a);
        }
        
        int l=0;
        int r=vec.size()-1;
        while(l<r)
        {
            if(vec[l++]!=vec[r--])
                return false;
        }
        return true;
    }
};
```



## 快乐数

[LeetCode链接](https://leetcode-cn.com/problems/happy-number/)



编写一个算法来判断一个数是不是“快乐数”。

一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。

**示例:** 

```
输入: 19
输出: true
解释: 
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

### 解答



- 时间复杂度O()
- 空间复杂度O()



```c++
class Solution {
public:
    bool isHappy(int n) {
        if(n <= 0)
            return false;
        
        unordered_set<int> st;
        while(1)
        {
            if(n == 1)
                return true;
            
            string str = to_string(n);
            int tmp = 0;
            for(auto a : str)
            {
                tmp += (a - '0')*(a - '0');
            }
            
            if(st.find(tmp) == st.end())
            {
                st.insert(tmp);
            }
            else
                break;
            
            n = tmp;
        }
        
        return false;
    }
};
```



## 2的幂

[LeetCode链接](https://leetcode-cn.com/problems/power-of-two/)

给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

**示例 1:**

```
输入: 1
输出: true
解释: 20 = 1
```

**示例 2:**

```
输入: 16
输出: true
解释: 24 = 16
```

**示例 3:**

```
输入: 218
输出: false
```

### 解答



- 时间复杂度O()
- 空间复杂度O()



```C++
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if(n <= 0)
            return false;
        
        return (n&(n-1)) == 0;
    }
};
```



## 3的幂

[LeetCode链接](https://leetcode-cn.com/problems/power-of-three/)

给定一个整数，写一个函数来判断它是否是 3 的幂次方。

**示例 1:**

```
输入: 27
输出: true
```

**示例 2:**

```
输入: 45
输出: false
```

**进阶：**
你能不使用循环或者递归来完成本题吗？

### 解答



- 时间复杂度O()
- 空间复杂度O()



```C++
class Solution {
public:
    bool isPowerOfThree(int n) {
        double a=log10(n)/log10(3);
        int tmp=(int)a;
        return (a-tmp)==0 ? true :false;
    }
};
```



## 加一

[LeetCode链接](https://leetcode-cn.com/problems/plus-one/)

给定一个由**整数**组成的**非空**数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

**示例 1:**

```
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
```

**示例 2:**

```
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
```



### 解答



- 时间复杂度O()
- 空间复杂度O()



```C++
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        vector<int> res;
        int len=digits.size();
        int a=0;
        int b=0;
        int tmp=0;
        for(int i=len-1;i>=0;i--)
        {
            if(i==len-1)
                tmp=digits[i]+1;
            else
                tmp=digits[i]+a;
            
            a=tmp/10;
            b=tmp%10;
            res.push_back(b);
        }
        if(a>0)
            res.push_back(a);
        
        reverse(res.begin(),res.end());
        return res;
        
    }
};
```



## 阶乘后的零

[LeetCode链接](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

给定一个整数 *n*，返回 *n*! 结果尾数中零的数量。

**示例 1:**

```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```

**示例 2:**

```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

**说明:** 你算法的时间复杂度应为 *O*(log *n*) 。

### 解答



- 时间复杂度O()
- 空间复杂度O()



```python
class Solution:
    def trailingZeroes(self, n):
        """
        :type n: int
        :rtype: int
        """
        cnt = 0
        while n >= 5:
            cnt += int(n/5)
            n /= 5
            
        return cnt
```



## x的平方根

[LeetCode链接](https://leetcode-cn.com/problems/sqrtx/)

实现 `int sqrt(int x)` 函数。

计算并返回 *x* 的平方根，其中 *x* 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

**示例 1:**

```
输入: 4
输出: 2
```

**示例 2:**

```
输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
```

### 解答



- 时间复杂度O()
- 空间复杂度O()



```python
class Solution:
    def mySqrt(self, x):
        """
        :type x: int
        :rtype: int
        """
        if x <= 1:
            return x
        
        l = 0
        r = x
        while l < r:
            m = int((l + r) / 2)
            if int(x/m) >= m:
                l = m+1
            else:
                r = m
                
        return r-1
        
```



## 整数反转

[LeetCode链接](https://leetcode-cn.com/problems/reverse-integer/)

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

**示例 1:**

```
输入: 123
输出: 321
```

 **示例 2:**

```
输入: -123
输出: -321
```

**示例 3:**

```
输入: 120
输出: 21
```

**注意:**

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2<sup>31</sup>,  2<sup>31</sup> − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

### 解答



- 时间复杂度O()
- 空间复杂度O()



```C++
class Solution {
public:
    vector<int> NumToVec(int num)
    {
        vector<int> res;
        
        while(num)
        {
            int a=num%10;
            num/=10;
            res.push_back(a);
        }
        return res;
    }
    
    int VecToNum(vector<int>& vec,bool flag)
    {
        long long sum=0;
        for(int i=0;i<vec.size();i++)
        {
            int a=vec[i];
            
            if (sum > INT_MAX/10 || (sum == INT_MAX / 10 && a > 6)) return 0;
            if (sum < INT_MIN/10 || (sum == INT_MIN / 10 && a > 5)) return 0;
            
            sum=10*sum+a;
        }
        return sum;
    }
    
    int reverse(int x) {
        if(x<9 && x>-9)
            return x;
        
        bool flag=false;
        if(x<0)
            flag=true;
        
        int num=abs(x);
        vector<int> vec=NumToVec(num);
        int sum=VecToNum(vec,flag);
        if(flag)
            sum=-sum;
        
        return sum;
    }
};
```

## 计数质数

[LeetCode链接](https://leetcode-cn.com/problems/count-primes/)

统计所有小于非负整数 *n* 的质数的数量。

**示例:**

```
输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```

### 解答



- 时间复杂度O()
- 空间复杂度O()



```C++
class Solution {
public:
    int countPrimes(int n) {
        if(n<=2)
            return 0;
        if(n==3)
            return 1;
        
        vector<bool> flag(n,false);
        int cnt=0;
        for(int i=2;i*i<n;i++)
        {
            if(flag[i])
                continue;
            int tmp=i+i;
            while(tmp<n)
            {
                flag[tmp]=true;
                tmp+=i;
            }
        }
        
        for(int i=2;i<n;i++)
        {
            if(!flag[i])
            {
                cnt++;
            }
        }
        
        return cnt;
    }
};
```




