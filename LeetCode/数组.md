* **数组类总结**
    * [杨辉三角](#杨辉三角) (`easy` `迭代`)
    * [求众数](#求众数) (`easy` `哈希`)
    * [移动零](#移动零) (`easy` `双指针`)
    * [缺失数字](#缺失数字) (`easy` `位运算` `数学`)
    * [存在重复元素](#存在重复元素) (`easy` `哈希`)
    * [两数之和](#两数之和) (`easy` `哈希`)
    * [三数之和](#三数之和) (`medium` `双指针`)
    * [最接近的三数之和](#最接近的三数之和) (`medium`)
    * [删除排序数组中的重复项](#删除排序数组中的重复项) (`easy`)
    * [合并两个有序数组](#合并两个有序数组) (`easy`)
    * [加一](#加一) (`easy`)
    * [旋转数组](#旋转数组) (`easy`)
    * [判断子序列](#判断子序列) (`medium` `双指针`)
    * [子集](#子集) (`medium`)
    * [子集II](#子集II) (`medium`)
    * [螺旋矩阵](#螺旋矩阵) (`medium`)
    * [螺旋矩阵II](#螺旋矩阵II) (`medium`)
    * [旋转图像](#旋转图像) (`medium`)
    * [寻找重复数](#寻找重复数) (`medium`)
    * [除自身以外数组的乘积](#除自身以外数组的乘积) (`medium`)
    * [颜色分类](#颜色分类) (`medium`)
    * [矩阵置零](#矩阵置零) (`medium`)
    * [盛最多水的容器](#盛最多水的容器) (`medium`)
    * [寻找旋转排序数组中的最小值](#寻找旋转排序数组中的最小值) (`medium`)
    * [寻找旋转排序数组中的最小值II](#寻找旋转排序数组中的最小值II) (`hard`)
    * [常数时间插入、删除和获取随机元素](#常数时间插入删除和获取随机元素) (`medium`)
    * [寻找峰值](#寻找峰值) (`medium`)
    * [单词搜索](#单词搜索) (`medium`)
    * [搜索旋转排序数组](#搜索旋转排序数组) (`medium`)
    * [搜索旋转排序数组II](#搜索旋转排序数组II) (`medium`)
    * [在排序数组中查找元素的第一个和最后一个位置](#在排序数组中查找元素的第一个和最后一个位置) (`medium`)
    * [合并区间](#合并区间) (`medium`)
    * [下一个排列](#下一个排列) (`medium`)
    * [缺失的第一个正数](#缺失的第一个正数) (`hard`)
    * [寻找两个有序数组的中位数](#寻找两个有序数组的中位数) (`hard`)
    
# 数组类总结
## 杨辉三角
[LeetCode链接](https://leetcode-cn.com/problems/pascals-triangle/)

给定一个非负整数 *numRows*，生成杨辉三角的前 *numRows* 行。

![1](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

在杨辉三角中，每个数是它左上方和右上方的数的和。

**示例**:
```
输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

### 解答

利用杨辉三角的性质，利用上一行的数值推导出下一行，推导关系式为：

* 时间复杂度O(n<sup>2</sup>)
* 空间复杂度O(n<sup>2</sup>)

```c++
class Solution {
public:
    vector<int> transform(vector<int> vec)
    {
        vector<int> res;
        res.push_back(1);
        int len=vec.size();
        for(int i=1;i<len;i++)
        {
            res.push_back(vec[i-1]+vec[i]);
        }
        res.push_back(1);
        return res;
        
    }
    
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> res;
        if(numRows==0)
            return res;
        if(numRows==1)
        {
            res.push_back({1});
            return res;
        }
        
        res.push_back({1});
        for(int i=1;i<numRows;i++)
        {
            res.push_back(transform(res[i-1]));
        }
        
        return res;
    }
};
```
    
## 求众数
[LeetCode链接](https://leetcode-cn.com/problems/majority-element/)

给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数**大于** ⌊ `n/2` ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在众数。

**示例 1**：
```
输入：[3,2,3]
输出：3
```

**示例 2**：
```
输入：[2,2,1,1,1,2,2]
输出：2
```
    
### 解答
#### 方法1：哈希表

基于原数组建立哈希表，key为元素，value为元素个数，找出value > len/2的元素就是众数

* 时间复杂度O(n)
* 空间复杂度O(n)

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        unordered_map<int,int> mp;
        int len = nums.size();
        int res = INT_MIN;
        for(auto a : nums)
        {
            mp[a]++;
            if(mp[a] > len/2) 
            {
                res = a;
                break;
            }
        }
        
        return res;
    }
};
```

#### 方法2：摩尔投票法

[参见博客](https://www.cnblogs.com/grandyang/p/4233501.html)

* 时间复杂度O(n)
* 空间复杂度O(1)

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int cnt = 0;
        int res = 0;
        for(int i=0;i<nums.size();i++)
        {
            if(cnt == 0)
            {
                cnt++;
                res = nums[i];
            }
            else if(nums[i] == res)
                cnt++;
            else
                cnt--;
        }
        
        return res;
        
    }
};
```

    
## 移动零
[LeetCode链接](https://leetcode-cn.com/problems/move-zeroes/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例**:
```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```
**说明**:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。
    
### 解答

双指针法，快指针i遍历一遍数组，当快指针的元素非零时，令慢指针idx的元素等于快指针元素，同时慢指针前进一步。最后，所有的非零元素都移到了数组前半部分（相对顺序不变），然后将之后的元素全部置0。

* 时间复杂度O(n)
* 空间复杂度O(1)
    
```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if(nums.empty())
            return;
        
        int idx = 0;
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i] != 0)
            {
                nums[idx++] = nums[i];
            }
        }
        
        for(;idx<nums.size();idx++)
            nums[idx] = 0;
        
        return;
    }
};
```

## 缺失数字
[LeetCode链接](https://leetcode-cn.com/problems/missing-number/)

给定一个包含 `0, 1, 2, ..., n` 中 `n` 个数的序列，找出 `0 .. n` 中没有出现在序列中的那个数。

**示例 1**:
```
输入: [3,0,1]
输出: 2
```

**示例 2**:
```
输入: [9,6,4,2,3,5,7,0,1]
输出: 8
```

**说明**:

你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?

### 解答
#### 方法1：位运算

将原数组的所有元素和0~n的所有数字做异或运算，得到结果就是缺失的数字

* 时间复杂度O(n)
* 空间复杂度O(1)

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int res=0;
        for(int i=0;i<nums.size();i++)
        {
            res^=(i+1)^nums[i];
        }
        
        return res;
    }
};
```

#### 方法2：等差数列

等差数列求0~n的和减去数组所有元素相加得到的和即为缺失的数字

* 时间复杂度O(n)
* 空间复杂度O(1)

```
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int sum = 0;
        int n = nums.size();
        for(auto num : nums) sum += num;
        return (int)((1 + n)*n/2) - sum;
    }
};
```

    
## 存在重复元素
[LeetCode链接](https://leetcode-cn.com/problems/contains-duplicate/)

给定一个整数数组，判断是否存在重复元素。

如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。

**示例 1**:
```
输入: [1,2,3,1]
输出: true
```

**示例 2**:
```
输入: [1,2,3,4]
输出: false
```

### 解答

利用unordered_set无序集合，遍历数组的时候将元素放入集合中，找出已经在集合中出现的元素就是重复的元素

* 时间复杂度O(n)
* 空间复杂度O(n)

    
```c++
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        if(nums.empty())
            return false;
        
        int len=nums.size();
        unordered_set<int> st;
        for(auto a:nums)
        {
            if(st.find(a) != st.end())
                return true;
            else
                st.insert(a);
        }
        
        return false;
    }
};
```
    
## 两数之和
[LeetCode链接](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

**示例**:
```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

### 解答

维护一个hash表，边遍历数组边存储值到hash表中，当遍历到`nums[i]`时，如果hash[target - nums[i]] > 0，那么就找到了符合条件的两个值

* 时间复杂度O(n)
* 空间复杂度O(n)

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res(2,-1);
        unordered_map<int, int> hash;
        for(int i = 0; i < nums.size(); i++) {
            if(hash.count(target - nums[i]) != 0) {
                res[0] = hash[target - nums[i]];
                res[1] = i;
                break;
            }
            hash[nums[i]] = i;
        }
        return res;
    }
};
```
    
## 最接近的三数之和
[LeetCode链接](https://leetcode-cn.com/problems/3sum-closest/)
    
### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(),nums.end());
        int len = nums.size();
        if(len < 3) return INT_MAX;
        
        int res = nums[0] + nums[1] + nums[2];
        
        for(int i=0;i<len-2;i++)
        {
            if(i == 0 || nums[i] != nums[i-1])
            {
                int l = i+1,r = len-1;
                while(l < r)
                {
                    int tmp = nums[l] + nums[r] + nums[i];
                    if(tmp < target)
                    {
                        res = abs(res - target) < abs(target - tmp) ? res : tmp;
                        l++;
                    }
                    else if(tmp > target)
                    {
                        res = abs(res - target) < abs(target - tmp) ? res : tmp;
                        r--;
                    }
                    else{
                        return tmp;
                    }
                }
            }
            
        }
        
        return res;
    }
}; 
```
    
## 三数之和
[LeetCode链接](https://leetcode-cn.com/problems/3sum)

给定一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 `a`，`b`，`c` ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

**注意**：答案中不可以包含重复的三元组。
```
例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

### 解答

对整个数组排序，先遍历数组取三数中的第一个数`nums[i]`，那么剩下两个数需要满足条件`target = 0 - nums[i]`,这两个数在数组中`num[i]`后面部分，维持两个双指针`l`和`r`，令`tmp = nums[l] + nums[r]`，处理情况如下：
1. 如果`tmp < target`，则`l`右移一步；
2. 如果`tmp > target`，则`r`左移一步；
3. 否则，满足条件，添加两个数到结果数组中，同时将`l`和`r`分别右移和左移到下一个不重复的元素处。

**注意**：遍历数组的时候取第一个数的时候过滤重复元素，可以提高查找效率

* 时间复杂度O(n<sup>2</sup>)
* 空间复杂度O(1)
    
```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int len = nums.size();
        if(len < 3)
            return vector<vector<int>>();
        
        sort(nums.begin(),nums.end());
        vector<vector<int>> res;
        for(int i=0;i<len-2;i++)
        {
            if(i == 0 || (i > 0 && nums[i] != nums[i-1]))
            {
                int l = i+1;
                int r = len-1;
                int target = 0 - nums[i];
                while(l < r)
                {
                    int tmp = nums[l] + nums[r];
                    if(target > tmp)
                    {
                        l++;
                    }
                    else if(target < tmp)
                    {
                        r--;
                    }
                    else{
                        res.push_back({nums[i],nums[l],nums[r]});
                        l++;
                        r--;
                        while(l < r && nums[l] == nums[l-1])
                            l++;
                        while(l < r && nums[r] == nums[r+1])
                            r--;
                    }
                }
                
            }
        }
        
        return res;
    }
};
```
    
## 删除排序数组中的重复项
[LeetCode链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

给定一个排序数组，你需要在**原地**删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在**原地修改输入数组**并在使用 O(1) 额外空间的条件下完成。

**示例 1**:
```
给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
```

**示例 2**:
```
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
```

### 解答

双指针，快指针`i`遍历数组，每当找到下一个不重复的元素即`nums[i] != nums[i-1]`时，慢指针`idx`位置的值nums[idx++] = nums[i]（同时idx前进一步）。

* 时间复杂度O(n)
* 空间复杂度O(1)
    
```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int len=nums.size();
        if(len==0)
            return 0;
        
        int index=1;
        for(int i=1;i<len;i++)
        {
            if(nums[i]!=nums[i-1])
                nums[index++]=nums[i];
        }
        while(nums.size()!=index)
            nums.pop_back();
        
        return index;
    }
};
```
    
## 合并两个有序数组
[LeetCode链接](https://leetcode-cn.com/problems/merge-sorted-array/)

给定两个有序整数数组 `nums1` 和 `nums2`，将 `nums2` 合并到 `nums1` 中，使得 `num1` 成为一个有序数组。

**说明**:

* 初始化 `nums1` 和 `nums2` 的元素数量分别为 `m` 和 `n`。
* 你可以假设 `nums1` 有足够的空间（空间大小大于或等于 `m + n`）来保存 `nums2` 中的元素。

**示例**:
```
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```

### 解答

* 时间复杂度O(m+n)
* 空间复杂度O(m+n)
    
```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
       for(int i=m,j=0;i<m+n ;i++)
           nums1[i]=nums2[j++];
        
        vector<int> vec(m+n,0);
        
        int l=0;
        int r=m;
        int cnt=0;
        while(l<m && r<m+n)
        {
            vec[cnt++]=nums1[l]<nums1[r]?nums1[l++]:nums1[r++];
        }
        while(l<m)
            vec[cnt++]=nums1[l++];
        while(r<m+n)
            vec[cnt++]=nums1[r++];
        
        copy(vec.begin(),vec.end(),nums1.begin());
    }
};
```
    
## 加一
[LeetCode链接](https://leetcode-cn.com/problems/plus-one/)

给定一个由**整数**组成的**非空**数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

**示例 1**:
```
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
```

**示例 2**:
```
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
```

### 解答
按照数学十进制进位规则，从数组末尾向前进位得到结果。

* 时间复杂度O(n)
* 空间复杂度O(n)

```c++
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        vector<int> res;
        int len=digits.size();
        int a=0;
        int b=0;
        int tmp=0;
        for(int i=len-1;i>=0;i--)
        {
            if(i==len-1)
                tmp=digits[i]+1;
            else
                tmp=digits[i]+a;
            
            a=tmp/10;
            b=tmp%10;
            res.push_back(b);
        }
        if(a>0)
            res.push_back(a);
        
        reverse(res.begin(),res.end());
        return res;
        
    }
};
```
    
## 旋转数组
[LeetCode链接](https://leetcode-cn.com/problems/rotate-array/)

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

**示例 1**:
```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```

**示例 2**:
```
输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```

**说明**:

* 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
* 要求使用空间复杂度为 O(1) 的原地算法。

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        if(k==nums.size())
            return;
        
        int len=nums.size();
        int k1=k%len;
        
        reverse(nums.begin(),nums.end()-k1);
        reverse(nums.end()-k1,nums.end());
        reverse(nums.begin(),nums.end());
    }
};
```
    
## 子集
[LeetCode链接](https://leetcode-cn.com/problems/subsets/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void recursion(vector<int>& vec,vector<vector<int>>& res,vector<int> tmp,int n)
    {
        if(n==vec.size())
        {
            res.push_back(tmp);
            return;
        }

        recursion(vec,res,tmp,n+1);
        
        tmp.push_back(vec[n]);
        recursion(vec,res,tmp,n+1);
    }
    
    
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> tmp;
        
        if(nums.empty())
            return res;
        
        recursion(nums,res,tmp,0);
        
        return res;
    }
};
```
    
## 子集II
[LeetCode链接](https://leetcode-cn.com/problems/subsets-ii/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void recursion(int n,vector<int>& vec,vector<vector<int>>& res,vector<int>& path)
    {
        if(n == vec.size())
        {
            res.push_back(path);
            return;
        }
        
        path.push_back(vec[n]);
        recursion(n+1,vec,res,path);
        path.pop_back();
        
        while(n+1 < vec.size() && vec[n] == vec[n+1]) n++;
        recursion(n+1,vec,res,path);
        
    }
    
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        if(nums.empty())
            return vector<vector<int>>();
        
        sort(nums.begin(),nums.end());
        vector<vector<int>> res;
        vector<int> path;
        recursion(0,nums,res,path);
        
        return res;
    }
};
```
 
## 螺旋矩阵
[LeetCode链接](https://leetcode-cn.com/problems/spiral-matrix/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void solution(int x1,int y1,int x2,int y2,vector<int>& vec,vector<vector<int>>& matrix)
    {
        int i=x1,j=y1;
        if(x1 < x2 && y1 < y2)
        {
            for(;j<y2;j++)
           {
            vec.push_back(matrix[i][j]);
           }
        for(;i<x2;i++)
        {
            vec.push_back(matrix[i][j]);
        }
        for(;j>y1;j--)
        {
            vec.push_back(matrix[i][j]);
        }
        for(;i>x1;i--)
        {
            vec.push_back(matrix[i][j]);
        }
        }
        else if(x1 == x2)
        {
            for(;j<=y2;j++)
                vec.push_back(matrix[i][j]);
        }
        else if(y1 == y2)
        {
            for(;i<=x2;i++)
                vec.push_back(matrix[i][j]);
        }
    }
    
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty())
            return vector<int>();
        
        vector<int> res;
        int m = matrix.size();
        int n = matrix[0].size();
        int x1 = 0,y1 = 0;
        int x2 = m-1,y2 = n-1;
        while(x1<=x2 && y1<=y2)
        {
            solution(x1++,y1++,x2--,y2--,res,matrix);
        }
        
        return res;
    }
    
};
```
    
## 螺旋矩阵II
[LeetCode链接](https://leetcode-cn.com/problems/spiral-matrix-ii/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void setVal(int x1,int y1,int x2,int y2,vector<vector<int>>& vec)
    {
        if(x1 == x2)
        {
            for(int i=y1;i<=y2;i++)
            {
                vec[x1][i] = cnt++;
            }
            
            return;
        }
        
        if(y1 == y2)
        {
            for(int i=x1;i<=x2;i++)
            {
                vec[i][y1] = cnt++;
            }
            return;
        }
        
        for(int i=y1;i<y2;i++)
        {
            vec[x1][i] = cnt++;
        }
        
        for(int i=x1;i<x2;i++)
        {
            vec[i][y2] = cnt++;
        }
        
        for(int i=y2;i>y1;i--)
        {
            vec[x2][i] = cnt++;
        }
        
        for(int i=x2;i>x1;i--)
        {
            vec[i][y1] = cnt++;
        }
    }
    
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res;
        if(n == 0) return res;
        cnt = 1;
        const int sum = n*n;
        res.resize(n,vector<int>(n));
        int x1 = 0,y1 = 0,x2 = n-1,y2 = n-1;
        while(x1 <= x2 && y1 <= y2)
        {
            setVal(x1++,y1++,x2--,y2--,res);
        }
        
        
        return res;
    }
    
private:
    int cnt;
};
```
    
## 旋转图像
[LeetCode链接](https://leetcode-cn.com/problems/rotate-image/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void rotate_circle(int x1,int y1,int x2,int y2,vector<vector<int>>& vec)
    {
        vector<int> tmp;
        for(int i=x1;i<x2;i++)
        {
            tmp.push_back(vec[i][y1]);
        }
        
        int i=x2-1;
        int j=y2-1;
        while(i>=x1 && j>=y1)
        {
            vec[i--][y1]=vec[x2][j--];
        }
        
        i=x1+1;
        j=y2-1;
        while(j>=y1 && i<=x2)
        {
            vec[x2][j--]=vec[i++][y2];
        }
        
        i=x1+1;
        j=y1+1;
        while(i<=x2)
        {
            vec[i++][y2]=vec[x1][j++];
        }
        
        j=y2;
        i=0;
        while(j>y1)
        {
            vec[x1][j--]=tmp[i++];
        }
    }
    void rotate(vector<vector<int>>& matrix) {
        int row=matrix.size();
        int col=matrix[0].size();
        int a1=0,b1=0;
        int a2=row-1,b2=col-1;
        while(a1<a2 && b1<b2)
        {
            rotate_circle(a1++,b1++,a2--,b2--,matrix);
        }
        
    }
};
```
    
## 寻找重复数
[LeetCode链接](https://leetcode-cn.com/problems/find-the-duplicate-number/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        if(nums.empty())
            return 0;
        
        for(int i=0;i<nums.size();i++)
        {
            while(nums[i] != i+1)
            {
                int tmp = nums[i];
                if(nums[tmp-1] == tmp)
                    return tmp;
                swap(nums[i],nums[tmp-1]);
            }
            
        }
        
        return -1;
    }
};
```
    
## 除自身以外数组的乘积
[LeetCode链接](https://leetcode-cn.com/problems/product-of-array-except-self/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int len = nums.size();
        if(len == 0) return nums;
        
        vector<int> res(len,1);
        for(int i=1;i<len;i++)
        {
            res[i] = res[i-1]*nums[i-1];
        }
        
        int tmp = 1;
        for(int i=len-2;i>=0;i--)
        {
            tmp *= nums[i+1];
            res[i] *= tmp; 
        }
        
        return res;
    }
};
```
    
## 颜色分类
[LeetCode链接](https://leetcode-cn.com/problems/sort-colors)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int len=nums.size();
        if(len==0)
            return;
        
        vector<int> hash(3,0);
        for(int i=0;i<len;i++)
        {
            hash[nums[i]]++;
        }
        
        int j=0;
        for(int i=0;i<3;i++)
        {
            while(hash[i]>0)
            {
                nums[j++]=i;
                hash[i]--;
            }
        }
        
        
    }
};
```

## 矩阵置零
[LeetCode链接](https://leetcode-cn.com/problems/set-matrix-zeroes)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int h=matrix.size();
        int l=matrix[0].size();
        vector<bool> row(h,false),col(l,false);
        for(int i=0;i<h;i++)
            for(int j=0;j<l;j++)
            {
                if(matrix[i][j]==0)
                {
                    row[i]=true;
                    col[j]=true;
                }
            }
        
        for(int i=0;i<h;i++)
        {
           for(int j=0;j<l;j++)
           {
               if(row[i])
                   matrix[i][j]=0;
               if(col[j])
                   matrix[i][j]=0;
           }
        }
    }
};
```
    
    
## 盛最多水的容器
[LeetCode链接](https://leetcode-cn.com/problems/container-with-most-water)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int len = height.size();
        if(len == 0)
            return 0;
        
        int res = 0;
        int l = 0;
        int r = len - 1;
        while(l < r)
        {
            int tmp = min(height[l],height[r]);
            int sum = (r - l)*tmp;
            if(height[l] < height[r])
                l++;
            else
                r--;
            
            res = max(res,sum);
        }
        
        return res;
    }
};
```
    
## 寻找旋转排序数组中的最小值
[LeetCode链接](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int len = nums.size();
        if(len == 0)
            return -1;
        if(len == 1)
            return nums[0];
        
        int min = -1;
        int l=0,r=len-1;
        if(nums[l] < nums[r])
        {
            return nums[l];
        }
        
        while(l < r)
        {
            if(r - l == 1)
            {
                min = nums[r];
                break;
            }
            
            int m = l + (r - l)/2;
            
            if(nums[m] > nums[r])
                l = m;
            else 
                r = m;        
        }
        
        return min;
    }
};
```
    
## 寻找旋转排序数组中的最小值II
[LeetCode链接](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    int normalSearch(vector<int>& nums)
    {
        int len = nums.size();
        int res = nums[0];
        bool flag = false;
        for(int i=1;i<len;i++)
        {
            if(nums[i] < nums[i-1])
            {
                return nums[i];
            }
            if(nums[i] != nums[i-1])
                flag = true;
        }
        
        if(!flag)//满足此条件，数组所有元素都相同
            return nums[0];
        
        return -1;
    }
    int findMin(vector<int>& nums) {
         int len = nums.size();
        if(len == 0)
            return -1;
        if(len == 1)
            return nums[0];
        
        int min = -1;
        int l=0,r=len-1;
        if(nums[l] < nums[r])
        {
            return nums[l];
        }
        
        while(l < r)
        {
            if(r - l == 1)
            {
                min = nums[r];
                break;
            }
            
            int m = l + (r - l)/2;
            
            if(nums[m] == nums[l] && nums[m] == nums[r])
            {
                return normalSearch(nums);
            }
            if(nums[m] > nums[r])
                l = m;
            else 
                r = m;        
        }
        
        return min;
    }
}; 
```
    
    
## 常数时间插入、删除和获取随机元素
[LeetCode链接](https://leetcode-cn.com/problems/insert-delete-getrandom-o1)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class RandomizedSet {
public:
    /** Initialize your data structure here. */
    RandomizedSet() {
        srand(time(0));
    }
    
    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    bool insert(int val) {
        if(mp.find(val) != mp.end()) return false;
        
        nums.push_back(val);
        mp[val] = nums.size() - 1;
        return true;
    }
    
    /** Removes a value from the set. Returns true if the set contained the specified element. */
    bool remove(int val) {
        if(mp.find(val) == mp.end()) return false;
        
        int tmp = mp[val];
        int len = nums.size();
        swap(nums[tmp],nums[len-1]);
        
        mp[nums[tmp]] = tmp;
        mp.erase(val);
        nums.pop_back();
        
        return true;
    }
    
    /** Get a random element from the set. */
    int getRandom() {
        return nums[rand() % nums.size()];
    }
    
private:
    vector<int> nums;
    unordered_map<int,int> mp;
};

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * bool param_1 = obj.insert(val);
 * bool param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```
    
## 寻找峰值
[LeetCode链接](https://leetcode-cn.com/problems/find-peak-element)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
         int ret = -1;
        int l = 0,r = nums.size() - 1,mid;
        while(l < r){
            mid = (l + r) >> 1;
            if(nums[mid] < nums[mid + 1])
                l = mid + 1;
            else if(nums[mid] > nums[mid + 1])
                r = mid;
            //假设输入合法，如果nums[mid] == nums[mid+1]会无限循环
            //为了代码的简洁性暂时不处理这种情况
        }
        return l == r ? l : -1;
    }
}; 
```
    
## 单词搜索
[LeetCode链接](https://leetcode-cn.com/problems/word-search)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    bool recursion(const vector<vector<char>>& board,vector<vector<bool>>& vis,const string& word,int a,int b,int idx)
    {
        if(idx == word.size())
            return true;
        
        if(a < 0 || a >= board.size() || b < 0 || b >= board[0].size() || vis[a][b] || word[idx] != board[a][b])
            return false;
        
        
        vis[a][b] = true;
        bool res = false;
        res = recursion(board,vis,word,a-1,b,idx+1) || recursion(board,vis,word,a+1,b,idx+1) 
              || recursion(board,vis,word,a,b-1,idx+1) || recursion(board,vis,word,a,b+1,idx+1);
        
        vis[a][b] = false;
        
        return res;
    }
    
    bool exist(vector<vector<char>>& board, string word) {
        if(board.empty())
            return false;
        
        int row = board.size();
        int col = board[0].size();
        if(word.size() > row*col)
            return false;
        
        vector<vector<bool>> vis(row,vector<bool>(col,false));
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
            {
                if(board[i][j] == word[0])
                {
                    if(recursion(board,vis,word,i,j,0))
                        return true;
                }
            }
        
        return false;
    }
};
```
    
## 搜索旋转排序数组
[LeetCode链接](https://leetcode-cn.com/problems/search-in-rotated-sorted-array)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int len = nums.size();
        if(len == 0)
            return -1;
        if(len == 1)
        {
            if(target == nums[0])
                return 0;
            else
                return -1;
        }
        
        int l = 0,r = len-1;
        while(l <= r)
        {
            int m = (r + l)/2;
            if(nums[m] == target)
                return m;
            
            if(nums[m] > nums[r])
            {
                if(target >= nums[l] && target < nums[m])
                    r = m-1;
                else
                    l = m+1;
            }
            else if(nums[m] <= nums[r])
            {
                if(target > nums[m] && target <= nums[r])
                    l = m+1;
                else
                    r = m-1;
            }
        }
        
        return -1;
    }
};
```
    
## 搜索旋转排序数组II
[LeetCode链接](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    bool normalSearch(vector<int>& nums,int target)
    {
        auto it = find_if(nums.begin(),nums.end(),[target](const int& a){return a == target;});
        if(it == nums.end())
            return false;
        
        return true;
    }
    
    bool search(vector<int>& nums, int target) {
         int len = nums.size();
        if(len == 0)
            return false;
        if(len == 1)
        {
            if(target == nums[0])
                return true;
            else
                return false;
        }
        
        int l = 0,r = len-1;
        while(l <= r)
        {
            int m = (r + l)/2;
            if(nums[m] == target)
                return true;
            
            if(nums[m] == nums[l] && nums[m] == nums[r])
            {
                return normalSearch(nums,target);
            }
            
            if(nums[m] > nums[r])//nums[m]位于左边有序段
            {
                if(target >= nums[l] && target < nums[m])
                    r = m-1;
                else
                    l = m+1;
            }
            else if(nums[m] <= nums[r])//nums[m]位于右边有序段
            {
                if(target > nums[m] && target <= nums[r])
                    l = m+1;
                else
                    r = m-1;
            }
        }
        
        return false;
    }
};
```
    
## 在排序数组中查找元素的第一个和最后一个位置
[LeetCode链接](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        auto it=find(nums.begin(),nums.end(),target);
        if(it==nums.end())
            return {-1,-1};
        
        int start=-1;
        int end=-1;
        int len=nums.size();
        int l=0;
        int r=len-1;
        
        while(l<=r)
        {
            int m=l+(r-l)/2;
            if(nums[m]<target)
                l=m+1;
            else if(nums[m]>target)
                r=m-1;
            else if(nums[m]==target)
            {
                if(m==0)
                {
                    start=0;
                    break;
                }
                if(nums[m-1]!=target)
                {
                    start=m;
                    break;
                }
                else 
                    r=m-1;
            }
        }
        
        
        l=0;
        r=len-1;
         while(l<=r)
        {
            int m=l+(r-l)/2;
            if(nums[m]<target)
                l=m+1;
            else if(nums[m]>target)
                r=m-1;
            else if(nums[m]==target)
            {
                if(m==len-1)
                {
                    end=len-1;
                    break;
                }
                if(nums[m]!=nums[m+1])
                {
                    end=m;
                    break;
                }
                else
                    l=m+1;
            }
        }
        
       return {start,end};
        
    }
};
```

## 合并区间
[LeetCode链接](https://leetcode-cn.com/problems/merge-intervals)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector<Interval> merge(vector<Interval>& intervals) {
        int len=intervals.size();
        if(len==0 || len==1)
            return intervals;
        
        sort(intervals.begin(),intervals.end(),
             [](const Interval& a,const Interval& b)
             {
                 return a.start<b.start;
             });
        
        vector<Interval> res;
        res.push_back(intervals[0]);
        for(int i=1;i<len;i++)
        {
            int tail=res.back().end;
            if(intervals[i].start<=tail)
            {
                res[res.size()-1].end=max(tail,intervals[i].end);
            }
            else
                res.push_back(intervals[i]);
        }
        
        return res;
    }
};
```

## 下一个排列
[LeetCode链接](https://leetcode-cn.com/problems/next-permutation)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int len = nums.size();
        if(len <= 0)
            return;
        
        int idx = len - 1;
        for(;idx >= 1 && nums[idx-1] >= nums[idx];idx--);
        
        if(idx == 0)
        {
            reverse(nums.begin(),nums.end());
            return;
        }
        
        int idx_l = idx - 1;
        for(int i=idx;idx<len;idx++)
        {
            if(nums[idx] <= nums[idx_l])
                break;
        }
        
        swap(nums[idx-1],nums[idx_l]);
        
        reverse(nums.begin() + idx_l + 1,nums.end());
        
        return;
    }
};
```
    
## 缺失的第一个正数
[LeetCode链接](https://leetcode-cn.com/problems/first-missing-positive)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int len = nums.size();
        if(len == 0) return 1;
        
        for(int i=0;i<len;i++)
        {
            while(nums[i] > 0 && nums[i] <= len && nums[i] != i+1 && nums[nums[i] - 1] != nums[i])
            {
                swap(nums[nums[i] - 1],nums[i]);
            }
        }
        
        for(int i=0;i<len;i++)
        {
            if(nums[i] != i+1)
                return i+1;
        }
        
        return len+1;
    }
};
```
    
## 寻找两个有序数组的中位数
[LeetCode链接](https://leetcode-cn.com/problems/median-of-two-sorted-arrays)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int len1=nums1.size();
        int len2=nums2.size();
        
        vector<int> nums3(len1+len2,0);
        int i=0;
        int j=0;
        int index=0;
        while(i<len1 && j<len2)
        {
            if(nums1[i]<nums2[j])
                nums3[index++]=nums1[i++];
            else
                nums3[index++]=nums2[j++];
        }
        
        while(i<len1)
        {
            nums3[index++]=nums1[i++];
        }
        
        while(j<len2)
        {
            nums3[index++]=nums2[j++];
        }
        
        double res;
        int len3=nums3.size();
        if((len3&0x1)==0)
        {
            res=(double)(nums3[len3/2]+nums3[len3/2-1])/2;
        }
        else
        {
            res=(double)nums3[len3/2];
        }
        
        return res;
    }
};
```

## 判断子序列
[LeetCode链接](https://leetcode-cn.com/problems/is-subsequence)

### 解答

双指针法

```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int len = s.size();
        int len1 = t.size();
        
        if(len > len1) return false;
        int i=0,j=0;
        while(i < len && j < len1)
        {
            if(s[i] == t[j])
            {
                i++;
               
            }
            
            j++;
        }
        
        if(i == len) return true;
        return false;
    }
};
```
    
