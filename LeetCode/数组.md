* **数组类总结**
    * [杨辉三角](#杨辉三角) (`easy`)
    * [求众数](#求众数) (`easy`)
    * [移动零](#移动零) (`easy`)
    * [缺失数字](#缺失数字) (`easy`)
    * [存在重复元素](#存在重复元素) (`easy`)
    
    * [两数之和](#两数之和) (`easy`)
    * [最接近的三数之和](#最接近的三数之和) (`medium`)
    * [三数之和](#三数之和) (`medium`)
    
    * [删除排序数组中的重复项](#删除排序数组中的重复项) (`easy`)
    * [合并两个有序数组](#合并两个有序数组) (`easy`)
    * [加一](#加一) (`easy`)
    * [旋转数组](#旋转数组) (`easy`)
    * [子集](#子集) (`medium`)
    * [子集II](#子集II) (`medium`)
    * [螺旋矩阵](#螺旋矩阵) (`medium`)
    * [螺旋矩阵II](#螺旋矩阵II) (`medium`)
    * [旋转图像](#旋转图像) (`medium`)
    * [寻找重复数](#寻找重复数) (`medium`)
    * [除自身以外数组的乘积](#除自身以外数组的乘积) (`medium`)
    * [颜色分类](#颜色分类) (`medium`)
    * [矩阵置零](#矩阵置零) (`medium`)
    * [盛最多水的容器](#盛最多水的容器) (`medium`)
    * [寻找旋转排序数组中的最小值](#寻找旋转排序数组中的最小值) (`medium`)
    * [寻找旋转排序数组中的最小值II](#寻找旋转排序数组中的最小值II) (`hard`)
    * [任务调度器](#任务调度器) (`medium`)
    * [常数时间插入、删除和获取随机元素](#常数时间插入删除和获取随机元素) (`medium`)
    * [寻找峰值](#寻找峰值) (`medium`)
    * [单词搜索](#单词搜索) (`medium`)
    * [搜索旋转排序数组](#搜索旋转排序数组) (`medium`)
    * [搜索旋转排序数组II](#搜索旋转排序数组II) (`medium`)
    * [在排序数组中查找元素的第一个和最后一个位置](#在排序数组中查找元素的第一个和最后一个位置) (`medium`)
    * [合并区间](#合并区间) (`medium`)
    * [跳跃游戏](#跳跃游戏) (`medium`)
    * [下一个排列](#下一个排列) (`medium`)
    * [缺失的第一个正数](#缺失的第一个正数) (`hard`)
    * [寻找两个有序数组的中位数](#寻找两个有序数组的中位数) (`hard`)
    
# 数组类总结
## 杨辉三角
[LeetCode链接](https://leetcode-cn.com/problems/pascals-triangle/)

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    vector<int> transform(vector<int> vec)
    {
        vector<int> res;
        res.push_back(1);
        int len=vec.size();
        for(int i=1;i<len;i++)
        {
            res.push_back(vec[i-1]+vec[i]);
        }
        res.push_back(1);
        return res;
        
    }
    
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> res;
        if(numRows==0)
            return res;
        if(numRows==1)
        {
            res.push_back({1});
            return res;
        }
        
        res.push_back({1});
        for(int i=1;i<numRows;i++)
        {
            res.push_back(transform(res[i-1]));
        }
        
        return res;
    }
};
```
    
## 求众数
[LeetCode链接](https://leetcode-cn.com/problems/majority-element/)
    
### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int cnt = 0;
        int res = 0;
        for(int i=0;i<nums.size();i++)
        {
            if(cnt == 0)
            {
                cnt++;
                res = nums[i];
            }
            else if(nums[i] == res)
                cnt++;
            else
                cnt--;
        }
        
        return res;
        
    }
};
```
    
## 移动零
[LeetCode链接](https://leetcode-cn.com/problems/move-zeroes/)
    
### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if(nums.empty())
            return;
        
        int idx = 0;
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i] != 0)
            {
                nums[idx++] = nums[i];
            }
        }
        
        for(;idx<nums.size();idx++)
            nums[idx] = 0;
        
        return;
    }
};
```

## 缺失数字
[LeetCode链接](https://leetcode-cn.com/problems/missing-number/)

### 解答

* 时间复杂度O()
* 空间复杂度O()


```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int res=0;
        for(int i=0;i<nums.size();i++)
        {
            res^=(i+1)^nums[i];
        }
        
        return res;
    }
};
```
    
## 存在重复元素
[LeetCode链接](https://leetcode-cn.com/problems/contains-duplicate/)

### 解答

* 时间复杂度O()
* 空间复杂度O()

    
```c++
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        if(nums.empty())
            return false;
        
        int len=nums.size();
        unordered_set<int> st;
        for(auto a:nums)
        {
            if(st.find(a) != st.end())
                return true;
            else
                st.insert(a);
        }
        
        return false;
    }
};
```
    
## 两数之和
[LeetCode链接](https://leetcode-cn.com/problems/two-sum/)

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res(2,-1);
        unordered_map<int, int> hash;
        for(int i = 0; i < nums.size(); i++) {
            if(hash.count(target - nums[i]) != 0) {
                res[0] = hash[target - nums[i]];
                res[1] = i;
                break;
            }
            hash[nums[i]] = i;
        }
        return res;
    }
};
```
    
## 最接近的三数之和
[LeetCode链接](https://leetcode-cn.com/problems/3sum-closest/)
    
### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(),nums.end());
        int len = nums.size();
        if(len < 3) return INT_MAX;
        
        int res = nums[0] + nums[1] + nums[2];
        
        for(int i=0;i<len-2;i++)
        {
            if(i == 0 || nums[i] != nums[i-1])
            {
                int l = i+1,r = len-1;
                while(l < r)
                {
                    int tmp = nums[l] + nums[r] + nums[i];
                    if(tmp < target)
                    {
                        res = abs(res - target) < abs(target - tmp) ? res : tmp;
                        l++;
                    }
                    else if(tmp > target)
                    {
                        res = abs(res - target) < abs(target - tmp) ? res : tmp;
                        r--;
                    }
                    else{
                        return tmp;
                    }
                }
            }
            
        }
        
        return res;
    }
}; 
```
    
## 三数之和
[LeetCode链接](https://leetcode-cn.com/problems/3sum)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int len = nums.size();
        if(len < 3)
            return vector<vector<int>>();
        
        sort(nums.begin(),nums.end());
        vector<vector<int>> res;
        for(int i=0;i<len-2;i++)
        {
            if(i == 0 || (i > 0 && nums[i] != nums[i-1]))
            {
                int l = i+1;
                int r = len-1;
                int target = 0 - nums[i];
                while(l < r)
                {
                    int tmp = nums[l] + nums[r];
                    if(target > tmp)
                    {
                        l++;
                    }
                    else if(target < tmp)
                    {
                        r--;
                    }
                    else{
                        res.push_back({nums[i],nums[l],nums[r]});
                        l++;
                        r--;
                        while(l < r && nums[l] == nums[l-1])
                            l++;
                        while(l < r && nums[r] == nums[r+1])
                            r--;
                    }
                }
                
            }
        }
        
        return res;
    }
};
```
    
## 删除排序数组中的重复项
[LeetCode链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int len=nums.size();
        if(len==0)
            return 0;
        
        int index=1;
        for(int i=1;i<len;i++)
        {
            if(nums[i]!=nums[i-1])
                nums[index++]=nums[i];
        }
        while(nums.size()!=index)
            nums.pop_back();
        
        return index;
    }
};
```
    
## 合并两个有序数组
[LeetCode链接](https://leetcode-cn.com/problems/merge-sorted-array/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
       for(int i=m,j=0;i<m+n ;i++)
           nums1[i]=nums2[j++];
        
        vector<int> vec(m+n,0);
        
        int l=0;
        int r=m;
        int cnt=0;
        while(l<m && r<m+n)
        {
            vec[cnt++]=nums1[l]<nums1[r]?nums1[l++]:nums1[r++];
        }
        while(l<m)
            vec[cnt++]=nums1[l++];
        while(r<m+n)
            vec[cnt++]=nums1[r++];
        
        copy(vec.begin(),vec.end(),nums1.begin());
    }
};
```
    
## 加一
[LeetCode链接](https://leetcode-cn.com/problems/plus-one/)

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        vector<int> res;
        int len=digits.size();
        int a=0;
        int b=0;
        int tmp=0;
        for(int i=len-1;i>=0;i--)
        {
            if(i==len-1)
                tmp=digits[i]+1;
            else
                tmp=digits[i]+a;
            
            a=tmp/10;
            b=tmp%10;
            res.push_back(b);
        }
        if(a>0)
            res.push_back(a);
        
        reverse(res.begin(),res.end());
        return res;
        
    }
};
```
    
## 旋转数组
[LeetCode链接](https://leetcode-cn.com/problems/rotate-array/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        if(k==nums.size())
            return;
        
        int len=nums.size();
        int k1=k%len;
        
        reverse(nums.begin(),nums.end()-k1);
        reverse(nums.end()-k1,nums.end());
        reverse(nums.begin(),nums.end());
    }
};
```
    
## 子集
[LeetCode链接](https://leetcode-cn.com/problems/subsets/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void recursion(vector<int>& vec,vector<vector<int>>& res,vector<int> tmp,int n)
    {
        if(n==vec.size())
        {
            res.push_back(tmp);
            return;
        }

        recursion(vec,res,tmp,n+1);
        
        tmp.push_back(vec[n]);
        recursion(vec,res,tmp,n+1);
    }
    
    
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> tmp;
        
        if(nums.empty())
            return res;
        
        recursion(nums,res,tmp,0);
        
        return res;
    }
};
```
    
## 子集II
[LeetCode链接](https://leetcode-cn.com/problems/subsets-ii/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void recursion(int n,vector<int>& vec,vector<vector<int>>& res,vector<int>& path)
    {
        if(n == vec.size())
        {
            res.push_back(path);
            return;
        }
        
        path.push_back(vec[n]);
        recursion(n+1,vec,res,path);
        path.pop_back();
        
        while(n+1 < vec.size() && vec[n] == vec[n+1]) n++;
        recursion(n+1,vec,res,path);
        
    }
    
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        if(nums.empty())
            return vector<vector<int>>();
        
        sort(nums.begin(),nums.end());
        vector<vector<int>> res;
        vector<int> path;
        recursion(0,nums,res,path);
        
        return res;
    }
};
```
 
## 螺旋矩阵
[LeetCode链接](https://leetcode-cn.com/problems/spiral-matrix/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void solution(int x1,int y1,int x2,int y2,vector<int>& vec,vector<vector<int>>& matrix)
    {
        int i=x1,j=y1;
        if(x1 < x2 && y1 < y2)
        {
            for(;j<y2;j++)
           {
            vec.push_back(matrix[i][j]);
           }
        for(;i<x2;i++)
        {
            vec.push_back(matrix[i][j]);
        }
        for(;j>y1;j--)
        {
            vec.push_back(matrix[i][j]);
        }
        for(;i>x1;i--)
        {
            vec.push_back(matrix[i][j]);
        }
        }
        else if(x1 == x2)
        {
            for(;j<=y2;j++)
                vec.push_back(matrix[i][j]);
        }
        else if(y1 == y2)
        {
            for(;i<=x2;i++)
                vec.push_back(matrix[i][j]);
        }
    }
    
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty())
            return vector<int>();
        
        vector<int> res;
        int m = matrix.size();
        int n = matrix[0].size();
        int x1 = 0,y1 = 0;
        int x2 = m-1,y2 = n-1;
        while(x1<=x2 && y1<=y2)
        {
            solution(x1++,y1++,x2--,y2--,res,matrix);
        }
        
        return res;
    }
    
};
```
    
## 螺旋矩阵II
[LeetCode链接](https://leetcode-cn.com/problems/spiral-matrix-ii/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void setVal(int x1,int y1,int x2,int y2,vector<vector<int>>& vec)
    {
        if(x1 == x2)
        {
            for(int i=y1;i<=y2;i++)
            {
                vec[x1][i] = cnt++;
            }
            
            return;
        }
        
        if(y1 == y2)
        {
            for(int i=x1;i<=x2;i++)
            {
                vec[i][y1] = cnt++;
            }
            return;
        }
        
        for(int i=y1;i<y2;i++)
        {
            vec[x1][i] = cnt++;
        }
        
        for(int i=x1;i<x2;i++)
        {
            vec[i][y2] = cnt++;
        }
        
        for(int i=y2;i>y1;i--)
        {
            vec[x2][i] = cnt++;
        }
        
        for(int i=x2;i>x1;i--)
        {
            vec[i][y1] = cnt++;
        }
    }
    
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res;
        if(n == 0) return res;
        cnt = 1;
        const int sum = n*n;
        res.resize(n,vector<int>(n));
        int x1 = 0,y1 = 0,x2 = n-1,y2 = n-1;
        while(x1 <= x2 && y1 <= y2)
        {
            setVal(x1++,y1++,x2--,y2--,res);
        }
        
        
        return res;
    }
    
private:
    int cnt;
};
```
    
## 旋转图像
[LeetCode链接](https://leetcode-cn.com/problems/rotate-image/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void rotate_circle(int x1,int y1,int x2,int y2,vector<vector<int>>& vec)
    {
        vector<int> tmp;
        for(int i=x1;i<x2;i++)
        {
            tmp.push_back(vec[i][y1]);
        }
        
        int i=x2-1;
        int j=y2-1;
        while(i>=x1 && j>=y1)
        {
            vec[i--][y1]=vec[x2][j--];
        }
        
        i=x1+1;
        j=y2-1;
        while(j>=y1 && i<=x2)
        {
            vec[x2][j--]=vec[i++][y2];
        }
        
        i=x1+1;
        j=y1+1;
        while(i<=x2)
        {
            vec[i++][y2]=vec[x1][j++];
        }
        
        j=y2;
        i=0;
        while(j>y1)
        {
            vec[x1][j--]=tmp[i++];
        }
    }
    void rotate(vector<vector<int>>& matrix) {
        int row=matrix.size();
        int col=matrix[0].size();
        int a1=0,b1=0;
        int a2=row-1,b2=col-1;
        while(a1<a2 && b1<b2)
        {
            rotate_circle(a1++,b1++,a2--,b2--,matrix);
        }
        
    }
};
```
    
## 寻找重复数
[LeetCode链接](https://leetcode-cn.com/problems/find-the-duplicate-number/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        if(nums.empty())
            return 0;
        
        for(int i=0;i<nums.size();i++)
        {
            while(nums[i] != i+1)
            {
                int tmp = nums[i];
                if(nums[tmp-1] == tmp)
                    return tmp;
                swap(nums[i],nums[tmp-1]);
            }
            
        }
        
        return -1;
    }
};
```
    
## 除自身以外数组的乘积
[LeetCode链接](https://leetcode-cn.com/problems/product-of-array-except-self/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
    
```
    
## 颜色分类
[LeetCode链接](https://leetcode-cn.com/problems/sort-colors)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
    
```

## 矩阵置零
[LeetCode链接](https://leetcode-cn.com/problems/set-matrix-zeroes)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
    
```
    
    
## 盛最多水的容器
[LeetCode链接](https://leetcode-cn.com/problems/container-with-most-water)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
    
```
    
## 寻找旋转排序数组中的最小值
[LeetCode链接](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
    
```
    
## 寻找旋转排序数组中的最小值II
[LeetCode链接](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
    
```
    
## 任务调度器
[LeetCode链接](https://leetcode-cn.com/problems/task-scheduler)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
    
```
    
## 常数时间插入、删除和获取随机元素
[LeetCode链接](https://leetcode-cn.com/problems/insert-delete-getrandom-o1)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
    
```
    
## 寻找峰值
[LeetCode链接](https://leetcode-cn.com/problems/find-peak-element)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
    
```
    
## 单词搜索
[LeetCode链接](https://leetcode-cn.com/problems/word-search)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
    
```
    
## 搜索旋转排序数组
[LeetCode链接](https://leetcode-cn.com/problems/search-in-rotated-sorted-array)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
    
```
    
## 搜索旋转排序数组II
[LeetCode链接](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
    
```
    
## 在排序数组中查找元素的第一个和最后一个位置
[LeetCode链接](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
    
```

## 合并区间
[LeetCode链接](https://leetcode-cn.com/problems/merge-intervals)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++

```
    
## 跳跃游戏
[LeetCode链接](https://leetcode-cn.com/problems/jump-game)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++

```
    
## 下一个排列
[LeetCode链接](https://leetcode-cn.com/problems/next-permutation)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
    
```
    
## 缺失的第一个正数
[LeetCode链接](https://leetcode-cn.com/problems/first-missing-positive)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
    
```
    
## 寻找两个有序数组的中位数
[LeetCode链接](https://leetcode-cn.com/problems/median-of-two-sorted-arrays)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
    
```
    
