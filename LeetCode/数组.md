* **数组类总结**
    * [杨辉三角](#杨辉三角) (`easy`)
    * [求众数](#求众数) (`easy`)
    * [移动零](#移动零) (`easy`)
    * [缺失数字](#缺失数字) (`easy`)
    * [存在重复元素](#存在重复元素) (`easy`)
    * [两数之和](#两数之和) (`easy`)
    * [最接近的三数之和](#最接近的三数之和) (`medium`)
    * [三数之和](#三数之和) (`medium`)
    * [删除排序数组中的重复项](#删除排序数组中的重复项) (`easy`)
    * [合并两个有序数组](#合并两个有序数组) (`easy`)
    * [加一](#加一) (`easy`)
    * [旋转数组](#旋转数组) (`easy`)
    * [子集](#子集) (`medium`)
    * [子集II](#子集II) (`medium`)
    * [螺旋矩阵](#螺旋矩阵) (`medium`)
    * [螺旋矩阵II](#螺旋矩阵II) (`medium`)
    * [旋转图像](#旋转图像) (`medium`)
    * [寻找重复数](#寻找重复数) (`medium`)
    * [除自身以外数组的乘积](#除自身以外数组的乘积) (`medium`)
    * [颜色分类](#颜色分类) (`medium`)
    * [矩阵置零](#矩阵置零) (`medium`)
    * [盛最多水的容器](#盛最多水的容器) (`medium`)
    * [寻找旋转排序数组中的最小值](#寻找旋转排序数组中的最小值) (`medium`)
    * [寻找旋转排序数组中的最小值II](#寻找旋转排序数组中的最小值II) (`hard`)
    * [任务调度器](#任务调度器) (`medium`)
    * [常数时间插入、删除和获取随机元素](#常数时间插入删除和获取随机元素) (`medium`)
    * [寻找峰值](#寻找峰值) (`medium`)
    * [单词搜索](#单词搜索) (`medium`)
    * [搜索旋转排序数组](#搜索旋转排序数组) (`medium`)
    * [搜索旋转排序数组II](#搜索旋转排序数组II) (`medium`)
    * [在排序数组中查找元素的第一个和最后一个位置](#在排序数组中查找元素的第一个和最后一个位置) (`medium`)
    * [合并区间](#合并区间) (`medium`)
    * [跳跃游戏](#跳跃游戏) (`medium`)
    * [下一个排列](#下一个排列) (`medium`)
    * [缺失的第一个正数](#缺失的第一个正数) (`hard`)
    * [寻找两个有序数组的中位数](#寻找两个有序数组的中位数) (`hard`)
    
# 数组类总结
## 杨辉三角
[LeetCode链接](https://leetcode-cn.com/problems/pascals-triangle/)

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    vector<int> transform(vector<int> vec)
    {
        vector<int> res;
        res.push_back(1);
        int len=vec.size();
        for(int i=1;i<len;i++)
        {
            res.push_back(vec[i-1]+vec[i]);
        }
        res.push_back(1);
        return res;
        
    }
    
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> res;
        if(numRows==0)
            return res;
        if(numRows==1)
        {
            res.push_back({1});
            return res;
        }
        
        res.push_back({1});
        for(int i=1;i<numRows;i++)
        {
            res.push_back(transform(res[i-1]));
        }
        
        return res;
    }
};
```
    
## 求众数
[LeetCode链接](https://leetcode-cn.com/problems/majority-element/)
    
### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int cnt = 0;
        int res = 0;
        for(int i=0;i<nums.size();i++)
        {
            if(cnt == 0)
            {
                cnt++;
                res = nums[i];
            }
            else if(nums[i] == res)
                cnt++;
            else
                cnt--;
        }
        
        return res;
        
    }
};
```
    
## 移动零
[LeetCode链接](https://leetcode-cn.com/problems/move-zeroes/)
    
### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if(nums.empty())
            return;
        
        int idx = 0;
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i] != 0)
            {
                nums[idx++] = nums[i];
            }
        }
        
        for(;idx<nums.size();idx++)
            nums[idx] = 0;
        
        return;
    }
};
```

## 缺失数字
[LeetCode链接](https://leetcode-cn.com/problems/missing-number/)

### 解答

* 时间复杂度O()
* 空间复杂度O()


```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int res=0;
        for(int i=0;i<nums.size();i++)
        {
            res^=(i+1)^nums[i];
        }
        
        return res;
    }
};
```
    
## 存在重复元素
[LeetCode链接](https://leetcode-cn.com/problems/contains-duplicate/)

### 解答

* 时间复杂度O()
* 空间复杂度O()

    
```c++
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        if(nums.empty())
            return false;
        
        int len=nums.size();
        unordered_set<int> st;
        for(auto a:nums)
        {
            if(st.find(a) != st.end())
                return true;
            else
                st.insert(a);
        }
        
        return false;
    }
};
```
    
## 两数之和
[LeetCode链接](https://leetcode-cn.com/problems/two-sum/)

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res(2,-1);
        unordered_map<int, int> hash;
        for(int i = 0; i < nums.size(); i++) {
            if(hash.count(target - nums[i]) != 0) {
                res[0] = hash[target - nums[i]];
                res[1] = i;
                break;
            }
            hash[nums[i]] = i;
        }
        return res;
    }
};
```
    
## 最接近的三数之和
[LeetCode链接](https://leetcode-cn.com/problems/3sum-closest/)
    
### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(),nums.end());
        int len = nums.size();
        if(len < 3) return INT_MAX;
        
        int res = nums[0] + nums[1] + nums[2];
        
        for(int i=0;i<len-2;i++)
        {
            if(i == 0 || nums[i] != nums[i-1])
            {
                int l = i+1,r = len-1;
                while(l < r)
                {
                    int tmp = nums[l] + nums[r] + nums[i];
                    if(tmp < target)
                    {
                        res = abs(res - target) < abs(target - tmp) ? res : tmp;
                        l++;
                    }
                    else if(tmp > target)
                    {
                        res = abs(res - target) < abs(target - tmp) ? res : tmp;
                        r--;
                    }
                    else{
                        return tmp;
                    }
                }
            }
            
        }
        
        return res;
    }
}; 
```
    
## 三数之和
[LeetCode链接](https://leetcode-cn.com/problems/3sum)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int len = nums.size();
        if(len < 3)
            return vector<vector<int>>();
        
        sort(nums.begin(),nums.end());
        vector<vector<int>> res;
        for(int i=0;i<len-2;i++)
        {
            if(i == 0 || (i > 0 && nums[i] != nums[i-1]))
            {
                int l = i+1;
                int r = len-1;
                int target = 0 - nums[i];
                while(l < r)
                {
                    int tmp = nums[l] + nums[r];
                    if(target > tmp)
                    {
                        l++;
                    }
                    else if(target < tmp)
                    {
                        r--;
                    }
                    else{
                        res.push_back({nums[i],nums[l],nums[r]});
                        l++;
                        r--;
                        while(l < r && nums[l] == nums[l-1])
                            l++;
                        while(l < r && nums[r] == nums[r+1])
                            r--;
                    }
                }
                
            }
        }
        
        return res;
    }
};
```
    
## 删除排序数组中的重复项
[LeetCode链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int len=nums.size();
        if(len==0)
            return 0;
        
        int index=1;
        for(int i=1;i<len;i++)
        {
            if(nums[i]!=nums[i-1])
                nums[index++]=nums[i];
        }
        while(nums.size()!=index)
            nums.pop_back();
        
        return index;
    }
};
```
    
## 合并两个有序数组
[LeetCode链接](https://leetcode-cn.com/problems/merge-sorted-array/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
       for(int i=m,j=0;i<m+n ;i++)
           nums1[i]=nums2[j++];
        
        vector<int> vec(m+n,0);
        
        int l=0;
        int r=m;
        int cnt=0;
        while(l<m && r<m+n)
        {
            vec[cnt++]=nums1[l]<nums1[r]?nums1[l++]:nums1[r++];
        }
        while(l<m)
            vec[cnt++]=nums1[l++];
        while(r<m+n)
            vec[cnt++]=nums1[r++];
        
        copy(vec.begin(),vec.end(),nums1.begin());
    }
};
```
    
## 加一
[LeetCode链接](https://leetcode-cn.com/problems/plus-one/)

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        vector<int> res;
        int len=digits.size();
        int a=0;
        int b=0;
        int tmp=0;
        for(int i=len-1;i>=0;i--)
        {
            if(i==len-1)
                tmp=digits[i]+1;
            else
                tmp=digits[i]+a;
            
            a=tmp/10;
            b=tmp%10;
            res.push_back(b);
        }
        if(a>0)
            res.push_back(a);
        
        reverse(res.begin(),res.end());
        return res;
        
    }
};
```
    
## 旋转数组
[LeetCode链接](https://leetcode-cn.com/problems/rotate-array/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        if(k==nums.size())
            return;
        
        int len=nums.size();
        int k1=k%len;
        
        reverse(nums.begin(),nums.end()-k1);
        reverse(nums.end()-k1,nums.end());
        reverse(nums.begin(),nums.end());
    }
};
```
    
## 子集
[LeetCode链接](https://leetcode-cn.com/problems/subsets/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void recursion(vector<int>& vec,vector<vector<int>>& res,vector<int> tmp,int n)
    {
        if(n==vec.size())
        {
            res.push_back(tmp);
            return;
        }

        recursion(vec,res,tmp,n+1);
        
        tmp.push_back(vec[n]);
        recursion(vec,res,tmp,n+1);
    }
    
    
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> tmp;
        
        if(nums.empty())
            return res;
        
        recursion(nums,res,tmp,0);
        
        return res;
    }
};
```
    
## 子集II
[LeetCode链接](https://leetcode-cn.com/problems/subsets-ii/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void recursion(int n,vector<int>& vec,vector<vector<int>>& res,vector<int>& path)
    {
        if(n == vec.size())
        {
            res.push_back(path);
            return;
        }
        
        path.push_back(vec[n]);
        recursion(n+1,vec,res,path);
        path.pop_back();
        
        while(n+1 < vec.size() && vec[n] == vec[n+1]) n++;
        recursion(n+1,vec,res,path);
        
    }
    
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        if(nums.empty())
            return vector<vector<int>>();
        
        sort(nums.begin(),nums.end());
        vector<vector<int>> res;
        vector<int> path;
        recursion(0,nums,res,path);
        
        return res;
    }
};
```
 
## 螺旋矩阵
[LeetCode链接](https://leetcode-cn.com/problems/spiral-matrix/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void solution(int x1,int y1,int x2,int y2,vector<int>& vec,vector<vector<int>>& matrix)
    {
        int i=x1,j=y1;
        if(x1 < x2 && y1 < y2)
        {
            for(;j<y2;j++)
           {
            vec.push_back(matrix[i][j]);
           }
        for(;i<x2;i++)
        {
            vec.push_back(matrix[i][j]);
        }
        for(;j>y1;j--)
        {
            vec.push_back(matrix[i][j]);
        }
        for(;i>x1;i--)
        {
            vec.push_back(matrix[i][j]);
        }
        }
        else if(x1 == x2)
        {
            for(;j<=y2;j++)
                vec.push_back(matrix[i][j]);
        }
        else if(y1 == y2)
        {
            for(;i<=x2;i++)
                vec.push_back(matrix[i][j]);
        }
    }
    
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty())
            return vector<int>();
        
        vector<int> res;
        int m = matrix.size();
        int n = matrix[0].size();
        int x1 = 0,y1 = 0;
        int x2 = m-1,y2 = n-1;
        while(x1<=x2 && y1<=y2)
        {
            solution(x1++,y1++,x2--,y2--,res,matrix);
        }
        
        return res;
    }
    
};
```
    
## 螺旋矩阵II
[LeetCode链接](https://leetcode-cn.com/problems/spiral-matrix-ii/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void setVal(int x1,int y1,int x2,int y2,vector<vector<int>>& vec)
    {
        if(x1 == x2)
        {
            for(int i=y1;i<=y2;i++)
            {
                vec[x1][i] = cnt++;
            }
            
            return;
        }
        
        if(y1 == y2)
        {
            for(int i=x1;i<=x2;i++)
            {
                vec[i][y1] = cnt++;
            }
            return;
        }
        
        for(int i=y1;i<y2;i++)
        {
            vec[x1][i] = cnt++;
        }
        
        for(int i=x1;i<x2;i++)
        {
            vec[i][y2] = cnt++;
        }
        
        for(int i=y2;i>y1;i--)
        {
            vec[x2][i] = cnt++;
        }
        
        for(int i=x2;i>x1;i--)
        {
            vec[i][y1] = cnt++;
        }
    }
    
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res;
        if(n == 0) return res;
        cnt = 1;
        const int sum = n*n;
        res.resize(n,vector<int>(n));
        int x1 = 0,y1 = 0,x2 = n-1,y2 = n-1;
        while(x1 <= x2 && y1 <= y2)
        {
            setVal(x1++,y1++,x2--,y2--,res);
        }
        
        
        return res;
    }
    
private:
    int cnt;
};
```
    
## 旋转图像
[LeetCode链接](https://leetcode-cn.com/problems/rotate-image/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void rotate_circle(int x1,int y1,int x2,int y2,vector<vector<int>>& vec)
    {
        vector<int> tmp;
        for(int i=x1;i<x2;i++)
        {
            tmp.push_back(vec[i][y1]);
        }
        
        int i=x2-1;
        int j=y2-1;
        while(i>=x1 && j>=y1)
        {
            vec[i--][y1]=vec[x2][j--];
        }
        
        i=x1+1;
        j=y2-1;
        while(j>=y1 && i<=x2)
        {
            vec[x2][j--]=vec[i++][y2];
        }
        
        i=x1+1;
        j=y1+1;
        while(i<=x2)
        {
            vec[i++][y2]=vec[x1][j++];
        }
        
        j=y2;
        i=0;
        while(j>y1)
        {
            vec[x1][j--]=tmp[i++];
        }
    }
    void rotate(vector<vector<int>>& matrix) {
        int row=matrix.size();
        int col=matrix[0].size();
        int a1=0,b1=0;
        int a2=row-1,b2=col-1;
        while(a1<a2 && b1<b2)
        {
            rotate_circle(a1++,b1++,a2--,b2--,matrix);
        }
        
    }
};
```
    
## 寻找重复数
[LeetCode链接](https://leetcode-cn.com/problems/find-the-duplicate-number/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        if(nums.empty())
            return 0;
        
        for(int i=0;i<nums.size();i++)
        {
            while(nums[i] != i+1)
            {
                int tmp = nums[i];
                if(nums[tmp-1] == tmp)
                    return tmp;
                swap(nums[i],nums[tmp-1]);
            }
            
        }
        
        return -1;
    }
};
```
    
## 除自身以外数组的乘积
[LeetCode链接](https://leetcode-cn.com/problems/product-of-array-except-self/)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int len = nums.size();
        if(len == 0) return nums;
        
        vector<int> res(len,1);
        for(int i=1;i<len;i++)
        {
            res[i] = res[i-1]*nums[i-1];
        }
        
        int tmp = 1;
        for(int i=len-2;i>=0;i--)
        {
            tmp *= nums[i+1];
            res[i] *= tmp; 
        }
        
        return res;
    }
};
```
    
## 颜色分类
[LeetCode链接](https://leetcode-cn.com/problems/sort-colors)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int len=nums.size();
        if(len==0)
            return;
        
        vector<int> hash(3,0);
        for(int i=0;i<len;i++)
        {
            hash[nums[i]]++;
        }
        
        int j=0;
        for(int i=0;i<3;i++)
        {
            while(hash[i]>0)
            {
                nums[j++]=i;
                hash[i]--;
            }
        }
        
        
    }
};
```

## 矩阵置零
[LeetCode链接](https://leetcode-cn.com/problems/set-matrix-zeroes)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int h=matrix.size();
        int l=matrix[0].size();
        vector<bool> row(h,false),col(l,false);
        for(int i=0;i<h;i++)
            for(int j=0;j<l;j++)
            {
                if(matrix[i][j]==0)
                {
                    row[i]=true;
                    col[j]=true;
                }
            }
        
        for(int i=0;i<h;i++)
        {
           for(int j=0;j<l;j++)
           {
               if(row[i])
                   matrix[i][j]=0;
               if(col[j])
                   matrix[i][j]=0;
           }
        }
    }
};
```
    
    
## 盛最多水的容器
[LeetCode链接](https://leetcode-cn.com/problems/container-with-most-water)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int len = height.size();
        if(len == 0)
            return 0;
        
        int res = 0;
        int l = 0;
        int r = len - 1;
        while(l < r)
        {
            int tmp = min(height[l],height[r]);
            int sum = (r - l)*tmp;
            if(height[l] < height[r])
                l++;
            else
                r--;
            
            res = max(res,sum);
        }
        
        return res;
    }
};
```
    
## 寻找旋转排序数组中的最小值
[LeetCode链接](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int len = nums.size();
        if(len == 0)
            return -1;
        if(len == 1)
            return nums[0];
        
        int min = -1;
        int l=0,r=len-1;
        if(nums[l] < nums[r])
        {
            return nums[l];
        }
        
        while(l < r)
        {
            if(r - l == 1)
            {
                min = nums[r];
                break;
            }
            
            int m = l + (r - l)/2;
            
            if(nums[m] > nums[r])
                l = m;
            else 
                r = m;        
        }
        
        return min;
    }
};
```
    
## 寻找旋转排序数组中的最小值II
[LeetCode链接](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    int normalSearch(vector<int>& nums)
    {
        int len = nums.size();
        int res = nums[0];
        bool flag = false;
        for(int i=1;i<len;i++)
        {
            if(nums[i] < nums[i-1])
            {
                return nums[i];
            }
            if(nums[i] != nums[i-1])
                flag = true;
        }
        
        if(!flag)//满足此条件，数组所有元素都相同
            return nums[0];
        
        return -1;
    }
    int findMin(vector<int>& nums) {
         int len = nums.size();
        if(len == 0)
            return -1;
        if(len == 1)
            return nums[0];
        
        int min = -1;
        int l=0,r=len-1;
        if(nums[l] < nums[r])
        {
            return nums[l];
        }
        
        while(l < r)
        {
            if(r - l == 1)
            {
                min = nums[r];
                break;
            }
            
            int m = l + (r - l)/2;
            
            if(nums[m] == nums[l] && nums[m] == nums[r])
            {
                return normalSearch(nums);
            }
            if(nums[m] > nums[r])
                l = m;
            else 
                r = m;        
        }
        
        return min;
    }
}; 
```
    
## 任务调度器
[LeetCode链接](https://leetcode-cn.com/problems/task-scheduler)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
inline bool comp(const pair<char,int>& pr1,const pair<char,int>& pr2)
{
    return pr1.second < pr2.second;
}

class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        vector<int> cnt(26,0);
        for(char ch : tasks)
            cnt[ch-'A']++;
        
        sort(cnt.begin(),cnt.end());
        auto iter = cnt.rbegin();
        int Max = *iter;
        int ct = 0;
        for(auto it = cnt.rbegin();it != cnt.rend() && (*it) == Max;it++)
        {
            ct++;
        }
        
        int res = (Max - 1)*(n + 1) + ct;
        int len = tasks.size();
        return max(len,res);
    }
};
```
    
## 常数时间插入、删除和获取随机元素
[LeetCode链接](https://leetcode-cn.com/problems/insert-delete-getrandom-o1)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class RandomizedSet {
public:
    /** Initialize your data structure here. */
    RandomizedSet() {
        srand(time(0));
    }
    
    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    bool insert(int val) {
        if(mp.find(val) != mp.end()) return false;
        
        nums.push_back(val);
        mp[val] = nums.size() - 1;
        return true;
    }
    
    /** Removes a value from the set. Returns true if the set contained the specified element. */
    bool remove(int val) {
        if(mp.find(val) == mp.end()) return false;
        
        int tmp = mp[val];
        int len = nums.size();
        swap(nums[tmp],nums[len-1]);
        
        mp[nums[tmp]] = tmp;
        mp.erase(val);
        nums.pop_back();
        
        return true;
    }
    
    /** Get a random element from the set. */
    int getRandom() {
        return nums[rand() % nums.size()];
    }
    
private:
    vector<int> nums;
    unordered_map<int,int> mp;
};

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * bool param_1 = obj.insert(val);
 * bool param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```
    
## 寻找峰值
[LeetCode链接](https://leetcode-cn.com/problems/find-peak-element)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
         int ret = -1;
        int l = 0,r = nums.size() - 1,mid;
        while(l < r){
            mid = (l + r) >> 1;
            if(nums[mid] < nums[mid + 1])
                l = mid + 1;
            else if(nums[mid] > nums[mid + 1])
                r = mid;
            //假设输入合法，如果nums[mid] == nums[mid+1]会无限循环
            //为了代码的简洁性暂时不处理这种情况
        }
        return l == r ? l : -1;
    }
}; 
```
    
## 单词搜索
[LeetCode链接](https://leetcode-cn.com/problems/word-search)

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    bool recursion(const vector<vector<char>>& board,vector<vector<bool>>& vis,const string& word,int a,int b,int idx)
    {
        if(idx == word.size())
            return true;
        
        if(a < 0 || a >= board.size() || b < 0 || b >= board[0].size() || vis[a][b] || word[idx] != board[a][b])
            return false;
        
        
        vis[a][b] = true;
        bool res = false;
        res = recursion(board,vis,word,a-1,b,idx+1) || recursion(board,vis,word,a+1,b,idx+1) 
              || recursion(board,vis,word,a,b-1,idx+1) || recursion(board,vis,word,a,b+1,idx+1);
        
        vis[a][b] = false;
        
        return res;
    }
    
    bool exist(vector<vector<char>>& board, string word) {
        if(board.empty())
            return false;
        
        int row = board.size();
        int col = board[0].size();
        if(word.size() > row*col)
            return false;
        
        vector<vector<bool>> vis(row,vector<bool>(col,false));
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
            {
                if(board[i][j] == word[0])
                {
                    if(recursion(board,vis,word,i,j,0))
                        return true;
                }
            }
        
        return false;
    }
};
```
    
## 搜索旋转排序数组
[LeetCode链接](https://leetcode-cn.com/problems/search-in-rotated-sorted-array)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int len = nums.size();
        if(len == 0)
            return -1;
        if(len == 1)
        {
            if(target == nums[0])
                return 0;
            else
                return -1;
        }
        
        int l = 0,r = len-1;
        while(l <= r)
        {
            int m = (r + l)/2;
            if(nums[m] == target)
                return m;
            
            if(nums[m] > nums[r])
            {
                if(target >= nums[l] && target < nums[m])
                    r = m-1;
                else
                    l = m+1;
            }
            else if(nums[m] <= nums[r])
            {
                if(target > nums[m] && target <= nums[r])
                    l = m+1;
                else
                    r = m-1;
            }
        }
        
        return -1;
    }
};
```
    
## 搜索旋转排序数组II
[LeetCode链接](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    bool normalSearch(vector<int>& nums,int target)
    {
        auto it = find_if(nums.begin(),nums.end(),[target](const int& a){return a == target;});
        if(it == nums.end())
            return false;
        
        return true;
    }
    
    bool search(vector<int>& nums, int target) {
         int len = nums.size();
        if(len == 0)
            return false;
        if(len == 1)
        {
            if(target == nums[0])
                return true;
            else
                return false;
        }
        
        int l = 0,r = len-1;
        while(l <= r)
        {
            int m = (r + l)/2;
            if(nums[m] == target)
                return true;
            
            if(nums[m] == nums[l] && nums[m] == nums[r])
            {
                return normalSearch(nums,target);
            }
            
            if(nums[m] > nums[r])//nums[m]位于左边有序段
            {
                if(target >= nums[l] && target < nums[m])
                    r = m-1;
                else
                    l = m+1;
            }
            else if(nums[m] <= nums[r])//nums[m]位于右边有序段
            {
                if(target > nums[m] && target <= nums[r])
                    l = m+1;
                else
                    r = m-1;
            }
        }
        
        return false;
    }
};
```
    
## 在排序数组中查找元素的第一个和最后一个位置
[LeetCode链接](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        auto it=find(nums.begin(),nums.end(),target);
        if(it==nums.end())
            return {-1,-1};
        
        int start=-1;
        int end=-1;
        int len=nums.size();
        int l=0;
        int r=len-1;
        
        while(l<=r)
        {
            int m=l+(r-l)/2;
            if(nums[m]<target)
                l=m+1;
            else if(nums[m]>target)
                r=m-1;
            else if(nums[m]==target)
            {
                if(m==0)
                {
                    start=0;
                    break;
                }
                if(nums[m-1]!=target)
                {
                    start=m;
                    break;
                }
                else 
                    r=m-1;
            }
        }
        
        
        l=0;
        r=len-1;
         while(l<=r)
        {
            int m=l+(r-l)/2;
            if(nums[m]<target)
                l=m+1;
            else if(nums[m]>target)
                r=m-1;
            else if(nums[m]==target)
            {
                if(m==len-1)
                {
                    end=len-1;
                    break;
                }
                if(nums[m]!=nums[m+1])
                {
                    end=m;
                    break;
                }
                else
                    l=m+1;
            }
        }
        
       return {start,end};
        
    }
};
```

## 合并区间
[LeetCode链接](https://leetcode-cn.com/problems/merge-intervals)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector<Interval> merge(vector<Interval>& intervals) {
        int len=intervals.size();
        if(len==0 || len==1)
            return intervals;
        
        sort(intervals.begin(),intervals.end(),
             [](const Interval& a,const Interval& b)
             {
                 return a.start<b.start;
             });
        
        vector<Interval> res;
        res.push_back(intervals[0]);
        for(int i=1;i<len;i++)
        {
            int tail=res.back().end;
            if(intervals[i].start<=tail)
            {
                res[res.size()-1].end=max(tail,intervals[i].end);
            }
            else
                res.push_back(intervals[i]);
        }
        
        return res;
    }
};
```
    
## 跳跃游戏
[LeetCode链接](https://leetcode-cn.com/problems/jump-game)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int len=nums.size();
        if(len==0)
            return false;
        
        vector<bool> dp(len,false);
        dp[0]=true;
        for(int i=1;i<len;i++)
        {
            for(int j=i-1;j>=0;j--)
            {
                if(dp[j])
               {
                if(nums[j]>=i-j)
                {
                    dp[i]=true;
                    break;
                }
               }
            }
        }
        
        return dp[len-1];
    }
};
```
    
## 下一个排列
[LeetCode链接](https://leetcode-cn.com/problems/next-permutation)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int len = nums.size();
        if(len <= 0)
            return;
        
        int idx = len - 1;
        for(;idx >= 1 && nums[idx-1] >= nums[idx];idx--);
        
        if(idx == 0)
        {
            reverse(nums.begin(),nums.end());
            return;
        }
        
        int idx_l = idx - 1;
        for(int i=idx;idx<len;idx++)
        {
            if(nums[idx] <= nums[idx_l])
                break;
        }
        
        swap(nums[idx-1],nums[idx_l]);
        
        reverse(nums.begin() + idx_l + 1,nums.end());
        
        return;
    }
};
```
    
## 缺失的第一个正数
[LeetCode链接](https://leetcode-cn.com/problems/first-missing-positive)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int len = nums.size();
        if(len == 0) return 1;
        
        for(int i=0;i<len;i++)
        {
            while(nums[i] > 0 && nums[i] <= len && nums[i] != i+1 && nums[nums[i] - 1] != nums[i])
            {
                swap(nums[nums[i] - 1],nums[i]);
            }
        }
        
        for(int i=0;i<len;i++)
        {
            if(nums[i] != i+1)
                return i+1;
        }
        
        return len+1;
    }
};
```
    
## 寻找两个有序数组的中位数
[LeetCode链接](https://leetcode-cn.com/problems/median-of-two-sorted-arrays)

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int len1=nums1.size();
        int len2=nums2.size();
        
        vector<int> nums3(len1+len2,0);
        int i=0;
        int j=0;
        int index=0;
        while(i<len1 && j<len2)
        {
            if(nums1[i]<nums2[j])
                nums3[index++]=nums1[i++];
            else
                nums3[index++]=nums2[j++];
        }
        
        while(i<len1)
        {
            nums3[index++]=nums1[i++];
        }
        
        while(j<len2)
        {
            nums3[index++]=nums2[j++];
        }
        
        double res;
        int len3=nums3.size();
        if((len3&0x1)==0)
        {
            res=(double)(nums3[len3/2]+nums3[len3/2-1])/2;
        }
        else
        {
            res=(double)nums3[len3/2];
        }
        
        return res;
    }
};
```
    
