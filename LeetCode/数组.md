* **数组类总结**
    * **找规律**
       * [螺旋矩阵](#螺旋矩阵) (`medium`)
       * [螺旋矩阵II](#螺旋矩阵II) (`medium`)
       * [旋转图像](#旋转图像) (`medium`)
       * [除自身以外数组的乘积](#除自身以外数组的乘积) (`medium`)
       * [矩阵置零](#矩阵置零) (`medium`)
    * **二分查找**
       * [寻找旋转排序数组中的最小值](#寻找旋转排序数组中的最小值) (`medium` `二分`)
       * [寻找旋转排序数组中的最小值II](#寻找旋转排序数组中的最小值II) (`hard` `二分`)
       * [搜索旋转排序数组](#搜索旋转排序数组) (`medium` `二分`)
       * [搜索旋转排序数组II](#搜索旋转排序数组II) (`medium` `二分`)
       * [寻找峰值](#寻找峰值) (`medium` `二分`)
       * [在排序数组中查找元素的第一个和最后一个位置](#在排序数组中查找元素的第一个和最后一个位置) (`medium` `二分`)
       * [寻找两个有序数组的中位数](#寻找两个有序数组的中位数) (`hard` `二分` `分治`)
    * **双指针**
       * [移动零](#移动零) (`easy` `双指针`)
       * [判断子序列](#判断子序列) (`medium` `双指针`)
       * [盛最多水的容器](#盛最多水的容器) (`medium` `双指针`)
       * [三数之和](#三数之和) (`medium` `双指针`)
       * [最接近的三数之和](#最接近的三数之和) (`medium` `双指针`)
       * [删除排序数组中的重复项](#删除排序数组中的重复项) (`easy` `双指针`)
       * [合并两个有序数组](#合并两个有序数组) (`easy` `双指针`)
    * **哈希**
       * [存在重复元素](#存在重复元素) (`easy` `哈希`)
       * [两数之和](#两数之和) (`easy` `哈希`)
       * [求众数](#求众数) (`easy` `哈希`)
    * **其他**
       * [杨辉三角](#杨辉三角) (`easy` `迭代`)
       * [缺失数字](#缺失数字) (`easy` `位运算` `数学`)
       * [加一](#加一) (`easy` `数学`)
       * [旋转数组](#旋转数组) (`easy`)
       * [合并区间](#合并区间) (`medium` `排序`)
       * [下一个排列](#下一个排列) (`medium`)
       * [寻找重复数](#寻找重复数) (`medium` `交换`)
       * [缺失的第一个正数](#缺失的第一个正数) (`hard` `交换`)
    
    
# 数组类总结
## 杨辉三角
[LeetCode链接](https://leetcode-cn.com/problems/pascals-triangle/)

给定一个非负整数 *numRows*，生成杨辉三角的前 *numRows* 行。

![1](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

在杨辉三角中，每个数是它左上方和右上方的数的和。

**示例**:
```
输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

### 解答

利用杨辉三角的性质，利用上一行的数值推导出下一行，推导关系式为：

* 时间复杂度O(n<sup>2</sup>)
* 空间复杂度O(n<sup>2</sup>)

```c++
class Solution {
public:
    vector<int> transform(vector<int> vec)
    {
        vector<int> res;
        res.push_back(1);
        int len=vec.size();
        for(int i=1;i<len;i++)
        {
            res.push_back(vec[i-1]+vec[i]);
        }
        res.push_back(1);
        return res;
        
    }
    
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> res;
        if(numRows==0)
            return res;
        if(numRows==1)
        {
            res.push_back({1});
            return res;
        }
        
        res.push_back({1});
        for(int i=1;i<numRows;i++)
        {
            res.push_back(transform(res[i-1]));
        }
        
        return res;
    }
};
```
    
## 求众数
[LeetCode链接](https://leetcode-cn.com/problems/majority-element/)

给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数**大于** ⌊ `n/2` ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在众数。

**示例 1**：
```
输入：[3,2,3]
输出：3
```

**示例 2**：
```
输入：[2,2,1,1,1,2,2]
输出：2
```
    
### 解答
#### 方法1：哈希表

基于原数组建立哈希表，key为元素，value为元素个数，找出value > len/2的元素就是众数

* 时间复杂度O(n)
* 空间复杂度O(n)

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        unordered_map<int,int> mp;
        int len = nums.size();
        int res = INT_MIN;
        for(auto a : nums)
        {
            mp[a]++;
            if(mp[a] > len/2) 
            {
                res = a;
                break;
            }
        }
        
        return res;
    }
};
```

#### 方法2：摩尔投票法

[参见博客](https://www.cnblogs.com/grandyang/p/4233501.html)

* 时间复杂度O(n)
* 空间复杂度O(1)

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int cnt = 0;
        int res = 0;
        for(int i=0;i<nums.size();i++)
        {
            if(cnt == 0)
            {
                cnt++;
                res = nums[i];
            }
            else if(nums[i] == res)
                cnt++;
            else
                cnt--;
        }
        
        return res;
        
    }
};
```

    
## 移动零
[LeetCode链接](https://leetcode-cn.com/problems/move-zeroes/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例**:
```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```
**说明**:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。
    
### 解答

双指针法，快指针i遍历一遍数组，当快指针的元素非零时，令慢指针idx的元素等于快指针元素，同时慢指针前进一步。最后，所有的非零元素都移到了数组前半部分（相对顺序不变），然后将之后的元素全部置0。

* 时间复杂度O(n)
* 空间复杂度O(1)
    
```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if(nums.empty())
            return;
        
        int idx = 0;
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i] != 0)
            {
                nums[idx++] = nums[i];
            }
        }
        
        for(;idx<nums.size();idx++)
            nums[idx] = 0;
        
        return;
    }
};
```

## 缺失数字
[LeetCode链接](https://leetcode-cn.com/problems/missing-number/)

给定一个包含 `0, 1, 2, ..., n` 中 `n` 个数的序列，找出 `0 .. n` 中没有出现在序列中的那个数。

**示例 1**:
```
输入: [3,0,1]
输出: 2
```

**示例 2**:
```
输入: [9,6,4,2,3,5,7,0,1]
输出: 8
```

**说明**:

你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?

### 解答
#### 方法1：位运算

将原数组的所有元素和0~n的所有数字做异或运算，得到结果就是缺失的数字

* 时间复杂度O(n)
* 空间复杂度O(1)

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int res=0;
        for(int i=0;i<nums.size();i++)
        {
            res^=(i+1)^nums[i];
        }
        
        return res;
    }
};
```

#### 方法2：等差数列

等差数列求0~n的和减去数组所有元素相加得到的和即为缺失的数字

* 时间复杂度O(n)
* 空间复杂度O(1)

```
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int sum = 0;
        int n = nums.size();
        for(auto num : nums) sum += num;
        return (int)((1 + n)*n/2) - sum;
    }
};
```

    
## 存在重复元素
[LeetCode链接](https://leetcode-cn.com/problems/contains-duplicate/)

给定一个整数数组，判断是否存在重复元素。

如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。

**示例 1**:
```
输入: [1,2,3,1]
输出: true
```

**示例 2**:
```
输入: [1,2,3,4]
输出: false
```

### 解答

利用unordered_set无序集合，遍历数组的时候将元素放入集合中，找出已经在集合中出现的元素就是重复的元素

* 时间复杂度O(n)
* 空间复杂度O(n)

    
```c++
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        if(nums.empty())
            return false;
        
        int len=nums.size();
        unordered_set<int> st;
        for(auto a:nums)
        {
            if(st.find(a) != st.end())
                return true;
            else
                st.insert(a);
        }
        
        return false;
    }
};
```
    
## 两数之和
[LeetCode链接](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

**示例**:
```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

### 解答

维护一个hash表，边遍历数组边存储值到hash表中，当遍历到`nums[i]`时，如果hash[target - nums[i]] > 0，那么就找到了符合条件的两个值

* 时间复杂度O(n)
* 空间复杂度O(n)

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res(2,-1);
        unordered_map<int, int> hash;
        for(int i = 0; i < nums.size(); i++) {
            if(hash.count(target - nums[i]) != 0) {
                res[0] = hash[target - nums[i]];
                res[1] = i;
                break;
            }
            hash[nums[i]] = i;
        }
        return res;
    }
};
```
    
## 最接近的三数之和
[LeetCode链接](https://leetcode-cn.com/problems/3sum-closest/)

给定一个包括 *n* 个整数的数组 `nums` 和 一个目标值 `target`。找出 `nums` 中的三个整数，使得它们的和与 `target` 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
```
例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
```

### 解答

思路和[三数之和](#三数之和)类似：先排序数组，遍历数组取第一个数(`只到数组倒数第三个元素`)，剩下两个数在第一个数的右边部分，定义双指针l和r分别指向`i+1`和`len-1`，当前三数和`tmp = nums[l] + nums[r] + nums[i]`，然后向中间移动，移动规则如下：

1. 如果`tmp < target`，则++l，同时比较`abs(tmp - target)`和`abs(res - target)`，取较小值对应的那个三数和给结果`res`
2. 如果`tmp > target`，则--r，同时比较`abs(tmp - target)`和`abs(res - target)`，取较小值对应的那个三数和给结果`res`
3. 如果`tmp == target`，则tmp即为所求


* 时间复杂度O(n<sup>2</sup>)
* 空间复杂度O(1)

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(),nums.end());
        int len = nums.size();
        if(len < 3) return INT_MAX;
        
        int res = nums[0] + nums[1] + nums[2];
        
        for(int i=0;i<len-2;i++)
        {
            if(i == 0 || nums[i] != nums[i-1])
            {
                int l = i+1,r = len-1;
                while(l < r)
                {
                    int tmp = nums[l] + nums[r] + nums[i];
                    if(tmp < target)
                    {
                        res = abs(res - target) < abs(target - tmp) ? res : tmp;
                        ++l;
                    }
                    else if(tmp > target)
                    {
                        res = abs(res - target) < abs(target - tmp) ? res : tmp;
                        --r;
                    }
                    else{
                        return tmp;
                    }
                    
                    if(i > 0)
                    {
                        while(l < r && nums[l] == nums[l-1]) ++l;
                        while(l < r && nums[r] == nums[r+1]) --r;
                    }
                }
            }
            
        }
        
        return res;
    }
};
```
    
## 三数之和
[LeetCode链接](https://leetcode-cn.com/problems/3sum)

给定一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 `a`，`b`，`c` ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

**注意**：答案中不可以包含重复的三元组。
```
例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

### 解答

对整个数组排序，先遍历数组取三数中的第一个数`nums[i]`，注意`num[i]`只到数组的倒数第三个元素，然后剩下两个数需要满足条件`target = 0 - nums[i]`,这两个数在数组中`num[i]`后面部分，维持两个双指针`l`和`r`，令`tmp = nums[l] + nums[r]`，处理情况如下：
1. 如果`tmp < target`，则`l`右移一步；
2. 如果`tmp > target`，则`r`左移一步；
3. 否则，满足条件，添加两个数到结果数组中，同时将`l`和`r`分别右移和左移到下一个不重复的元素处。

**注意**：遍历数组的时候取第一个数的时候过滤重复元素，可以提高查找效率

* 时间复杂度O(n<sup>2</sup>)
* 空间复杂度O(1)
    
```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int len = nums.size();
        if(len < 3)
            return vector<vector<int>>();
        
        sort(nums.begin(),nums.end());
        vector<vector<int>> res;
        for(int i=0;i<len-2;i++)
        {
            if(i == 0 || (i > 0 && nums[i] != nums[i-1]))
            {
                int l = i+1;
                int r = len-1;
                int target = 0 - nums[i];
                while(l < r)
                {
                    int tmp = nums[l] + nums[r];
                    if(target > tmp)
                    {
                        l++;
                    }
                    else if(target < tmp)
                    {
                        r--;
                    }
                    else{
                        res.push_back({nums[i],nums[l],nums[r]});
                        l++;
                        r--;
                        while(l < r && nums[l] == nums[l-1])
                            l++;
                        while(l < r && nums[r] == nums[r+1])
                            r--;
                    }
                }
                
            }
        }
        
        return res;
    }
};
```
    
## 删除排序数组中的重复项
[LeetCode链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

给定一个排序数组，你需要在**原地**删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在**原地修改输入数组**并在使用 O(1) 额外空间的条件下完成。

**示例 1**:
```
给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
```

**示例 2**:
```
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
```

### 解答

双指针，快指针`i`遍历数组，每当找到下一个不重复的元素即`nums[i] != nums[i-1]`时，慢指针`idx`位置的值nums[idx++] = nums[i]（同时idx前进一步）。

* 时间复杂度O(n)
* 空间复杂度O(1)
    
```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int len=nums.size();
        if(len==0)
            return 0;
        
        int index=1;
        for(int i=1;i<len;i++)
        {
            if(nums[i]!=nums[i-1])
                nums[index++]=nums[i];
        }
        while(nums.size()!=index)
            nums.pop_back();
        
        return index;
    }
};
```
    
## 合并两个有序数组
[LeetCode链接](https://leetcode-cn.com/problems/merge-sorted-array/)

给定两个有序整数数组 `nums1` 和 `nums2`，将 `nums2` 合并到 `nums1` 中，使得 `num1` 成为一个有序数组。

**说明**:

* 初始化 `nums1` 和 `nums2` 的元素数量分别为 `m` 和 `n`。
* 你可以假设 `nums1` 有足够的空间（空间大小大于或等于 `m + n`）来保存 `nums2` 中的元素。

**示例**:
```
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```

### 解答

双指针法，思路同[合并两个有序链表](https://github.com/Making-It/Code/blob/master/LeetCode/%E9%93%BE%E8%A1%A8.md#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8)

* 时间复杂度O(m+n)
* 空间复杂度O(m+n)
    
```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
       for(int i=m,j=0;i<m+n ;i++)
           nums1[i]=nums2[j++];
        
        vector<int> vec(m+n,0);
        
        int l=0;
        int r=m;
        int cnt=0;
        while(l<m && r<m+n)
        {
            vec[cnt++]=nums1[l]<nums1[r]?nums1[l++]:nums1[r++];
        }
        while(l<m)
            vec[cnt++]=nums1[l++];
        while(r<m+n)
            vec[cnt++]=nums1[r++];
        
        copy(vec.begin(),vec.end(),nums1.begin());
    }
};
```
    
## 加一
[LeetCode链接](https://leetcode-cn.com/problems/plus-one/)

给定一个由**整数**组成的**非空**数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

**示例 1**:
```
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
```

**示例 2**:
```
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
```

### 解答

按照数学十进制进位规则，从数组末尾向前进位得到结果。

* 时间复杂度O(n)
* 空间复杂度O(n)

```c++
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        vector<int> res;
        int len=digits.size();
        int a=0;
        int b=0;
        int tmp=0;
        for(int i=len-1;i>=0;i--)
        {
            if(i==len-1)
                tmp=digits[i]+1;
            else
                tmp=digits[i]+a;
            
            a=tmp/10;
            b=tmp%10;
            res.push_back(b);
        }
        if(a>0)
            res.push_back(a);
        
        reverse(res.begin(),res.end());
        return res;
        
    }
};
```
    
## 旋转数组
[LeetCode链接](https://leetcode-cn.com/problems/rotate-array/)

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

**示例 1**:
```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```

**示例 2**:
```
输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```

**说明**:

* 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
* 要求使用空间复杂度为 O(1) 的原地算法。

### 解答
#### 方法1

设数组的长度为`len`，`k`对`len`取模得到`k1 = k % len`，开辟一个新数组`cp`拷贝`nums`，`nums`的值清空，然后进行如下步骤：
1. 将`cp`数组的最后`k1`个元素添加到数组`nums`尾部
2. 将`cp`数组的开始`len-k1`个元素添加到数组`nums`尾部

* 时间复杂度O(n)
* 空间复杂度O(n)

```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int len = nums.size();
        int k1 = k%len;
        
        vector<int> cp(nums);
        nums.clear();
        
        copy(cp.end()-k1,cp.end(),back_inserter(nums));
        copy(cp.begin(),cp.end()-k1,back_inserter(nums));
    }
};
```

#### 方法2

设数组的长度为`len`，`k`对`len`取模得到`k1 = k % len`，然后进行如下步骤：
1. 反转数组的最后k1个元素
2. 反转数组的前面len-k1个元素
3. 反转整个数组

最后得到的数组的就是旋转之后的数组

* 时间复杂度O(n)
* 空间复杂度O(1)
    
```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        if(k==nums.size())
            return;
        
        int len=nums.size();
        int k1=k%len;
        
        reverse(nums.begin(),nums.end()-k1);
        reverse(nums.end()-k1,nums.end());
        reverse(nums.begin(),nums.end());
    }
};
```
 
## 螺旋矩阵
[LeetCode链接](https://leetcode-cn.com/problems/spiral-matrix/)

给定一个包含 `m x n` 个元素的矩阵（`m` 行, `n` 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

**示例 1**:
```
输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
输出: [1,2,3,6,9,8,7,4,5]
```

**示例 2**:
```
输入:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
输出: [1,2,3,4,8,12,11,10,9,5,6,7]
```

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void solution(int x1,int y1,int x2,int y2,vector<int>& vec,vector<vector<int>>& matrix)
    {
        int i=x1,j=y1;
        if(x1 < x2 && y1 < y2)
        {
            for(;j<y2;j++)
           {
            vec.push_back(matrix[i][j]);
           }
        for(;i<x2;i++)
        {
            vec.push_back(matrix[i][j]);
        }
        for(;j>y1;j--)
        {
            vec.push_back(matrix[i][j]);
        }
        for(;i>x1;i--)
        {
            vec.push_back(matrix[i][j]);
        }
        }
        else if(x1 == x2)
        {
            for(;j<=y2;j++)
                vec.push_back(matrix[i][j]);
        }
        else if(y1 == y2)
        {
            for(;i<=x2;i++)
                vec.push_back(matrix[i][j]);
        }
    }
    
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty())
            return vector<int>();
        
        vector<int> res;
        int m = matrix.size();
        int n = matrix[0].size();
        int x1 = 0,y1 = 0;
        int x2 = m-1,y2 = n-1;
        while(x1<=x2 && y1<=y2)
        {
            solution(x1++,y1++,x2--,y2--,res,matrix);
        }
        
        return res;
    }
    
};
```
    
## 螺旋矩阵II
[LeetCode链接](https://leetcode-cn.com/problems/spiral-matrix-ii/)

给定一个正整数 `n`，生成一个包含 1 到 `n<sup>2</sup>` 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

**示例**:
```
输入: 3
输出:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
```

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void setVal(int x1,int y1,int x2,int y2,vector<vector<int>>& vec)
    {
        if(x1 == x2)
        {
            for(int i=y1;i<=y2;i++)
            {
                vec[x1][i] = cnt++;
            }
            
            return;
        }
        
        if(y1 == y2)
        {
            for(int i=x1;i<=x2;i++)
            {
                vec[i][y1] = cnt++;
            }
            return;
        }
        
        for(int i=y1;i<y2;i++)
        {
            vec[x1][i] = cnt++;
        }
        
        for(int i=x1;i<x2;i++)
        {
            vec[i][y2] = cnt++;
        }
        
        for(int i=y2;i>y1;i--)
        {
            vec[x2][i] = cnt++;
        }
        
        for(int i=x2;i>x1;i--)
        {
            vec[i][y1] = cnt++;
        }
    }
    
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res;
        if(n == 0) return res;
        cnt = 1;
        const int sum = n*n;
        res.resize(n,vector<int>(n));
        int x1 = 0,y1 = 0,x2 = n-1,y2 = n-1;
        while(x1 <= x2 && y1 <= y2)
        {
            setVal(x1++,y1++,x2--,y2--,res);
        }
        
        
        return res;
    }
    
private:
    int cnt;
};
```

## 旋转图像
[LeetCode链接](https://leetcode-cn.com/problems/rotate-image/)

给定一个 `n × n` 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

**说明**：

你必须在**原地**旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要**使用另一个矩阵来旋转图像。

**示例 1**:
```
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

**示例 2**:
```
给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void rotate_circle(int x1,int y1,int x2,int y2,vector<vector<int>>& vec)
    {
        vector<int> tmp;
        for(int i=x1;i<x2;i++)
        {
            tmp.push_back(vec[i][y1]);
        }
        
        int i=x2-1;
        int j=y2-1;
        while(i>=x1 && j>=y1)
        {
            vec[i--][y1]=vec[x2][j--];
        }
        
        i=x1+1;
        j=y2-1;
        while(j>=y1 && i<=x2)
        {
            vec[x2][j--]=vec[i++][y2];
        }
        
        i=x1+1;
        j=y1+1;
        while(i<=x2)
        {
            vec[i++][y2]=vec[x1][j++];
        }
        
        j=y2;
        i=0;
        while(j>y1)
        {
            vec[x1][j--]=tmp[i++];
        }
    }
    void rotate(vector<vector<int>>& matrix) {
        int row=matrix.size();
        int col=matrix[0].size();
        int a1=0,b1=0;
        int a2=row-1,b2=col-1;
        while(a1<a2 && b1<b2)
        {
            rotate_circle(a1++,b1++,a2--,b2--,matrix);
        }
        
    }
};
```
    
## 寻找重复数
[LeetCode链接](https://leetcode-cn.com/problems/find-the-duplicate-number/)

给定一个包含 `n + 1` 个整数的数组 `nums`，其数字都在 1 到 `n` 之间（包括 1 和 `n`），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

**示例 1**:
```
输入: [1,3,4,2,2]
输出: 2
```

**示例 2**:
```
输入: [3,1,3,4,2]
输出: 3
```

**说明**：

* **不能**更改原数组（假设数组是只读的）。
* 只能使用额外的 O(1) 的空间。
* 时间复杂度小于 O(n<sup>2</sup>) 。
* 数组中只有一个重复的数字，但它可能不止重复出现一次。

### 解答

遍历数组，判断当前元素`nums[i]`是否和位置`i+1`相等：
1. 如果`nums[i] == i+1`，则`nums[i]`位于它自己的位置，`++i`遍历下一个元素；
2. 否则，找到位置是`nums[i]-1`位置的元素`nums[nums[i] - 1]`：
   * 如果`nums[nums[i] - 1] == nums[i]`,则找到重复元素`nums[i]`
   * 否则，交换`nums[nums[i] - 1]`和`nums[i]`   
   重复`情况2`的过程，直到`nums[i] == i+1`时，执行`情况1`。

* 时间复杂度O(n)
* 空间复杂度O(1)
    
```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        if(nums.empty())
            return 0;
        
        for(int i=0;i<nums.size();i++)
        {
            while(nums[i] != i+1)
            {
                int tmp = nums[i];
                if(nums[tmp-1] == tmp)
                    return tmp;
                swap(nums[i],nums[tmp-1]);
            }
            
        }
        
        return -1;
    }
};
```
    
## 除自身以外数组的乘积
[LeetCode链接](https://leetcode-cn.com/problems/product-of-array-except-self/)

给定长度为 `n` 的整数数组 `nums`，其中 `n > 1`，返回输出数组 `output` ，其中 `output[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

**示例**:
```
输入: [1,2,3,4]
输出: [24,12,8,6]
```

**说明**: 请**不要使用除法**，且在 O(n) 时间复杂度内完成此题。

**进阶**：

你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组**不被视为**额外空间。）

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int len = nums.size();
        if(len == 0) return nums;
        
        vector<int> res(len,1);
        for(int i=1;i<len;i++)
        {
            res[i] = res[i-1]*nums[i-1];
        }
        
        int tmp = 1;
        for(int i=len-2;i>=0;i--)
        {
            tmp *= nums[i+1];
            res[i] *= tmp; 
        }
        
        return res;
    }
};
```
    

## 矩阵置零
[LeetCode链接](https://leetcode-cn.com/problems/set-matrix-zeroes)

给定一个 `m x n` 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。

**示例 1**:
```
输入: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
```

**示例 2**:
```
输入: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
```

**进阶**:

* 一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。
* 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
* 你能想出一个常数空间的解决方案吗？

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int h=matrix.size();
        int l=matrix[0].size();
        vector<bool> row(h,false),col(l,false);
        for(int i=0;i<h;i++)
            for(int j=0;j<l;j++)
            {
                if(matrix[i][j]==0)
                {
                    row[i]=true;
                    col[j]=true;
                }
            }
        
        for(int i=0;i<h;i++)
        {
           for(int j=0;j<l;j++)
           {
               if(row[i])
                   matrix[i][j]=0;
               if(col[j])
                   matrix[i][j]=0;
           }
        }
    }
};
```
    
    
## 盛最多水的容器
[LeetCode链接](https://leetcode-cn.com/problems/container-with-most-water)

给定 n 个非负整数 *a1，a2，...，an*，每个数代表坐标中的一个点 *(i, ai)* 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 *(i, ai)* 和 *(i, 0)* 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

**说明**：你不能倾斜容器，且 n 的值至少为 2。

![1](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

图中垂直线代表输入数组 `[1,8,6,2,5,4,8,3,7]`。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

**示例**:
```
输入: [1,8,6,2,5,4,8,3,7]
输出: 49
```

### 解答

双指针法，定义两个指针`l`和`r`分别指向数组两端，两个指针向中间移动，移动规则如下：

1. 如果height[l] < height[r]，则++l
2. 否则，--r

每走一步，计算容器装水量为左右边缘较小的那个高度乘边缘的的距离`min(height[l],height[r]) * (r - l)`,然后和结果比较去较大值。

* 时间复杂度O(n)
* 空间复杂度O(1)
    
```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int len = height.size();
        if(len == 0) return 0;
        
        int res = 0;
        int l = 0;
        int r = len - 1;
        while(l < r)
        {
            int tmp = min(height[l],height[r]);
            int sum = (r - l)*tmp;
            if(height[l] < height[r])
                ++l;
            else
                --r;
            
            res = max(res,sum);
            
            while(l < r && tmp == height[l]) ++l;
            while(l < r && tmp == height[r]) --r;
        }
        
        return res;
    }
};
```
    
## 寻找旋转排序数组中的最小值
[LeetCode链接](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array)

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

**示例 1**:
```
输入: [3,4,5,1,2]
输出: 1
```

**示例 2**:
```
输入: [4,5,6,7,0,1,2]
输出: 0
```

### 解答

首先判断数组是否已经旋转，如果`nums[0] < num[len-1]`那么数组没有旋转，直接返回`nums[0]`；否则，数组旋转。

二分查找：定义两个指针l和r分别指向数组两端，取`m = (r + l)/2`，找到中间那个数`nums[m]`和`nums[l]`和`nums[r]`比较：

1. 如果`nums[m] < nums[l]`，则在右半段搜索；
2. 如果`nums[m] > nums[l]`，则在左半段搜索；

直到l和r相邻，返回`nums[r]`

* 时间复杂度O(log n)
* 空间复杂度O(1)
```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int len = nums.size();
        if(len == 0) return -1;
        int l = 0,r = len-1;
        if(nums[l] < nums[r]) return nums[l];
        while(nums[l] > nums[r])
        {
            if(r - l == 1)
            {
                return nums[r];
            }
            
            int m = l + (r - l)/2;
            if(nums[m] > nums[r]) l = m;
            else r = m;        
        }
        
        return nums[0];
    }
};
```
    
## 寻找旋转排序数组中的最小值II
[LeetCode链接](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii)

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

请找出其中最小的元素。

注意数组中可能存在重复的元素。

**示例 1**：
```
输入: [1,3,5]
输出: 1
```

**示例 2**：
```
输入: [2,2,2,0,1]
输出: 0
```

**说明**：

这道题是 [寻找旋转排序数组中的最小值](#寻找旋转排序数组中的最小值) 的延伸题目。
允许重复会影响算法的时间复杂度吗？会如何影响，为什么？

### 解答

思路和 [寻找旋转排序数组中的最小值](#寻找旋转排序数组中的最小值) 一样,但是由于数组存在重复元素，会影响二分查找的效果，要特殊处理这种情况，当`nums[m] == num[l] && nums[m] == nums[r]`时，二分查找退化为遍历数组查找。

* 时间复杂度O(log n ~ n)
* 空间复杂度O(1)
    
```c++
class Solution {
public:
    int normalSearch(vector<int>& nums)
    {
        int len = nums.size();
        int res = nums[0];
        bool flag = false;
        for(int i=1;i<len;i++)
        {
            if(nums[i] < nums[i-1]) return nums[i];
            if(nums[i] != nums[i-1]) flag = true;
        }
        
        //满足此条件，数组所有元素都相同
        if(!flag) return nums[0];
        return -1;
    }
    int findMin(vector<int>& nums) {
         int len = nums.size();
        if(len == 0) return -1;
        int l = 0,r = len-1;
        if(nums[l] < nums[r]) return nums[l];
        while(l < r)
        {
            if(r - l == 1) return nums[r];
            
            int m = l + (r - l)/2;
            if(nums[m] == nums[l] && nums[m] == nums[r])
            {
                return normalSearch(nums);
            }
            if(nums[m] > nums[r]) l = m;
            else r = m;        
        }
        
        return nums[0];
    }
};
```
    
    
## 寻找峰值
[LeetCode链接](https://leetcode-cn.com/problems/find-peak-element)

峰值元素是指其值大于左右相邻值的元素。

给定一个输入数组 `nums`，其中 `nums[i] ≠ nums[i+1]`，找到峰值元素并返回其索引。

数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞`。

**示例 1**:
```
输入: nums = [1,2,3,1]
输出: 2
解释: 3 是峰值元素，你的函数应该返回其索引 2。
```

**示例 2**:
```
输入: nums = [1,2,1,3,5,6,4]
输出: 1 或 5 
解释: 你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```

**说明**: 你的解法应该是 O(logN) 时间复杂度的。

### 解答

二分查找，设左边缘和右边缘分别是`l`和`r`，找到中间值`nums[mid]`，需要判断到左半段还是右半段查找，由于题目假设`nums[-1] = nums[n] = -∞`，判断规则为：

1. 如果`nums[m] >= nums[m+1]`，则峰值位于左半段，令`r = m`
2. 如果`nums[m] < nums[m+1]`，则峰值位于右半段，令`l = m+1`

* 时间复杂度O(log n)
* 空间复杂度O(n)

```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int l = 0,r = nums.size() - 1,mid;
        while(l < r)
        {
            mid = (l + r) >> 1;
            if(nums[mid] < nums[mid + 1])
                l = mid + 1;
            else if(nums[mid] >= nums[mid + 1])
                r = mid;
        }
        return l;
    }
};
```
    

## 搜索旋转排序数组
[LeetCode链接](https://leetcode-cn.com/problems/search-in-rotated-sorted-array)

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。

**示例 1**:
```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```

**示例 2**:
```
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

### 解答

二分查找，关键是找到中间值之后，判断接下来在左半段还是右半段继续查找。根据旋转数组的规律，数组经过旋转之后会被分为两段升序段，找到中间值`nums[m]`之后，将它和搜索区域最右边元素`nums[r]`比较，处理情况如下：
1. 如果`nums[m] == target`，则返回`m`
2. 如果`nums[m] > nums[r]`，则中间值位于旋转数组的前一段升序段
    * 如果`target < nums[m] && target >= nums[l]`，则到`m`的左半段继续查找
    * 否则，到`m`的右半段继续查找
3. 如果`nums[m] <= nums[r]`，则中间值位于旋转数组的后一段升序段
    * 如果`target > nums[m] && target <= nums[r]`，则到`m`的右半段继续查找
    * 否则，到`m`的左半段继续查找

* 时间复杂度O(log n)
* 空间复杂度O(1)
```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int len = nums.size();
        int l = 0,r = len-1;
        while(l <= r)
        {
            int m = (r + l)/2;
            if(nums[m] == target)
                return m;
            else if(nums[m] > nums[r])
            {
                if(target >= nums[l] && target < nums[m])
                    r = m-1;
                else
                    l = m+1;
            }
            else if(nums[m] <= nums[r])
            {
                if(target > nums[m] && target <= nums[r])
                    l = m+1;
                else
                    r = m-1;
            }
        }
        
        return -1;
    }
};
```
    
## 搜索旋转排序数组II
[LeetCode链接](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii)

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,0,1,2,2,5,6]` 可能变为 `[2,5,6,0,0,1,2]` )。

编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 `true`，否则返回 `false`。

**示例 1**:
```
输入: nums = [2,5,6,0,0,1,2], target = 0
输出: true
```

**示例 2**:
```
输入: nums = [2,5,6,0,0,1,2], target = 3
输出: false
```

**进阶**:

* 这是 [搜索旋转排序数组](#搜索旋转排序数组) 的延伸题目，本题中的 `nums`  可能包含重复元素。
* 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？

### 解答

和 [搜索旋转排序数组](#搜索旋转排序数组) 一样还是二分查找，但是由于数组可能包含重复元素，所以当`nums[m] == nums[r]`的时候，将搜索区域的右边缘左移一个位置直到`nums[m] != nums[r]`。

* 时间复杂度O(log n)
* 空间复杂度O(1)
```c++
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int len = nums.size();
        int l = 0,r = len-1;
        while(l <= r)
        {
            int m = (r + l)/2;
            if(nums[m] == target) return true;
            else if(nums[m] > nums[r])//nums[m]位于左边有序段
            {
                if(target >= nums[l] && target < nums[m])
                    r = m-1;
                else
                    l = m+1;
            }
            else if(nums[m] < nums[r])//nums[m]位于右边有序段
            {
                if(target > nums[m] && target <= nums[r])
                    l = m+1;
                else
                    r = m-1;
            }
            else --r;
        }
        
        return false;
    }
};
```
    
## 在排序数组中查找元素的第一个和最后一个位置
[LeetCode链接](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array)

给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 O(log n) 级别。

如果数组中不存在目标值，返回 `[-1, -1]`。

**示例 1**:
```
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
```

**示例 2**:
```
输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
```

### 解答

二分查找，由于要找到目标值的第一个位置和最后一个位置。当中间值`nums[m] == target`时：

1. 如果要找第一个位置，则向`m`的左半段继续二分查找，`--r`直到`nums[m-1] != target`为止;
2. 如果要找最后一个位置，则向`m`的右半段继续二分查找，`++l`直到`nums[m+1] != target`为止；

* 时间复杂度O(log n)
* 空间复杂度O(1)

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if(nums.empty()) return {-1,-1};
        int len = nums.size();
        int l = 0,r = nums.size() - 1;
        int start = -1,end = -1;
        while(l <= r)
        {
            int m = l + (r-l)/2;
            if(nums[m] < target) l=m+1;
            else if(nums[m] > target) r = m-1;
            else
            {
                if(m==0)
                {
                    start = 0;
                    break;
                }
                if(nums[m-1] != target)
                {
                    start = m;
                    break;
                }
                else r = m-1;
            }
        }
        
        if(l > r) return {-1,-1};
        
        l = 0;
        r = nums.size() - 1;
        while(l <= r)
        {
            int m = l + (r-l)/2;
            if(nums[m] < target) l = m+1;
            else if(nums[m] > target) r = m-1;
            else 
            {
                if(m == len-1)
                {
                    end = len-1;
                    break;
                }
                if(nums[m+1] != target)
                {
                    end = m;
                    break;
                }
                else l = m+1;
            }
        }
        
       return {start,end};
        
    }
};
```


**简化代码**

查找最后一个位置的时候，中间位置计算方法是`m = (l + r +1)/2`，这样使得中间值偏向右侧，防止无限循环。例如`[8,8,10]`，如果按照`m = (l + r)/2`来计算，在查找目标值最后一个位置的时候会无限循环

* 时间复杂度O(log n)
* 空间复杂度O(1)

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> res(2,-1);
        if(nums.empty()) return res;
        int l = 0,r = nums.size() - 1;
        
        while(l < r)
        {
            int m = (l + r) / 2;
            if(nums[m] < target) l = m+1;
            else r = m;
        }
        
        if(nums[l] != target) return res;
        res[0] = l;
        
        l = 0,r = nums.size() - 1;
        while(l < r)
        {
            int m = (r + l + 1) / 2;
            if(nums[m] <= target) l = m;
            else r = m-1;
        }
        
        res[1] = l;
        
        return res;
    }
};
```

## 合并区间
[LeetCode链接](https://leetcode-cn.com/problems/merge-intervals)

给出一个区间的集合，请合并所有重叠的区间。

**示例 1**:
```
输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2**:
```
输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

### 解答

现将数组元素按照区间起点大小从小到大进行排序，遍历数组，将元素放入结果数组`res`中，同时比较结果数组中末尾元素的区间终点`tail`和当前元素`interval[i]`的区间起点：
1. 如果`tail >= intervals[i].start`，则区间出现重叠，更新结果数组`res`末尾元素的区间终点为`tail`和`intervals[i]`的较大值；
2. 如果`tail < intervals[i].start`，则区间为重叠，加入`intervals[i]`到结果数组`res`。

* 时间复杂度O(n log n)
* 空间复杂度O(n)

```c++
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector<Interval> merge(vector<Interval>& intervals) {
        int len=intervals.size();
        if(len==0 || len==1)
            return intervals;
        
        sort(intervals.begin(),intervals.end(),
             [](const Interval& a,const Interval& b)
             {
                 return a.start<b.start;
             });
        
        vector<Interval> res;
        res.push_back(intervals[0]);
        for(int i=1;i<len;i++)
        {
            int tail=res.back().end;
            if(intervals[i].start<=tail)
            {
                res[res.size()-1].end=max(tail,intervals[i].end);
            }
            else
                res.push_back(intervals[i]);
        }
        
        return res;
    }
};
```

## 下一个排列
[LeetCode链接](https://leetcode-cn.com/problems/next-permutation)

### 解答

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须**原地**修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。

`1,2,3` → `1,3,2`
`3,2,1` → `1,2,3`
`1,1,5` → `1,5,1`

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int len = nums.size();
        if(len <= 0)
            return;
        
        int idx = len - 1;
        for(;idx >= 1 && nums[idx-1] >= nums[idx];idx--);
        
        if(idx == 0)
        {
            reverse(nums.begin(),nums.end());
            return;
        }
        
        int idx_l = idx - 1;
        for(int i=idx;idx<len;idx++)
        {
            if(nums[idx] <= nums[idx_l])
                break;
        }
        
        swap(nums[idx-1],nums[idx_l]);
        
        reverse(nums.begin() + idx_l + 1,nums.end());
        
        return;
    }
};
```
    
## 缺失的第一个正数
[LeetCode链接](https://leetcode-cn.com/problems/first-missing-positive)

给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

**示例 1**:
```
输入: [1,2,0]
输出: 3
```

**示例 2**:
```
输入: [3,4,-1,1]
输出: 2
```

**示例 3**:
```
输入: [7,8,9,11,12]
输出: 1
```

**说明**:

你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。

### 解答
#### 方法1

使用unordered_set结构的集合`st`装入`nums`中的元素，同时找到`nums`元素的最大值`Max`，然后遍历1~Max范围内的数，找到第一个不在集合`st`中数就是缺失的第一个正数，如果都在集合`st`中，那么缺失的第一个正数就在1和`Max+1`的较小值中取得。

* 时间复杂度O(n)
* 空间复杂度O(n)

```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        unordered_set<int> st;
        int Max = INT_MIN;
        for(auto a : nums)
        {
            st.insert(a);
            Max = max(Max,a);
        }
        
        for(int i=1;i<=Max;i++)
        {
            if(st.count(i) == 0)
                return i;
        }
        
        return max(Max+1,1);
        
    }
};
```
#### 方法2：优化空间复杂度

对于大小为n（n>0）的数组，这n个数可以分为以下几种情况：
1. 这n个数都小于等于0
2. 这n个数都大于n
3. 存在一个或多个位于[1,n]的数

对于`情况1`和`情况2`，要查找的第一个缺失的正数就是1；

问题是对于`情况3`应该怎么考虑呢？

假设这些位于`[1,n]`的数i，在数组中的位置应该为`i-1`，而小于等于0的数，以及大于n的数，在数组剩余位置：
* 如果数组所有的数都在`[1,n]`，那么每个元素都在其值减1的位置，此时要找的第一个缺失的整数就是`n+1`
* 否则，数组中，必然存在一个位置`idx`，其元素值不等于`idx+1`，而范围`[1,n]`就是正数序列最开始的n个数，因此，从左往右查找第一个下标加1不等于值的位置，那么要找的第一个缺失的正数就是该位置的下标加1

**注意**：`交换元素`的方法可以将范围在`[1,n]`的元素放置到正确的位置,详见 [寻找重复数](#寻找重复数)

* 时间复杂度O(n)
* 空间复杂度O(1)

```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int len = nums.size();
        if(len == 0) return 1;
        
        for(int i=0;i<len;i++)
        {
            while(nums[i] > 0 && nums[i] <= len && nums[i] != i+1 && nums[nums[i] - 1] != nums[i])
            {
                swap(nums[nums[i] - 1],nums[i]);
            }
        }
        
        for(int i=0;i<len;i++)
        {
            if(nums[i] != i+1)
                return i+1;
        }
        
        return len+1;
    }
};
```
    
## 寻找两个有序数组的中位数
[LeetCode链接](https://leetcode-cn.com/problems/median-of-two-sorted-arrays)

给定两个大小为 m 和 n 的有序数组 `nums1` 和 `nums2`。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 `nums1` 和 `nums2` 不会同时为空。

**示例 1**:
```
nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
```

**示例 2**:
```
nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
```

### 解答

* 时间复杂度O()
* 空间复杂度O()
```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int len1=nums1.size();
        int len2=nums2.size();
        
        vector<int> nums3(len1+len2,0);
        int i=0;
        int j=0;
        int index=0;
        while(i<len1 && j<len2)
        {
            if(nums1[i]<nums2[j])
                nums3[index++]=nums1[i++];
            else
                nums3[index++]=nums2[j++];
        }
        
        while(i<len1)
        {
            nums3[index++]=nums1[i++];
        }
        
        while(j<len2)
        {
            nums3[index++]=nums2[j++];
        }
        
        double res;
        int len3=nums3.size();
        if((len3&0x1)==0)
        {
            res=(double)(nums3[len3/2]+nums3[len3/2-1])/2;
        }
        else
        {
            res=(double)nums3[len3/2];
        }
        
        return res;
    }
};
```

## 判断子序列
[LeetCode链接](https://leetcode-cn.com/problems/is-subsequence)

给定字符串 `s` 和 `t` ，判断 `s` 是否为 `t` 的子序列。

你可以认为 `s` 和 `t` 中仅包含英文小写字母。字符串 `t` 可能会很长（长度 ~= 500,000），而 `s` 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"`ace`"是"`abcde`"的一个子序列，而"`aec`"不是）。

**示例 1**:

s = "`abc`", t = "`ahbgdc`"

返回 `true`.

**示例 2**:

s = "`axc`", t = "`ahbgdc`"

返回 `false`.

**后续挑战** :

如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

### 解答

双指针法，设置指针`i`和`j`分别指向字符串`s`和`t`

1. 如果`s[i] == t[j]`，则`i`前进一步，`j`前进一步
2. 否则，`j`前进一步

最后，判断指针`i`是否走完`s`，就能判断`s`是否为`t`的子序列。

* 时间复杂度O(m+n)
* 空间复杂度O(1)

```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int len = s.size();
        int len1 = t.size();
        
        if(len > len1) return false;
        int i=0,j=0;
        while(i < len && j < len1)
        {
            if(s[i] == t[j])
            {
                i++;
               
            }
            
            j++;
        }
        
        if(i == len) return true;
        return false;
    }
};
```
    
