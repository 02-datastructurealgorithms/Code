* **回溯法总结**
   * [子集](#子集) (`medium`)
   * [子集II](#子集II) (`medium`)
   * [括号生成](#括号生成) (`medium`) 
   * [电话号码的字母组合](#电话号码的字母组合) (`medium`)
   * [全排列](#全排列) (`medium`)
   * [格雷编码](#格雷编码) (`medium`)
   * [累加数](#累加数) (`medium`)
   * [单词搜索](#单词搜索) (`medium`)
   * [单词搜索II](#单词搜索II) (`hard`)

# 回溯法总结

## 子集
[LeetCode链接](https://leetcode-cn.com/problems/subsets/)

给定一组**不含重复元素**的整数数组 `nums`，返回该数组所有可能的子集（幂集）。

**说明**：解集不能包含重复的子集。

**示例**:
```
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void recursion(vector<int>& vec,vector<vector<int>>& res,vector<int> tmp,int n)
    {
        if(n==vec.size())
        {
            res.push_back(tmp);
            return;
        }

        recursion(vec,res,tmp,n+1);
        
        tmp.push_back(vec[n]);
        recursion(vec,res,tmp,n+1);
    }
    
    
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> tmp;
        
        if(nums.empty())
            return res;
        
        recursion(nums,res,tmp,0);
        
        return res;
    }
};
```


## 子集II
[LeetCode链接](https://leetcode-cn.com/problems/subsets-ii/)

给定一个可能包含重复元素的整数数组 `nums`，返回该数组所有可能的子集（幂集）。

**说明**：解集不能包含重复的子集。

**示例**:
```
输入: [1,2,2]
输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
```

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    void recursion(int n,vector<int>& vec,vector<vector<int>>& res,vector<int>& path)
    {
        if(n == vec.size())
        {
            res.push_back(path);
            return;
        }
        
        path.push_back(vec[n]);
        recursion(n+1,vec,res,path);
        path.pop_back();
        
        while(n+1 < vec.size() && vec[n] == vec[n+1]) n++;
        recursion(n+1,vec,res,path);
        
    }
    
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        if(nums.empty())
            return vector<vector<int>>();
        
        sort(nums.begin(),nums.end());
        vector<vector<int>> res;
        vector<int> path;
        recursion(0,nums,res,path);
        
        return res;
    }
};
```

## 单词搜索
[LeetCode链接](https://leetcode-cn.com/problems/word-search)

给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例**:
```
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true.
给定 word = "SEE", 返回 true.
给定 word = "ABCB", 返回 false.
```

### 解答

* 时间复杂度O()
* 空间复杂度O()
    
```c++
class Solution {
public:
    bool recursion(const vector<vector<char>>& board,vector<vector<bool>>& vis,const string& word,int a,int b,int idx)
    {
        if(idx == word.size())
            return true;
        
        if(a < 0 || a >= board.size() || b < 0 || b >= board[0].size() || vis[a][b] || word[idx] != board[a][b])
            return false;
        
        
        vis[a][b] = true;
        bool res = false;
        res = recursion(board,vis,word,a-1,b,idx+1) || recursion(board,vis,word,a+1,b,idx+1) 
              || recursion(board,vis,word,a,b-1,idx+1) || recursion(board,vis,word,a,b+1,idx+1);
        
        vis[a][b] = false;
        
        return res;
    }
    
    bool exist(vector<vector<char>>& board, string word) {
        if(board.empty())
            return false;
        
        int row = board.size();
        int col = board[0].size();
        if(word.size() > row*col)
            return false;
        
        vector<vector<bool>> vis(row,vector<bool>(col,false));
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
            {
                if(board[i][j] == word[0])
                {
                    if(recursion(board,vis,word,i,j,0))
                        return true;
                }
            }
        
        return false;
    }
};
```

## 括号生成
[LeetCode链接](https://leetcode-cn.com/problems/generate-parentheses/)

给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且**有效的**括号组合。

例如，给出 n = 3，生成结果为：
```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    void recursion(const int n,int l,int r,vector<string>& res,string str)
    {
        if(l>n || r>n || l<r)
            return;
        if(l==r && l==n)
        {
            res.push_back(str);
            return;
        }
        
         recursion(n,l+1,r,res,str+'(');
         recursion(n,l,r+1,res,str+')');
        /*
        if(l==r && l<n)
            recursion(n,l+1,r,res,str+'(');
        else if(l==n && l>r)
            recursion(n,l,r+1,res,str+')');
        else if(l>r && l<n)
        {
            recursion(n,l+1,r,res,str+'(');
            recursion(n,l,r+1,res,str+')');
        }*/
    }
    vector<string> generateParenthesis(int n) {
        if(n<=0)
            return vector<string>();
        
        string str;
        vector<string> res;
        recursion(n,0,0,res,str);
        
        return res;
    }
};
```


## 电话号码的字母组合
[LeetCode链接](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![1](http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png)

**示例**:
```
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```

**说明**:

尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    void recursion(unordered_map<char,string>& mp,int n,string& str,vector<string>& res,string& tmp)
    {
        if(n==str.size())
        {
            res.push_back(tmp);
        }
        
        string s=mp[str[n]];
        for(int i=0;i<s.size();i++)
        {
            tmp.push_back(s[i]);
            recursion(mp,n+1,str,res,tmp);
            tmp.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if(digits.empty())
            return vector<string>();
        unordered_map<char,string> mp;
        mp['2']="abc";
        mp['3']="def";
        mp['4']="ghi";
        mp['5']="jkl";
        mp['6']="mno";
        mp['7']="pqrs";
        mp['8']="tuv";
        mp['9']="wxyz";
        
        vector<string> res;
        string tmp;
        recursion(mp,0,digits,res,tmp);
        
        return res;
    }
};
```

## 全排列

[LeetCode链接](https://leetcode-cn.com/problems/permutations)

给定一个**没有重复**数字的序列，返回其所有可能的全排列。

**示例**:
```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    void recursion(int n,vector<int>& vec)
    {
        if(n==vec.size())
        {
            res.push_back(vec);
            return;
        }
        
        for(int i=n;i<vec.size();i++)
        {
            swap(vec[n],vec[i]);
            recursion(n+1,vec);
            swap(vec[n],vec[i]);
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        if(nums.empty())
            return res;
        
        recursion(0,nums);
        
        return res;
    }
    
private:
    vector<int> tmp;
    vector<vector<int>> res;
};
```
    
## 格雷编码

[LeetCode链接](https://leetcode-cn.com/problems/gray-code/)

格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。

**示例 1**:
```
输入: 2
输出: [0,1,3,2]
```
解释:
```
00 - 0
01 - 1
11 - 3
10 - 2
```
对于给定的 *n*，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。
```
00 - 0
10 - 2
11 - 3
01 - 1
```

**示例 2**:
```
输入: 0
输出: [0]
```
解释: 我们定义格雷编码序列必须以 0 开头。
     给定编码总位数为 *n* 的格雷编码序列，其长度为 2<sup>n</sup>。当 n = 0 时，长度为 2<sup>0</sup> = 1。
     因此，当 n = 0 时，其格雷编码序列为 [0]。

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    vector<int> grayCode(int n) {
        int len = 1 << n;
        vector<int> res;
        for(int i=0;i<len;i++)
        {
            int a = i^(i >> 1);
            res.push_back(a);
        }
        
        return res;
    }
};
```

## 累加数

[LeetCode链接](https://leetcode-cn.com/problems/additive-number/)

累加数是一个字符串，组成它的数字可以形成累加序列。

一个有效的累加序列必须**至少**包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。

给定一个只包含数字 `'0'-'9'` 的字符串，编写一个算法来判断给定输入是否是累加数。

**说明**: 累加序列里的数不会以 0 开头，所以不会出现 `1, 2, 03` 或者 `1, 02, 3` 的情况。

**示例 1**:
```
输入: "112358"
输出: true 
解释: 累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
```

**示例 2**:
```
输入: "199100199"
输出: true 
解释: 累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199
```

**进阶**:

你如何处理一个溢出的过大的整数输入?

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    bool inValid(const string& str)
    {
        if(str.size() == 1)
            return false;
        if(str.size() > 1)
        {
            if(str[0] == '0')
                return true;
        }
        
        return false;
    }
    
    long long Stol(string str)
    {
        long long res = 0;
        for(int i=0;i<str.size();i++)
        {
            res = 10*res + (str[i] - '0'); 
        }
        
        return res;
    }
    bool recursion(int idx,string& num,vector<long long>& res)
    {
        int len = num.size();
        if(idx == len && res.size() >= 3) return true;
        
        for(int i = idx;i < len && i - idx <= 9;i++)
        {
            string str = num.substr(idx,i-idx+1);
            if(inValid(str)) break;//01 02、、
            
            long long tmp = Stol(str);
            
            if(res.size() < 2) 
            {
                res.push_back(tmp);
                if(recursion(i+1,num,res))
                    return true;
                res.pop_back();
            }
            else{
                int len1 = res.size();
                if(tmp == res[len1-1] + res[len1-2])
                {
                    res.push_back(tmp);
                    if(recursion(i+1,num,res))
                        return true;
                    res.pop_back();
                }
            }
        }
        
        return false;
    }
    
    bool isAdditiveNumber(string num) {
        if(num.size() < 3) return false;
        
        vector<long long> res;
        return recursion(0,num,res);
    }
};
```

## 单词搜索II

[LeetCode链接](https://leetcode-cn.com/problems/word-search-ii/)

给定一个二维网格 `board` 和一个字典中的单词列表 `words`，找出所有同时在二维网格和字典中出现的单词。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

**示例**:
```
输入: 
words = ["oath","pea","eat","rain"] and board =
[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]

输出: ["eat","oath"]
```

**说明**:

你可以假设所有输入都由小写字母 `a-z` 组成。

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class node
{
public:
    node()
    {
        for(int i=0;i<26;i++)
            arr[i] = nullptr;
    }
    
    node* arr[26];
    string s;
};

class Trie
{
public:
    node* root;
    
    Trie()
    {
        root = nullptr;
    }
    
    void insert(const string& word)
    {
        if(word.empty()) return;
        if(!root) root = new node;
        auto temp = root;
        for(int i=0;i<word.size();i++)
        {
            char ch = word[i];
            int idx = ch - 'a';
            if(!temp->arr[idx])
                temp->arr[idx] = new node;
            
            temp = temp->arr[idx];
        }
        
        temp->s = word;
    }
    
    bool inTrie(const string& word)
    {
        auto temp = root;
        if(!root) return false;
        
        for(auto ch : word)
        {
            int idx = ch - 'a';
            if(temp->arr[idx])
            {
                temp = temp->arr[idx];
            }
            else
                return false;
        }
        
        return true;
    }
    
};


class Solution {
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        if(board.empty() || words.empty()) return vector<string>();
        
        vector<string> vec;
        Trie* tree = new Trie;
        for(auto word : words)
        {
            tree->insert(word);
        }
        
        
        int row = board.size();
        int col = board[0].size();
        vector<vector<bool>> vis(row,vector<bool>(col,false));
        
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
            {
                recursion(i,j,board,tree->root,vis,vec);
            }
        
        sort(vec.begin(),vec.end());
        return vec;
    }
    
    void recursion(int i,int j,vector<vector<char>>& board,node* tree,vector<vector<bool>>& vis,vector<string>& vec)
    {
        int row = board.size();
        int col = board[0].size();
        if(i < 0 || i >= row || j < 0 || j >= col || vis[i][j] || !tree->arr[board[i][j] - 'a'])
            return;
        
        int idx = board[i][j] - 'a';
        tree = tree->arr[idx];
        
        if( !(tree->s.empty()) )
        {
            vec.push_back(tree->s);
            tree->s.clear();
        }
        
        
        vis[i][j] = true;
        recursion(i-1,j,board,tree,vis,vec);
        recursion(i+1,j,board,tree,vis,vec);
        recursion(i,j-1,board,tree,vis,vec);
        recursion(i,j+1,board,tree,vis,vec);
        vis[i][j] = false;
    }
};
```
