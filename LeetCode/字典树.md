* **字典树总结**
   * [实现Trie(前缀树)](#实现Trie前缀树)
   * [键值映射](#键值映射)
   * [单词替换](#单词替换)
  
# 字典树总结
## 实现Trie(前缀树)

[LeetCode链接](https://leetcode-cn.com/problems/implement-trie-prefix-tree)

## 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
struct node
{
    int tail;
    node* next[26];
    
    node()
    {
        tail=0;
        for(int i=0;i<26;i++)
            next[i]=nullptr;
    }
};


class Trie {
public:
    /** Initialize your data structure here. */
    Trie() {
        root=nullptr;
    }
    
    /** Inserts a word into the trie. */
    void insert(string word) {
        if(word.empty())
            return;
        
        if(!root)
            root=new node();
        
        node* p=root;
        for(int i=0;i<word.size();i++)
        {
            int a=word[i]-'a';
            
            if(!p->next[a])
                p->next[a]=new node();
            p=p->next[a];
        }
        p->tail++;
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        if(word.empty())
            return false;
        
        if(!root)
            return false;
        
        node* p=root;
        for(int i=0;i<word.size();i++)
        {
            int a=word[i]-'a';
            if(!p->next[a])
                return false;
            p=p->next[a];
        }
        
        if(p->tail>0)
            return true;
        else
            return false;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        if(prefix.empty())
            return false;
        
        if(!root)
            return false;
        
        node* p=root;
        for(int i=0;i<prefix.size();i++)
        {
            int a=prefix[i]-'a';
            if(!p->next[a])
                return false;
            p=p->next[a];
        }
        
        return true;
    }
    
private:
    node* root;
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * bool param_2 = obj.search(word);
 * bool param_3 = obj.startsWith(prefix);
 */
```

## 键值映射

[LeetCode链接](https://leetcode-cn.com/problems/map-sum-pairs)

## 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
struct node
{
    bool tail;
    int val;
    node* next[26];
    node()
    {
        tail=false;
        val=0;
        for(int i=0;i<26;i++)
            next[i]=nullptr;
    }
    
};

void recursion(node* p,int& sum)
{
    if(p->tail)
    {
        sum+=p->val;
    }
        
    
    for(int i=0;i<26;i++)
    {
        if(p->next[i])
            recursion(p->next[i],sum);
    }
}

class MapSum {
public:
    /** Initialize your data structure here. */
    MapSum() {
        root=nullptr;
    }
    
    void insert(string key, int val) {
        if(key.empty())
            return;
        
        if(!root)
            root=new node();
        
        node* p=root;
        for(auto a:key)
        {
            int b=a - 'a';
            
            if(!p->next[b])
                p->next[b]=new node();
            
            p=p->next[b];
        }
        
        p->tail=true;
        p->val=val;
    }
    
    int sum(string prefix) {
        if(prefix.empty() || !root)
            return 0;
        
        node* p=root;
        for(auto a:prefix)
        {
            int b=a-'a';
            if(!p->next[b])
                return 0;
            
            p=p->next[b];
        }
        
        int sum=0;
        recursion(p,sum);
        
        return sum;
    }
    
private:
    node* root;
};

/**
 * Your MapSum object will be instantiated and called as such:
 * MapSum obj = new MapSum();
 * obj.insert(key,val);
 * int param_2 = obj.sum(prefix);
 */
```

## 单词替换

[LeetCode链接](https://leetcode-cn.com/problems/replace-words)

## 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
struct node
{
    bool tail;
    node* next[52];
    node()
    {
        tail=false;
        for(int i=0;i<52;i++)
            next[i]=nullptr;
    }
    
};

class Trie
{
public:
    Trie()
    {
        root=nullptr;
    }
    
    void insert(string word)
    {
        if(word.empty())
            return;
        
        if(!root)
            root=new node();
        
        node* p=root;
        for(int i=0;i<word.size();i++)
        {
            int a=word[i]-'a';
            
            if(!p->next[a])
                p->next[a]=new node();
            p=p->next[a];
        }
        
        p->tail=true;
    }
    
    void split(string& word)
    {
        int cnt=0;
        
        node* p=root;
        string res;
        for(auto s:word)
        {
            int a=s-'a';
            
            if(p && p->tail)
                break;
            if(p->next[a])
                p=p->next[a];
            else
                break;
            
            cnt++;
            
        }
        
        if(p && p->tail)
            word=word.substr(0,cnt);
    }
    
private:
    node* root;
    
};



class Solution {
public:
    string replaceWords(vector<string>& dict, string sentence) {
        Trie tr;
        for(auto a:dict)
            tr.insert(a);
        
        vector<string> res;
        string tmp("");
        for(auto s:sentence)
        {
            if(s!=' ')
                tmp+=s;
            else
            {
                res.push_back(tmp);
                tmp.clear();
            }
        }
        res.push_back(tmp);
        
        string out;
        for(auto w:res)
        {
            tr.split(w);
            out+=w+' ';
        }
        out.pop_back();
        
        return out;
    }
};
```

