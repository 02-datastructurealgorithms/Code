* **链表类总结**
   * [删除链表中的节点](#删除链表中的节点) (`easy`)
   * [反转链表](#反转链表) (`easy`)
   * [合并两个有序链表](#合并两个有序链表) (`easy`)
   * [删除排序链表中的重复元素](#删除排序链表中的重复元素) (`easy`)
   * [回文链表](#回文链表) (`easy`)
   * [环形链表](#环形链表) (`easy`)
   * [环形链表II](#环形链表II) (`medium`)
   * [相交链表](#相交链表) (`easy`)
   * [排序链表](#排序链表) (`medium`)
   * [奇偶链表](#奇偶链表) (`medium`)
   * [删除排序链表中的重复元素II](#删除排序链表中的重复元素II) (`medium`)
   * [旋转链表](#旋转链表) (`medium`)
   * [两数相加](#两数相加) (`medium`)
   * [删除链表的倒数第N个节点](#删除链表的倒数第N个节点) (`medium`)
   * [复制带随机指针的链表](#复制带随机指针的链表) (`medium`)
   * [合并K个排序链表](#合并K个排序链表) (`hard`)
   
   
   
# 链表类总结
## 删除链表中的节点
[LeetCode链接](https://leetcode-cn.com/problems/delete-node-in-a-linked-list)

**解答**：由于链表只能向后遍历，不能通过指向结点那个指针删除结点，但是可以通过与结点的下一个节点交换值，然后删除下一节点，就达到了要求

* c++代码

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node->val=node->next->val;
        node->next=node->next->next;
    }
};
```

## 反转链表
[LeetCode链接](https://leetcode-cn.com/problems/reverse-linked-list/)

**解答**：三指针法

* c++代码
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre=nullptr;
        ListNode* cur=head;
        ListNode* next=nullptr;
        while(cur)
        {
            next=cur->next;
            cur->next=pre;
            
            pre=cur;
            cur=next;
        }
        ListNode* res=pre;
        return res;
        
    }
};
```

## 合并两个有序链表
[LeetCode链接](https://leetcode-cn.com/problems/merge-two-sorted-lists)

* c++代码
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(!l1 && !l2) return nullptr;
        else if(!l1) return l2;
        else if(!l2) return l1;
        
        ListNode node(0),*head = &node;
        while(l1 && l2)
        {
            if(l1->val < l2->val)
            {
                head->next = l1;
                head = l1;
                l1 = l1->next;
            }
            else{
                head->next = l2;
                head = l2;
                l2 = l2->next;
            }
        }
        
        if(l1) head->next = l1;
        if(l2) head->next = l2;
        
        return node.next;
    }
};
```

## 删除排序链表中的重复元素
[LeetCode链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

**解答**：

* c++代码
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head)
            return nullptr;
        
        ListNode* pre=head;
        ListNode* cur=head->next;
        while(cur)
        {
            if(cur->val!=pre->val)
            {
                pre->next=cur;
                pre=pre->next;
            }
            cur=cur->next;
        }
        if(pre->next)
            pre->next=nullptr;
        
        return head;
    }
};
```c++

```

## 回文链表
[LeetCode链接](https://leetcode-cn.com/problems/palindrome-linked-list/)

* c++代码

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if(!head)
            return true;
        
        ListNode* slow = head;
        ListNode* fast = head;
        while(slow && fast->next && fast->next->next)
        {
            slow = slow->next;
            fast = fast->next->next;
        }
        
        ListNode* pre = nullptr;
        ListNode* cur = slow->next;
        ListNode* next = nullptr;
        while(cur)
        {
            next = cur->next;
            cur->next = pre;
            
            pre = cur;
            cur = next;
        }
        
        ListNode* head1 = pre;
        while(head1 && head)
        {
            if(head1->val != head->val)
                return false;
            
            head1 = head1->next;
            head = head->next;
        }
        
        return true;
    }
};
```

## 环形链表
[LeetCode链接](https://leetcode-cn.com/problems/linked-list-cycle/)

* c++代码

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(!head)
            return false;
     
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast && slow)
        {
            slow=slow->next;
            fast=fast->next;
            if(fast)
                fast=fast->next;
            else
                return false;
            
            if(slow==fast)
                return true;
        }
        
        return false;
        
    }
};
```

## 环形链表II
[LeetCode链接](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

* c++代码

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if(!head)
            return nullptr;
        
        ListNode* slow = head;
        ListNode* fast = head;
       
        while(slow && fast)
        {
            slow = slow->next;
            fast = fast->next;
            if(fast)
                fast = fast->next;
            else
                break;
            
            if(slow == fast)
                break;
        }
        
        if(!fast)
            return nullptr;
        
        slow = head;
        while(slow && fast && slow != fast)
        {
            slow = slow->next;
            fast = fast->next;
        }
        
        return slow;
    }
};
```

## 相交链表
[LeetCode链接](https://leetcode-cn.com/problems/intersection-of-two-linked-lists)

* c++代码

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(!headA || !headB)
            return nullptr;
        
        int lenA=0;
        int lenB=0;
        ListNode* p1=headA;
        ListNode* p2=headB;
        while(p1)
        {
            lenA++;
            p1=p1->next;
        }
        while(p2)
        {
            lenB++;
            p2=p2->next;
        }
        
        int k=lenA-lenB;
        int cnt=abs(k);
        if(k>0)
        {
            while(cnt>0)
            {
                headA=headA->next;
                cnt--;
            }
        }
        else
        {
            while(cnt>0)
            {
                headB=headB->next;
                cnt--;
            }
        }
        
        while(headA && headB)
        {
            if(headA->val==headB->val && headA==headB)
                return headA;
            
            headA=headA->next;
            headB=headB->next;
        }
        
        return nullptr;
    }
};
```

## 排序链表
[LeetCode链接](https://leetcode-cn.com/problems/sort-list)

* c++代码

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
         if(!head || !head->next)
            return head;
        
        ListNode *slow = head,*fast = head;
        while(fast && fast->next && fast->next->next)
        {
            slow = slow->next;
            fast = fast->next->next;
        }
        
        ListNode *p1 = head,*p2 = slow->next;
        slow->next = nullptr;
        
        p1 = sortList(p1);
        p2 = sortList(p2);
        
        ListNode node(0),*head1 = &node;
        while(p1 && p2)
        {
            if(p1->val < p2->val)
            {
                head1->next = p1;
                head1 = p1;
                p1 = p1->next;
            }
            else{
                head1->next = p2;
                head1 = p2;
                
                p2 = p2->next;
            }
        }
        
        if(p1)
            head1->next = p1;
        if(p2)
            head1->next = p2;
        
        return node.next;
    }
};
```

## 奇偶链表
[LeetCode链接](https://leetcode-cn.com/problems/odd-even-linked-list)

* c++代码

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(!head)
            return nullptr;
        
        ListNode head1(0),head2(0);//头结点
        ListNode* cur1 = &head1;
        ListNode* cur2 = &head2;
        ListNode* cur = head;
        int cnt = 0;
        while(cur)
        {
            if((cnt&0x1) == 0)
            {
                cur1->next = cur;
                cur1 = cur;
            }
            else{
                cur2->next = cur;
                cur2 = cur;
            }
            
            cnt++;
            cur = cur->next;
        }
        
        if(cur2) cur2->next = nullptr;
        cur1->next = head2.next;
        return head1.next;
        
        
    }
};
```

## 删除排序链表中的重复元素II
[LeetCode链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii)

* c++代码

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head)
            return nullptr;
        
        ListNode* p = head;
        if(p->next && p->val == p->next->val)
        {
            int tmp = p->val;
            while(p && p->val == tmp)
                p = p->next;
            
            return deleteDuplicates(p);
        }
        else{
            p->next = deleteDuplicates(p->next);
        }
        
        return p;
    }
};
```

## 旋转链表
[LeetCode链接](https://leetcode-cn.com/problems/rotate-list)

* c++代码

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head)
            return nullptr;
        
        int len = 0;
        ListNode* cur = head;
        while(cur)
        {
            len++;
            cur = cur->next;
        }
        
        int step = k%len;
        if(step == 0)
            return head;
        
        cur = head;
        int cnt = 1;
        while(cnt != len - step)
        {
            cur = cur->next;
            cnt++;
        }
        
        ListNode* head1 = cur->next;
        cur->next = nullptr;
        
        cur = head1;
        while(cur->next)
            cur = cur->next;
        
        cur->next = head;
        
        return head1;
    }
};
```

## 两数相加
[LeetCode链接](https://leetcode-cn.com/problems/add-two-numbers)

* c++代码

```c++

```

## 删除链表的倒数第N个节点
[LeetCode链接](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)

* python代码

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeNthFromEnd(self, head, n):
        """
        :type head: ListNode
        :type n: int
        :rtype: ListNode
        """
        if not head:
            return None
        
        l = 0
        p = head
        while p:
            p = p.next
            l += 1
        
        if l < n:
            return head
        if l == 1:
            return None
        
        """特殊情况：删除末尾元素"""
        if n == 1:
            p = head
            while p.next.next:
                p = p.next
            #p.val = p.next.val
            p.next = p.next.next
            return head
            
        p1 = p2 = head
        cnt = 1
        while p1.next and p2.next:
            if cnt >= n:
                p1 = p1.next
            cnt += 1
            p2 = p2.next
            
        #if not p1.next:
            #return None
        
        p1.val = p1.next.val
        p1.next = p1.next.next
        return head
```

## 复制带随机指针的链表
[LeetCode链接](https://leetcode-cn.com/problems/copy-list-with-random-pointer)

* c++代码

```c++
/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode *next, *random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    RandomListNode *copyRandomList(RandomListNode *head) {
        if(!head)
            return head;
        
        RandomListNode* cur=head;
        while(cur)
        {
            RandomListNode* node=new RandomListNode(cur->label);
            node->next=cur->next;
            cur->next=node;
            cur=node->next;
        }
        
        RandomListNode* cur1=head;
        while(cur1)
        {
            if(cur1->next && cur1->label==cur1->next->label)
            {
                if(cur1->random)
                    cur1->next->random=cur1->random->next;
            }
            cur1=cur1->next;
        }
        
        
        RandomListNode node(0),*head1 = &node;
        RandomListNode node1(0),*head2 = &node;
        RandomListNode* cur2 = head;
        //RandomListNode* start1=nullptr,*end1=nullptr;
        int cnt=0;
        while(cur2)
        {
            if((cnt&0x1)==1)
            {
                head1->next = cur2;
                head1 = cur2;
            }
            else{
                head2->next = cur2;
                head2 = cur2;
            }
            
            cnt++;
            cur2=cur2->next;
        }
        
        head1->next = nullptr;
        head2->next = nullptr;
        head = node1.next;
        return node.next;
    }
};
```

## 合并K个排序链表
[LeetCode链接](https://leetcode-cn.com/problems/merge-k-sorted-lists)

* c++代码

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

inline bool comp(const ListNode* p1,const ListNode* p2)
{
    return p1->val > p2->val;
}

class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.empty())
            return nullptr;
        
        vector<ListNode*> min;
        //priority_queue<ListNode*,vector<ListNode*>,decltype(comp)*> que(comp);
        for(auto p : lists)
        {
            if(p)
                min.push_back(p);
        }
        
        make_heap(min.begin(),min.end(),comp);
        
        ListNode head(0);
        ListNode* tail = &head;
        while(!min.empty())
        {
            auto cur = min.front();
            pop_heap(min.begin(),min.end(),comp);
            min.pop_back();
            
            tail->next = cur;
            tail = cur;
            
            if(cur->next)
            {
                //que.push(cur->next);
                min.push_back(cur->next);
                push_heap(min.begin(),min.end(),comp);
            }
        }
        
        
        return head.next;
    }
};
```
