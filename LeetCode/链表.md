* **链表类总结**
   * [删除链表中的节点](#删除链表中的节点) (`easy`)
   * [反转链表](#反转链表) (`easy`)
   * [合并两个有序链表](#合并两个有序链表) (`easy`)
   * [删除排序链表中的重复元素](#删除排序链表中的重复元素) (`easy`)
   * [回文链表](#回文链表) (`easy`)
   * [环形链表](#环形链表) (`easy`)
   * [环形链表II](#环形链表II) (`medium`)
   * [相交链表](#相交链表) (`easy`)
   * [排序链表](#排序链表) (`medium`)
   * [奇偶链表](#奇偶链表) (`medium`)
   * [删除排序链表中的重复元素II](#删除排序链表中的重复元素II) (`medium`)
   * [旋转链表](#旋转链表) (`medium`)
   * [两数相加](#两数相加) (`medium`)
   * [删除链表的倒数第N个节点](#删除链表的倒数第N个节点) (`medium`)
   * [复制带随机指针的链表](#复制带随机指针的链表) (`medium`)
   * [合并K个排序链表](#合并K个排序链表) (`hard`)
   
   
   
# 链表类总结
## 删除链表中的节点
[LeetCode链接](https://leetcode-cn.com/problems/delete-node-in-a-linked-list)

### 解答

由于链表只能向后遍历，不能通过指向结点那个指针删除结点，但是可以通过与结点的下一个节点交换值，然后删除下一节点，就达到了要求
* 时间复杂度O(1)


```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node->val=node->next->val;
        node->next=node->next->next;
    }
};
```

## 反转链表
[LeetCode链接](https://leetcode-cn.com/problems/reverse-linked-list/)

### 解答
#### 方法1：三指针法

设指针cur指向当前节点，反转指针的过程是改变当前节点的next指针指向当前节点前一个结点，所以同时需要保存前一个节点和下一个节点，设指针pre指向当前节点前一个节点，指针next指向当前节点下一个节点。cur指针最初指向链表首节点，next指向cur下一个节点，pre为空，改变当前节点的next结点指向pre指向的结点，每这样操作一次，三个指针同时前进，直到链表尾部为止。最后，返回反转后的链表表头指针。
* 时间复杂度O(n)
* 空间复杂度O(1)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre=nullptr;
        ListNode* cur=head;
        ListNode* next=nullptr;
        while(cur)
        {
            next=cur->next;
            cur->next=pre;
            
            pre=cur;
            cur=next;
        }
        
        return pre;
        
    }
};
```

#### 方法2：dummy结点

设一个dummy结点(`头结点`)，它的next指针始终指向链表首节点。设cur指针指向当前节点，temp作为临时指针指向当前节点的下一个节点。那么翻转的过程就是：

   1. 令cur->next指向temp指向节点的下一个节点(`cur->next = temp->next`)
   2. 令temp->next指向链表当前的首节点(`temp->next = dummy->next`)
   3. 令dummy->next指向temp指向的结点(`dummy->next = temp`)
   
重复这个过程，直到cur->next到达链表末尾为止，返回dummy->next就是反转后新链表的表头指针
* 时间复杂度O(n)
* 空间复杂度O(1)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head) return nullptr;
        
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* cur = head;
        while(cur->next)
        {
            ListNode* temp = cur->next;
            cur->next = temp->next;
            temp->next = dummy->next;
            dummy->next = temp;
        }
        
        return dummy->next;
    }
};
```

#### 方法3：递归

设第k+1层递归返回处理第k层结点k时，k以后的节点都已经反转。那么对于节点k，需要修改结点k+1的next指向节点，以及节点k的next指向节点

```c++
node(1) -> node(2) -> node(3) -> ... -> node(k) -> node(k+1) <- ... <- node(n-1) <- node(n)

node(k)->next->next = node(k);
node(k)->next = nullptr;
```

最后，返回第一层递归就是逆序后的链表的头结点

* 时间复杂度O(n)
* 空间复杂度O(n) (`由于n层递归，而每层递归函数调用的栈帧会创建局部指针tmp`)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head || !head->next) return head;
        
        ListNode* tmp = head;
        head = reverseList(tmp->next);
        
        tmp->next->next = tmp;
        tmp->next = nullptr;
        
        return head;
    }
};
```

## 合并两个有序链表
[LeetCode链接](https://leetcode-cn.com/problems/merge-two-sorted-lists)

### 解答

**双指针法**，维持两个指针l1,l2分别遍历两个链表，分两种情况处理：
1. l1->val < l2->val ，那么合并的下一个节点是l1，同时l1前进一个节点
2. l1->val >= l2->val , 那么合并的下一个节点时l2，同时l2前进一个节点

直到l1和l2有一个到达链表尾结束遍历，如果两个链表不等长，那此时肯定有一个链表没走完，将这个链表剩下没走完的那部分加到合并的新链表尾部即可

* 时间复杂度O(m+n)
* 空间复杂度O(1)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(!l1 && !l2) return nullptr;
        else if(!l1) return l2;
        else if(!l2) return l1;
        
        ListNode node(0),*head = &node;
        while(l1 && l2)
        {
            if(l1->val < l2->val)
            {
                head->next = l1;
                head = l1;
                l1 = l1->next;
            }
            else{
                head->next = l2;
                head = l2;
                l2 = l2->next;
            }
        }
        
        if(l1) head->next = l1;
        if(l2) head->next = l2;
        
        return node.next;
    }
};
```

## 删除排序链表中的重复元素
[LeetCode链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

### 解答

双指针法：设置两个指针cur和pre遍历链表，cur指向当前节点，pre指向当前节点前一个节点，比较pre->val和cur->val的值，
1. pre->val != cur->val，此时cur指向下一个不重复的节点，令pre的next指向cur指向的当前节点，这样就跳过了重复的节点，同时pre前进一步(`pre = pre->next`);
2. pre->val == cur->val, 此时cur仍然指向重复的节点，cur继续前进直到找到不重复的节点

* 时间复杂度O(n)
* 空间复杂度O(1)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head)
            return nullptr;
        
        ListNode* pre=head;
        ListNode* cur=head->next;
        while(cur)
        {
            if(cur->val!=pre->val)
            {
                pre->next=cur;
                pre=pre->next;
            }
            cur=cur->next;
        }
        if(pre->next)
            pre->next=nullptr;
        
        return head;
    }
};
```

## 回文链表
[LeetCode链接](https://leetcode-cn.com/problems/palindrome-linked-list/)

### 解答

思路：要判断链表是否回文，可以分别从头和尾同时往中间遍历元素，比较遍历到的每个元素是否相等，直到链表中间。但是链表不同于数组，遍历只能从前往后而不能从后往前，所以需要调整链表，将链表的后半部分反转。
1. 设两个指针遍历链表，一个快指针fast，一个慢指针slow，快指针一步走两个结点，慢指针一步走一个节点，直到快指针到达链表尾，此时慢指针到达链表的中间。
2. 反转以slow指向的这个中间节点开始到链表尾之间的节点，详见[反转链表](#反转链表)。
3. 接下来设置两个指针head和head1，从链表的头和尾同时向中间遍历，如果遍历的过程中出现head->val != head1->val，那么原链表就不是回文；否则，是回文。

* 时间复杂度O(n)
* 空间复杂度O(1)


```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if(!head)
            return true;
        
        ListNode* slow = head;
        ListNode* fast = head;
        while(slow && fast->next && fast->next->next)
        {
            slow = slow->next;
            fast = fast->next->next;
        }
        
        ListNode* pre = nullptr;
        ListNode* cur = slow->next;
        ListNode* next = nullptr;
        while(cur)
        {
            next = cur->next;
            cur->next = pre;
            
            pre = cur;
            cur = next;
        }
        
        ListNode* head1 = pre;
        while(head1 && head)
        {
            if(head1->val != head->val)
                return false;
            
            head1 = head1->next;
            head = head->next;
        }
        
        return true;
    }
};
```

## 环形链表
[LeetCode链接](https://leetcode-cn.com/problems/linked-list-cycle/)

### 解答

使用一个快指针和一个慢指针，快指针走两步，慢指针走一步。如果链表有环，两个指针一定会相遇，并且相遇的节点与头结点到环结点的距离相等；如果链表没有环，快指针会先到达链表尾。
* 时间复杂度O(n)
* 空间复杂度O(1)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(!head)
            return false;
     
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast && slow)
        {
            slow=slow->next;
            fast=fast->next;
            if(fast)
                fast=fast->next;
            else
                return false;
            
            if(slow==fast)
                return true;
        }
        
        return false;
        
    }
};
```

## 环形链表II
[LeetCode链接](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

### 解答

方法详见[环形链表](#环形链表)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if(!head)
            return nullptr;
        
        ListNode* slow = head;
        ListNode* fast = head;
       
        while(slow && fast)
        {
            slow = slow->next;
            fast = fast->next;
            if(fast)
                fast = fast->next;
            else
                break;
            
            if(slow == fast)
                break;
        }
        
        if(!fast)
            return nullptr;
        
        slow = head;
        while(slow && fast && slow != fast)
        {
            slow = slow->next;
            fast = fast->next;
        }
        
        return slow;
    }
};
```

## 相交链表
[LeetCode链接](https://leetcode-cn.com/problems/intersection-of-two-linked-lists)

### 解答

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(!headA || !headB)
            return nullptr;
        
        int lenA=0;
        int lenB=0;
        ListNode* p1=headA;
        ListNode* p2=headB;
        while(p1)
        {
            lenA++;
            p1=p1->next;
        }
        while(p2)
        {
            lenB++;
            p2=p2->next;
        }
        
        int k=lenA-lenB;
        int cnt=abs(k);
        if(k>0)
        {
            while(cnt>0)
            {
                headA=headA->next;
                cnt--;
            }
        }
        else
        {
            while(cnt>0)
            {
                headB=headB->next;
                cnt--;
            }
        }
        
        while(headA && headB)
        {
            if(headA->val==headB->val && headA==headB)
                return headA;
            
            headA=headA->next;
            headB=headB->next;
        }
        
        return nullptr;
    }
};
```

## 排序链表
[LeetCode链接](https://leetcode-cn.com/problems/sort-list)

### 解答

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
         if(!head || !head->next)
            return head;
        
        ListNode *slow = head,*fast = head;
        while(fast && fast->next && fast->next->next)
        {
            slow = slow->next;
            fast = fast->next->next;
        }
        
        ListNode *p1 = head,*p2 = slow->next;
        slow->next = nullptr;
        
        p1 = sortList(p1);
        p2 = sortList(p2);
        
        ListNode node(0),*head1 = &node;
        while(p1 && p2)
        {
            if(p1->val < p2->val)
            {
                head1->next = p1;
                head1 = p1;
                p1 = p1->next;
            }
            else{
                head1->next = p2;
                head1 = p2;
                
                p2 = p2->next;
            }
        }
        
        if(p1)
            head1->next = p1;
        if(p2)
            head1->next = p2;
        
        return node.next;
    }
};
```

## 奇偶链表
[LeetCode链接](https://leetcode-cn.com/problems/odd-even-linked-list)

### 解答

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(!head)
            return nullptr;
        
        ListNode head1(0),head2(0);//头结点
        ListNode* cur1 = &head1;
        ListNode* cur2 = &head2;
        ListNode* cur = head;
        int cnt = 0;
        while(cur)
        {
            if((cnt&0x1) == 0)
            {
                cur1->next = cur;
                cur1 = cur;
            }
            else{
                cur2->next = cur;
                cur2 = cur;
            }
            
            cnt++;
            cur = cur->next;
        }
        
        if(cur2) cur2->next = nullptr;
        cur1->next = head2.next;
        return head1.next;
        
        
    }
};
```

## 删除排序链表中的重复元素II
[LeetCode链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii)

### 解答

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head)
            return nullptr;
        
        ListNode* p = head;
        if(p->next && p->val == p->next->val)
        {
            int tmp = p->val;
            while(p && p->val == tmp)
                p = p->next;
            
            return deleteDuplicates(p);
        }
        else{
            p->next = deleteDuplicates(p->next);
        }
        
        return p;
    }
};
```

## 旋转链表
[LeetCode链接](https://leetcode-cn.com/problems/rotate-list)

### 解答

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head)
            return nullptr;
        
        int len = 0;
        ListNode* cur = head;
        while(cur)
        {
            len++;
            cur = cur->next;
        }
        
        int step = k%len;
        if(step == 0)
            return head;
        
        cur = head;
        int cnt = 1;
        while(cnt != len - step)
        {
            cur = cur->next;
            cnt++;
        }
        
        ListNode* head1 = cur->next;
        cur->next = nullptr;
        
        cur = head1;
        while(cur->next)
            cur = cur->next;
        
        cur->next = head;
        
        return head1;
    }
};
```

## 两数相加
[LeetCode链接](https://leetcode-cn.com/problems/add-two-numbers)

### 解答

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* recursion(ListNode* root1,ListNode* root2,int inc)
    {
        //int inc1=0;
        ListNode* res=new ListNode(0);
        if(!root1 && !root2)
        {
            if(inc==0)
                return nullptr;
            else
            {
                res->val=inc;
                res->next=nullptr;
            }
        }
        else if(root1 && root2)
        {
            int sum=root1->val+root2->val+inc;
            int a=sum/10;
            int b=sum%10;
            res->val=b;
            res->next=recursion(root1->next,root2->next,a);
        }
        else{
            ListNode* cur = root1 ? root1 : root2;
            int sum=cur->val + inc;
            int a=sum/10;
            int b=sum%10;
            res->val=b;
            if(a==0)
           {
              res->next=cur->next;
           }
           else{
              res->next=recursion(cur->next,nullptr,a);
           }
        }
        
            
        
        return res;
        
    }
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        if(!l1 && !l2)
            return nullptr;
        if(!l1 && l2)
            return l2;
        if(l1 && !l2)
            return l1;
        
        return recursion(l1,l2,false);
        
    }
};
```

## 删除链表的倒数第N个节点
[LeetCode链接](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)

### 解答

* python代码

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeNthFromEnd(self, head, n):
        """
        :type head: ListNode
        :type n: int
        :rtype: ListNode
        """
        if not head:
            return None
        
        l = 0
        p = head
        while p:
            p = p.next
            l += 1
        
        if l < n:
            return head
        if l == 1:
            return None
        
        """特殊情况：删除末尾元素"""
        if n == 1:
            p = head
            while p.next.next:
                p = p.next
            #p.val = p.next.val
            p.next = p.next.next
            return head
            
        p1 = p2 = head
        cnt = 1
        while p1.next and p2.next:
            if cnt >= n:
                p1 = p1.next
            cnt += 1
            p2 = p2.next
            
        #if not p1.next:
            #return None
        
        p1.val = p1.next.val
        p1.next = p1.next.next
        return head
```

## 复制带随机指针的链表
[LeetCode链接](https://leetcode-cn.com/problems/copy-list-with-random-pointer)

### 解答

```c++
/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode *next, *random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    RandomListNode *copyRandomList(RandomListNode *head) {
        if(!head)
            return head;
        
        RandomListNode* cur=head;
        while(cur)
        {
            RandomListNode* node=new RandomListNode(cur->label);
            node->next=cur->next;
            cur->next=node;
            cur=node->next;
        }
        
        RandomListNode* cur1=head;
        while(cur1)
        {
            if(cur1->next && cur1->label==cur1->next->label)
            {
                if(cur1->random)
                    cur1->next->random=cur1->random->next;
            }
            cur1=cur1->next;
        }
        
        
        RandomListNode node(0),*head1 = &node;
        RandomListNode node1(0),*head2 = &node;
        RandomListNode* cur2 = head;
        //RandomListNode* start1=nullptr,*end1=nullptr;
        int cnt=0;
        while(cur2)
        {
            if((cnt&0x1)==1)
            {
                head1->next = cur2;
                head1 = cur2;
            }
            else{
                head2->next = cur2;
                head2 = cur2;
            }
            
            cnt++;
            cur2=cur2->next;
        }
        
        head1->next = nullptr;
        head2->next = nullptr;
        head = node1.next;
        return node.next;
    }
};
```

## 合并K个排序链表
[LeetCode链接](https://leetcode-cn.com/problems/merge-k-sorted-lists)

### 解答

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

inline bool comp(const ListNode* p1,const ListNode* p2)
{
    return p1->val > p2->val;
}

class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.empty())
            return nullptr;
        
        vector<ListNode*> min;
        //priority_queue<ListNode*,vector<ListNode*>,decltype(comp)*> que(comp);
        for(auto p : lists)
        {
            if(p)
                min.push_back(p);
        }
        
        make_heap(min.begin(),min.end(),comp);
        
        ListNode head(0);
        ListNode* tail = &head;
        while(!min.empty())
        {
            auto cur = min.front();
            pop_heap(min.begin(),min.end(),comp);
            min.pop_back();
            
            tail->next = cur;
            tail = cur;
            
            if(cur->next)
            {
                //que.push(cur->next);
                min.push_back(cur->next);
                push_heap(min.begin(),min.end(),comp);
            }
        }
        
        
        return head.next;
    }
};
```
