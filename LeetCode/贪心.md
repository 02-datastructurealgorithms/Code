* **贪心总结**
   * [买卖股票的最佳时机II](#买卖股票的最佳时机II)
   * [柠檬水找零](#柠檬水找零)
   * [分发饼干](分发饼干)
   * [判断子序列](#判断子序列)
   * [任务调度器](#任务调度器)
   * [分割数组为连续子序列](#分割数组为连续子序列)
   * [摆动序列](#摆动序列)
   * [跳跃游戏](#跳跃游戏)
   * [将数组拆分成斐波那契序列](将数组拆分成斐波那契序列)
   
   
# 贪心总结
## 买卖股票的最佳时机II
[LeetCode链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        
        int res = 0;
        for(int i=1;i<prices.size();i++){
            if(prices[i] > prices[i-1])
                res += prices[i] - prices[i-1];
        }
        
        return res;
    }
};
```

## 柠檬水找零
[LeetCode链接](https://leetcode-cn.com/problems/lemonade-change)

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int cnt_5 = 0,cnt_10 = 0,cnt_20 = 0;
        int len = bills.size();
        if(len == 0) return false;
        if(bills[0] != 5) return false;
        for(int i = 0;i < len;i++)
        {
            if(bills[i] == 5)
                ++cnt_5;
            else if(bills[i] == 10)
            {
                --cnt_5;
                if(cnt_5 < 0) return false;
                ++cnt_10;
            }
            else if(bills[i] == 20)
            {
                if(cnt_10 > 0)
                {
                    --cnt_10;
                    --cnt_5;
                    if(cnt_5 < 0) return false;
                }
                else if(cnt_10 == 0) 
                {
                    cnt_5 -= 3;
                    if(cnt_5 < 0) return false;
                }
                
                ++cnt_20;
            }
        }
        
        return true;
    }
};
```

## 分发饼干
[LeetCode链接](https://leetcode-cn.com/problems/assign-cookies)

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        if(g.empty() || s.empty()) return 0;
        
        make_heap(g.begin(),g.end(),greater<int>());
        make_heap(s.begin(),s.end(),greater<int>());
        int res = 0;
        while(!s.empty() && !g.empty())
        {
            int g0 = g.front();
            int s0 = s.front();
            if(g0 <= s0)
            {
                ++res;
                
                pop_heap(g.begin(),g.end(),greater<int>());
                g.pop_back();
            }
            
             pop_heap(s.begin(),s.end(),greater<int>());
             s.pop_back();
            
        }
        
        return res;
    }
};
```

# 判断子序列
[LeetCode链接](https://leetcode-cn.com/problems/is-subsequence)

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

# 任务调度器
[LeetCode链接](https://leetcode-cn.com/problems/task-scheduler)

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
inline bool comp(const pair<char,int>& pr1,const pair<char,int>& pr2)
     {
         return pr1.second < pr2.second;
     }

class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        vector<int> cnt(26,0);
        for(char ch : tasks)
            cnt[ch-'A']++;
        
        sort(cnt.begin(),cnt.end());
        auto iter = cnt.rbegin();
        int Max = *iter;
        int ct = 0;
        for(auto it = cnt.rbegin();it != cnt.rend() && (*it) == Max;it++)
        {
            ct++;
        }
        
        int res = (Max - 1)*(n + 1) + ct;
        int len = tasks.size();
        return max(len,res);
    }
};
```

# 分割数组为连续子序列
[LeetCode链接](https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences)

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    bool isPossible(vector<int>& nums) {
        unordered_map<int,int> mp,need;
        for(auto a:nums) 
            mp[a]++;
        
        for(auto num:nums)
        {
            if(mp[num] == 0) continue;
            else if(need[num] > 0)
            {
                need[num]--;
                need[num+1]++;
            }
            else if(mp[num+1] > 0 && mp[num+2] > 0)
            {
                mp[num+1]--;
                mp[num+2]--;
                need[num+3]++;
            }
            else
                return false;
            
            mp[num]--;
        }
        
        return true;
    }
};
```

# 跳跃游戏
[LeetCode链接](https://leetcode-cn.com/problems/jump-game)

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int len=nums.size();
        if(len==0)
            return false;
        
        vector<bool> dp(len,false);
        dp[0]=true;
        for(int i=1;i<len;i++)
        {
            for(int j=i-1;j>=0;j--)
            {
                if(dp[j])
               {
                if(nums[j]>=i-j)
                {
                    dp[i]=true;
                    break;
                }
               }
            }
        }
        
        return dp[len-1];
    }
};
```

# 摆动序列
[LeetCode链接](https://leetcode-cn.com/problems/wiggle-subsequence)

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if(nums.empty()) return 0;
        
        vector<int> dp1(nums.size(), 1);
        vector<int> dp2(nums.size(), 1);
        for(int i = 1; i < nums.size();i++) 
        {
            for (int j = 0; j < i; j++) 
            {
                if (nums[i] > nums[j]) dp1[i] = max(dp1[i], dp2[j] + 1);
                else if (nums[i] < nums[j]) dp2[i] = max(dp2[i], dp1[j] + 1);
            }
        }
        
        return max(dp1.back(), dp2.back());
    }
};
```

# 将数组拆分成斐波那契序列
[LeetCode链接](https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence)

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    long long Stol(const string& str)
    {
        long long res = 0;
        for(int i=0;i<str.size();i++)
        {
            res = res*10 + (str[i] - '0');
        }
        
        return res;
    }
    
    bool inValid(const string& str)
    {
        if(str.size() > 1 && str[0] == '0')
        {
            return true;
        }
        
        return false;
    }
    
    bool recursion(int idx,string& S,vector<int>& res)
    {
        if(idx == S.size() && res.size() >= 3)
            return true;
        
        for(int i=idx;i<S.size() && i-idx <= 9;i++)
        {
            string str = S.substr(idx,i-idx+1);
            if(inValid(str)) break;
            
            long long tmp = Stol(str);
            if(tmp > INT_MAX) break;
            
            if(res.size() < 2)
            {
                res.push_back((int)tmp);
                if(recursion(i+1,S,res)) return true;
                res.pop_back();
            }
            else{
                int len = res.size();
                if(tmp == res[len-1] + res[len-2])
                {
                    res.push_back((int)tmp);
                    if(recursion(i+1,S,res)) return true;
                    res.pop_back();
                }
            }
            
            
        }
        
        return false;
    }
    
    vector<int> splitIntoFibonacci(string S) {
        vector<int> res;
        if(S.size() < 3) return res;
        
        if(recursion(0,S,res))
            return res;
        
        return res;
    }
};
```
