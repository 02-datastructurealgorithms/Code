* **贪心总结**
   * [买卖股票的最佳时机II](#买卖股票的最佳时机II)
   * [柠檬水找零](#柠檬水找零)
   * [分发饼干](#分发饼干)
   * [任务调度器](#任务调度器)
   * [分割数组为连续子序列](#分割数组为连续子序列)
   * [跳跃游戏](#跳跃游戏)
   * [将数组拆分成斐波那契序列](#将数组拆分成斐波那契序列)
   
   
# 贪心总结
## 买卖股票的最佳时机II
[LeetCode链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意**：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1**:
```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2**:
```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3**:
```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        
        int res = 0;
        for(int i=1;i<prices.size();i++){
            if(prices[i] > prices[i-1])
                res += prices[i] - prices[i-1];
        }
        
        return res;
    }
};
```

## 柠檬水找零
[LeetCode链接](https://leetcode-cn.com/problems/lemonade-change)

在柠檬水摊上，每一杯柠檬水的售价为 5 美元。

顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。

**示例 1**：
```
输入：[5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。
```

**示例 2**：
```
输入：[5,5,10]
输出：true
```

**示例 3**：
```
输入：[10,10]
输出：false
```

**示例 4**：
```
输入：[5,5,10,10,20]
输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。
```

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int cnt_5 = 0,cnt_10 = 0,cnt_20 = 0;
        int len = bills.size();
        if(len == 0) return false;
        if(bills[0] != 5) return false;
        for(int i = 0;i < len;i++)
        {
            if(bills[i] == 5)
                ++cnt_5;
            else if(bills[i] == 10)
            {
                --cnt_5;
                if(cnt_5 < 0) return false;
                ++cnt_10;
            }
            else if(bills[i] == 20)
            {
                if(cnt_10 > 0)
                {
                    --cnt_10;
                    --cnt_5;
                    if(cnt_5 < 0) return false;
                }
                else if(cnt_10 == 0) 
                {
                    cnt_5 -= 3;
                    if(cnt_5 < 0) return false;
                }
                
                ++cnt_20;
            }
        }
        
        return true;
    }
};
```

## 分发饼干
[LeetCode链接](https://leetcode-cn.com/problems/assign-cookies)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 g<sub>i</sub> ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 s<sub>j</sub> 。如果 s<sub>j</sub> >= g<sub>i</sub> ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**注意**：

你可以假设胃口值为正。
一个小朋友最多只能拥有一块饼干。

**示例 1**:
```
输入: [1,2,3], [1,1]

输出: 1

解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

**示例 2**:
```
输入: [1,2], [1,2,3]

输出: 2

解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        if(g.empty() || s.empty()) return 0;
        
        make_heap(g.begin(),g.end(),greater<int>());
        make_heap(s.begin(),s.end(),greater<int>());
        int res = 0;
        while(!s.empty() && !g.empty())
        {
            int g0 = g.front();
            int s0 = s.front();
            if(g0 <= s0)
            {
                ++res;
                
                pop_heap(g.begin(),g.end(),greater<int>());
                g.pop_back();
            }
            
             pop_heap(s.begin(),s.end(),greater<int>());
             s.pop_back();
            
        }
        
        return res;
    }
};
```


# 任务调度器
[LeetCode链接](https://leetcode-cn.com/problems/task-scheduler)

给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。

然而，两个**相同种类**的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的**最短时间**。

示例 1：
```
输入: tasks = ["A","A","A","B","B","B"], n = 2
输出: 8
执行顺序: A -> B -> (待命) -> A -> B -> (待命) -> A -> B.
```

**注：**

1. 任务的总个数为 `[1, 10000]`。
2. n 的取值范围为 `[0, 100]`。

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
inline bool comp(const pair<char,int>& pr1,const pair<char,int>& pr2)
     {
         return pr1.second < pr2.second;
     }

class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        vector<int> cnt(26,0);
        for(char ch : tasks)
            cnt[ch-'A']++;
        
        sort(cnt.begin(),cnt.end());
        auto iter = cnt.rbegin();
        int Max = *iter;
        int ct = 0;
        for(auto it = cnt.rbegin();it != cnt.rend() && (*it) == Max;it++)
        {
            ct++;
        }
        
        int res = (Max - 1)*(n + 1) + ct;
        int len = tasks.size();
        return max(len,res);
    }
};
```

# 分割数组为连续子序列
[LeetCode链接](https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences)

输入一个按升序排序的整数数组（可能包含重复数字），你需要将它们分割成几个子序列，其中每个子序列至少包含三个连续整数。返回你是否能做出这样的分割？

**示例 1**：
```
输入: [1,2,3,3,4,5]
输出: True
解释:
你可以分割出这样两个连续子序列 : 
1, 2, 3
3, 4, 5
```

**示例 2**：
```
输入: [1,2,3,3,4,4,5,5]
输出: True
解释:
你可以分割出这样两个连续子序列 : 
1, 2, 3, 4, 5
3, 4, 5
```

**示例 3**：
```
输入: [1,2,3,4,4,5]
输出: False
```

**提示**：

* 输入的数组长度范围为 `[1, 10000]`

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    bool isPossible(vector<int>& nums) {
        unordered_map<int,int> mp,need;
        for(auto a:nums) 
            mp[a]++;
        
        for(auto num:nums)
        {
            if(mp[num] == 0) continue;
            else if(need[num] > 0)
            {
                need[num]--;
                need[num+1]++;
            }
            else if(mp[num+1] > 0 && mp[num+2] > 0)
            {
                mp[num+1]--;
                mp[num+2]--;
                need[num+3]++;
            }
            else
                return false;
            
            mp[num]--;
        }
        
        return true;
    }
};
```

# 跳跃游戏
[LeetCode链接](https://leetcode-cn.com/problems/jump-game)

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

**示例 1**:
```
输入: [2,3,1,1,4]
输出: true
解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。
```

**示例 2**:
```
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
```

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int len=nums.size();
        if(len==0)
            return false;
        
        vector<bool> dp(len,false);
        dp[0]=true;
        for(int i=1;i<len;i++)
        {
            for(int j=i-1;j>=0;j--)
            {
                if(dp[j])
               {
                if(nums[j]>=i-j)
                {
                    dp[i]=true;
                    break;
                }
               }
            }
        }
        
        return dp[len-1];
    }
};
```


# 将数组拆分成斐波那契序列
[LeetCode链接](https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence)

定一个数字字符串 `S`，比如 `S = "123456579"`，我们可以将它分成斐波那契式的序列 `[123, 456, 579]`。

形式上，斐波那契式序列是一个非负整数列表 `F`，且满足：

* `0 <= F[i] <= 2^31 - 1`，（也就是说，每个整数都符合 32 位有符号整数类型）；
* `F.length >= 3`；
* 对于所有的`0 <= i < F.length - 2`，都有 `F[i] + F[i+1] = F[i+2]` 成立。

另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。

返回从 `S` 拆分出来的所有斐波那契式的序列块，如果不能拆分则返回 `[]`。

**示例 1**：
```
输入："123456579"
输出：[123,456,579]
```

**示例 2**：
```
输入: "11235813"
输出: [1,1,2,3,5,8,13]
```

**示例 3**：
```
输入: "112358130"
输出: []
解释: 这项任务无法完成。
```

**示例 4**：
```
输入："0123"
输出：[]
解释：每个块的数字不能以零开头，因此 "01"，"2"，"3" 不是有效答案。
```

**示例 5**：
```
输入: "1101111"
输出: [110, 1, 111]
解释: 输出 [11,0,11,11] 也同样被接受。
```

**提示**：

1. `1 <= S.length <= 200`
2. 字符串 S 中只含有数字。

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    long long Stol(const string& str)
    {
        long long res = 0;
        for(int i=0;i<str.size();i++)
        {
            res = res*10 + (str[i] - '0');
        }
        
        return res;
    }
    
    bool inValid(const string& str)
    {
        if(str.size() > 1 && str[0] == '0')
        {
            return true;
        }
        
        return false;
    }
    
    bool recursion(int idx,string& S,vector<int>& res)
    {
        if(idx == S.size() && res.size() >= 3)
            return true;
        
        for(int i=idx;i<S.size() && i-idx <= 9;i++)
        {
            string str = S.substr(idx,i-idx+1);
            if(inValid(str)) break;
            
            long long tmp = Stol(str);
            if(tmp > INT_MAX) break;
            
            if(res.size() < 2)
            {
                res.push_back((int)tmp);
                if(recursion(i+1,S,res)) return true;
                res.pop_back();
            }
            else{
                int len = res.size();
                if(tmp == res[len-1] + res[len-2])
                {
                    res.push_back((int)tmp);
                    if(recursion(i+1,S,res)) return true;
                    res.pop_back();
                }
            }
            
            
        }
        
        return false;
    }
    
    vector<int> splitIntoFibonacci(string S) {
        vector<int> res;
        if(S.size() < 3) return res;
        
        if(recursion(0,S,res))
            return res;
        
        return res;
    }
};
```
