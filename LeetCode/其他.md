* **其他类总结**

   * [Nim游戏](#Nim游戏) (`easy` `智力题`)

   * [第一个错误的版本](#第一个错误的版本) (`easy` `二分查找`)
   * [四数相加II](#四数相加II) (`medium ` `哈希`)
   * [搜索二维矩阵II](#搜索二维矩阵II) (`medium` `二分查找`)
   * [有效的数独](#有效的数独) (`medium` `哈希`)

# 其他类总结

## Nim游戏

[LeetCode链接](https://leetcode-cn.com/problems/nim-game/)

你和你的朋友，两个人一起玩 [Nim游戏](https://baike.baidu.com/item/Nim%E6%B8%B8%E6%88%8F/6737105)：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。

你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。

**示例:**

```
输入: 4
输出: false 
解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；
     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。
```

### 解答



* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    bool canWinNim(int n) {
        return (n%4 != 0);
    }
};
```



## 第一个错误的版本

[LeetCode链接](https://leetcode-cn.com/problems/first-bad-version/)

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 `n` 个版本 `[1, 2, ..., n]`，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 `bool isBadVersion(version)` 接口来判断版本号 `version` 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

**示例:**

```
给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -> false
调用 isBadVersion(5) -> true
调用 isBadVersion(4) -> true

所以，4 是第一个错误的版本。 
```

### 解答



* 时间复杂度O()
* 空间复杂度O()

```c++
// Forward declaration of isBadVersion API.
bool isBadVersion(int version);

class Solution {
public:
    int BinarySearch(int l,int r)
    {
        if(l==r)
            return l;
        int m=l+(r-l)/2;
        if(isBadVersion(m))
            return BinarySearch(l,m);
        else
            return BinarySearch(m+1,r);
    }
    int firstBadVersion(int n) {
        return BinarySearch(1,n);
    }
};
```



## 四数相加II

[LeetCode链接](https://leetcode-cn.com/problems/4sum-ii/)

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 `(i, j, k, l)` ，使得 `A[i] + B[j] + C[k] + D[l] = 0`。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2<sup>28</sup> 到 2<sup>28</sup> - 1 之间，最终结果不会超过 2<sup>31</sup> - 1 。

**例如:**

```
输入:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

输出:
2

解释:
两个元组如下:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
```

### 解答



- 时间复杂度O()
- 空间复杂度O()

```c++
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        unordered_map<int,int> mp;
        for(auto a:A)
        {
            for(auto b:B)
            {
                mp[a+b]++;
            }
        }
        
        int cnt = 0;
        for(auto c:C)
        {
            for(auto d:D)
            {
                if(mp.find(-c-d) != mp.end())
                    cnt += mp[-c-d];
            }
        }
        
        return cnt;
    }
};
```

## 搜索二维矩阵II

[LeetCode链接](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

编写一个高效的算法来搜索 *m* x *n* 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

**示例:**

现有矩阵 matrix 如下：

```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```

给定 target = `5`，返回 `true`。

给定 target = `20`，返回 `false`。

### 解答



- 时间复杂度O()
- 空间复杂度O()



```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if(matrix.empty())
            return false;
        
        int row=matrix.size();
        int col=matrix[0].size();
        int i=0;
        int j=col-1;
        while(i<row && j>=0)
        {
            if(target>matrix[i][j])
            {
                i++;
            }
            else if(target<matrix[i][j])
            {
                j--;
            }
            else
                return true;
        }
        
        return false;
    }
};
```

## 有效的数独

[LeetCode链接](https://leetcode-cn.com/problems/valid-sudoku/)

判断一个 9x9 的数独是否有效。只需要**根据以下规则**，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

**示例 1:**

```
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
```

**示例 2:**

```
输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

**说明:**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 给定数独序列只包含数字 `1-9` 和字符 `'.'` 。
- 给定数独永远是 `9x9` 形式的。

### 解答



* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        unordered_map<char,int> mp;
        int row=board.size();
        int col=board[0].size();
        
        for(int i=0;i<row;i++)
        {
            for(int j=0;j<col;j++)
            {
                int ch=board[i][j];
                if(ch!='.')
                {
                    mp[ch]++;
                    if(mp[ch]>1)
                        return false;
                }
                
            }
            mp.clear();
        }
        
        for(int i=0;i<col;i++)
        {
            for(int j=0;j<row;j++)
            {
                char ch=board[j][i];
                if(ch!='.')
                {
                    mp[ch]++;
                    if(mp[ch]>1)
                        return false;
                }
            }
            mp.clear();
        }
        
        for(int i=0;i<row;i+=3)
        {
            for(int j=0;j<col;j+=3)
            {
                for(int x=i;x<i+3;x++)
                    for(int y=j;y<j+3;y++)
                    {
                        char ch=board[x][y];
                        if(ch!='.')
                        {
                            mp[ch]++;
                            if(mp[ch]>1)
                                return false;
                        }
                    }
                mp.clear();
            }
        }
        
        return true;
            
    }
};
```

