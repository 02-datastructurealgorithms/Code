* **其他类总结**
   * [Nim游戏](#Nim游戏) (`easy` `智力题`)
   * [Fizz Buzz](#Fizz Buzz) (`easy`)
   * [四数相加II](#四数相加II) (`medium ` `哈希`)
   * [有效的数独](#有效的数独) (`medium` `哈希`)
   * [打乱数组](#打乱数组) (`mqdium` `洗牌算法`)
   * [递增的三元子序列](#递增的三元子序列) (`medium`)

# 其他类总结

## Nim游戏

[LeetCode链接](https://leetcode-cn.com/problems/nim-game/)

你和你的朋友，两个人一起玩 [Nim游戏](https://baike.baidu.com/item/Nim%E6%B8%B8%E6%88%8F/6737105)：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。

你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。

**示例:**

```
输入: 4
输出: false 
解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；
     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。
```

### 解答



* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    bool canWinNim(int n) {
        return (n%4 != 0);
    }
};
```



## Fizz Buzz

[LeetCode链接](https://leetcode-cn.com/problems/fizz-buzz/)

写一个程序，输出从 1 到 *n* 数字的字符串表示。

\1. 如果 *n* 是3的倍数，输出“Fizz”；

\2. 如果 *n* 是5的倍数，输出“Buzz”；

3.如果 *n* 同时是3和5的倍数，输出 “FizzBuzz”。

**示例：**

```
n = 15,

返回:
[
    "1",
    "2",
    "Fizz",
    "4",
    "Buzz",
    "Fizz",
    "7",
    "8",
    "Fizz",
    "Buzz",
    "11",
    "Fizz",
    "13",
    "14",
    "FizzBuzz"
]
```

### 解答



* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    vector<string> fizzBuzz(int n) {
        if(n <= 0)
            return vector<string>();
        
        vector<string> res;
        for(int i=1;i<=n;i++)
        {
            if(i%3 == 0 && i%5 == 0)
            {
                res.push_back("FizzBuzz");
            }
            else if(i%3 == 0)
            {
                res.push_back("Fizz");
            }
            else if(i%5 == 0)
            {
                res.push_back("Buzz");
            }
            else{
                res.push_back(to_string(i));
            }
        }
        
        
        return res;
    }
};
```



## 四数相加II

[LeetCode链接](https://leetcode-cn.com/problems/4sum-ii/)

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 `(i, j, k, l)` ，使得 `A[i] + B[j] + C[k] + D[l] = 0`。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2<sup>28</sup> 到 2<sup>28</sup> - 1 之间，最终结果不会超过 2<sup>31</sup> - 1 。

**例如:**

```
输入:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

输出:
2

解释:
两个元组如下:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
```

### 解答



- 时间复杂度O()
- 空间复杂度O()

```c++
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        unordered_map<int,int> mp;
        for(auto a:A)
        {
            for(auto b:B)
            {
                mp[a+b]++;
            }
        }
        
        int cnt = 0;
        for(auto c:C)
        {
            for(auto d:D)
            {
                if(mp.find(-c-d) != mp.end())
                    cnt += mp[-c-d];
            }
        }
        
        return cnt;
    }
};
```



## 有效的数独

[LeetCode链接](https://leetcode-cn.com/problems/valid-sudoku/)

判断一个 9x9 的数独是否有效。只需要**根据以下规则**，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

**示例 1:**

```
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
```

**示例 2:**

```
输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

**说明:**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 给定数独序列只包含数字 `1-9` 和字符 `'.'` 。
- 给定数独永远是 `9x9` 形式的。

### 解答



* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        unordered_map<char,int> mp;
        int row=board.size();
        int col=board[0].size();
        
        for(int i=0;i<row;i++)
        {
            for(int j=0;j<col;j++)
            {
                int ch=board[i][j];
                if(ch!='.')
                {
                    mp[ch]++;
                    if(mp[ch]>1)
                        return false;
                }
                
            }
            mp.clear();
        }
        
        for(int i=0;i<col;i++)
        {
            for(int j=0;j<row;j++)
            {
                char ch=board[j][i];
                if(ch!='.')
                {
                    mp[ch]++;
                    if(mp[ch]>1)
                        return false;
                }
            }
            mp.clear();
        }
        
        for(int i=0;i<row;i+=3)
        {
            for(int j=0;j<col;j+=3)
            {
                for(int x=i;x<i+3;x++)
                    for(int y=j;y<j+3;y++)
                    {
                        char ch=board[x][y];
                        if(ch!='.')
                        {
                            mp[ch]++;
                            if(mp[ch]>1)
                                return false;
                        }
                    }
                mp.clear();
            }
        }
        
        return true;
            
    }
};
```

## 打乱数组

[LeetCode链接](https://leetcode-cn.com/problems/shuffle-an-array/)

打乱一个没有重复元素的数组。

**示例:**

```
// 以数字集合 1, 2 和 3 初始化数组。
int[] nums = {1,2,3};
Solution solution = new Solution(nums);

// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。
solution.shuffle();

// 重设数组到它的初始状态[1,2,3]。
solution.reset();

// 随机返回数组[1,2,3]打乱后的结果。
solution.shuffle();
```

### 解答



* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    Solution(vector<int> nums) : vec(nums){
        srand(time(0));
    }
    
    /** Resets the array to its original configuration and return it. */
    vector<int> reset() {
        return vec;
    }
    
    /** Returns a random shuffling of the array. */
    vector<int> shuffle() {
        vector<int> res(vec);
        
        int len = res.size();
        for(int i = len-1;i >= 1;i--)
        {
            int rdm = rand() % (i+1);
            swap(res[rdm],res[i]);
        }
        
        return res;
    }
    
private:
    vector<int> vec;
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(nums);
 * vector<int> param_1 = obj.reset();
 * vector<int> param_2 = obj.shuffle();
 */
```

## 递增的三元子序列

[LeetCode链接](https://leetcode-cn.com/problems/increasing-triplet-subsequence/)

给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。

数学表达式如下:

> 如果存在这样的 *i, j, k,*  且满足 0 ≤ *i* < *j* < *k* ≤ *n*-1，
> 使得 *arr[i]* < *arr[j]* < *arr[k]* ，返回 true ; 否则返回 false 。

**说明:** 要求算法的时间复杂度为 O(*n*)，空间复杂度为 O(*1*) 。

**示例 1:**

```
输入: [1,2,3,4,5]
输出: true
```

**示例 2:**

```
输入: [5,4,3,2,1]
输出: false
```

### 解答



* 时间复杂度O()
* 空间复杂度O()

```c++

```

