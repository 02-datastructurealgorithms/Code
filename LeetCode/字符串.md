* **字符串类总结**
   * [机器能否返回原点](#机器能否返回原点)
   * [反转字符串](#反转字符串)
   * [反转字符串里的单词](#反转字符串里的单词)
   * [反转字符串中的单词III](#反转字符串中的单词III)
   * [罗马数字转整数](#罗马数字转整数)
   * [报数](#报数)
   * [验证回文串](#验证回文串)
   * [实现strStr()](#实现strStr)
   * [有效的括号](#有效的括号)
   * [字符串中的第一个唯一字符](#字符串中的第一个唯一字符)
   * [最长公共前缀](#最长公共前缀)
   * [括号生成](#括号生成)
   * [字母异位词分组](#字母异位词分组)
   * [电话号码的字母组合](#电话号码的字母组合)
   * [字符串相乘](#字符串相乘)
   * [简化路径](#简化路径)
   * [无重复字符的最长子串](#无重复字符的最长子串)
   * [字符串转整数(atoi)](#字符串转整数atoi)
   * [最小覆盖子串](#最小覆盖子串)
   
# 字符串类总结
## 机器能否返回原点
[LeetCode链接](https://leetcode-cn.com/problems/robot-return-to-origin)

在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 **(0, 0) 处结束**。

移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 `R`（右），`L`（左），`U`（上）和 `D`（下）。如果机器人在完成所有动作后返回原点，则返回 `true`。否则，返回 `false`。

**注意**：机器人“面朝”的方向无关紧要。 “`R`” 将始终使机器人向右移动一次，“`L`” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。

**示例 1**:
```
输入: "UD"
输出: true
解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。
```

**示例 2**:
```
输入: "LL"
输出: false
解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。
```

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 反转字符串
[LeetCode链接](https://leetcode-cn.com/problems/reverse-string)

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。


**示例 1**：
```
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

**示例 2**：
```
输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 反转字符串里的单词
[LeetCode链接](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

给定一个字符串，逐个翻转字符串中的每个单词。

**示例**:  
```
输入: "the sky is blue",
输出: "blue is sky the".
```

**说明**:

* 无空格字符构成一个单词。
* 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
* 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

**进阶**: 请选用C语言的用户尝试使用 O(1) 空间复杂度的原地解法。


### 解答

* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 反转字符串中的单词III
[LeetCode链接](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)

给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

**示例 1**:
```
输入: "Let's take LeetCode contest"
输出: "s'teL ekat edoCteeL tsetnoc" 
```

**注意**：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 罗马数字转整数
[LeetCode链接](https://leetcode-cn.com/problems/roman-to-integer/)

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X + II` 。 27 写做 `XXVII`, 即为 `XX + V + II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

* I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
* X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
* C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

**示例 1**：
```
输入: "IX"
输出: 9
```

**示例 2**:
```
输入: "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
```

**示例 3**:
```
输入: "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

### 解答


* 时间复杂度O()
* 空间复杂度O()

```python

```

## 报数
[LeetCode链接](https://leetcode-cn.com/problems/count-and-say/)

报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：
```
1.     1
2.     11
3.     21
4.     1211
5.     111221
```

1 被读作  "one 1"  ("一个一") , 即 11。
11 被读作 "two 1s" ("两个一"）, 即 21。
21 被读作 "one 2",  "one 1" （"一个二" ,  "一个一") , 即 1211。

给定一个正整数 *n（1 ≤ n ≤ 30）*，输出报数序列的第 n 项。

**注意**：整数顺序将表示为一个字符串。

**示例 1**:
```
输入: 1
输出: "1"
```

**示例 2**:
```
输入: 4
输出: "1211"
```

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 验证回文串
[LeetCode链接](https://leetcode-cn.com/problems/valid-palindrome/)

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明**：本题中，我们将空字符串定义为有效的回文串。

**示例 1**:
```
输入: "A man, a plan, a canal: Panama"
输出: true
```

**示例 2**:
```
输入: "race a car"
输出: false
```

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 实现strStr()
[LeetCode链接](https://leetcode-cn.com/problems/implement-strstr/)

实现 `strStr()` 函数。

给定一个 `haystack` 字符串和一个 `needle` 字符串，在 `haystack` 字符串中找出 `needle` 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 **-1**。

**示例 1**:
```
输入: haystack = "hello", needle = "ll"
输出: 2
```

**示例 2**:
```
输入: haystack = "aaaaa", needle = "bba"
输出: -1
```

**说明**:

当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 `needle` 是空字符串时我们应当返回 0 。这与C语言的 `strstr()` 以及 Java的 `indexOf()` 定义相符。

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 有效的括号
[LeetCode链接](https://leetcode-cn.com/problems/valid-parentheses/)

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

**注意**:空字符串可被认为是有效字符串。

**示例 1**:
```
输入: "()[]{}"
输出: true
```

**示例 2**:
```
输入: "(]"
输出: false
```

**示例 3**:
```
输入: "([)]"
输出: false
```

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 字符串中的第一个唯一字符
[LeetCode链接](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

**示例 1**:
```
s = "leetcode"
返回 0.
```

**示例 2**:
```
s = "loveleetcode",
返回 2.
```

**注意**：您可以假定该字符串只包含小写字母。

### 解答


* 时间复杂度O()
* 空间复杂度O()

```python

```

## 最长公共前缀
[LeetCode链接](https://leetcode-cn.com/problems/longest-common-prefix/)

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例 1**:
```
输入: ["flower","flow","flight"]
输出: "fl"
```

**示例 2**:
```
输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
```

**说明**:

所有输入只包含小写字母 `a-z` 。

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 括号生成
[LeetCode链接](https://leetcode-cn.com/problems/generate-parentheses/)

给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且**有效的**括号组合。

例如，给出 n = 3，生成结果为：
```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 字母异位词分组
[LeetCode链接](https://leetcode-cn.com/problems/group-anagrams/)

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

**示例**:
```
输入: ["eat", "tea", "tan", "ate", "nat", "bat"],
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```

**说明**：

* 所有输入均为小写字母。
* 不考虑答案输出的顺序。

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 电话号码的字母组合
[LeetCode链接](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![1](http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png)

**示例**:
```
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```

**说明**:

尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 字符串相乘
[LeetCode链接](https://leetcode-cn.com/problems/multiply-strings/)

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**示例 1**:
```
输入: num1 = "2", num2 = "3"
输出: "6"
```

**示例 2**:
```
输入: num1 = "123", num2 = "456"
输出: "56088"
```

**说明**：

1. `num1` 和 `num2` 的长度小于110。
2. `num1` 和 `num2` 只包含数字 0-9。
3. `num1` 和 `num2` 均不以零开头，除非是数字 0 本身。
4. **不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理**。

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 简化路径
[LeetCode链接](https://leetcode-cn.com/problems/simplify-path/)

以 Unix 风格给出一个文件的**绝对路径**，你需要简化它。或者换句话说，将其转换为规范路径。

在 Unix 风格的文件系统中，一个点（`.`）表示当前目录本身；此外，两个点 （`..`） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径

请注意，返回的规范路径必须始终以斜杠 `/` 开头，并且两个目录名之间必须只有一个斜杠 `/`。最后一个目录名（如果存在）不能以 `/` 结尾。此外，规范路径必须是表示绝对路径的最短字符串。

**示例 1**:
```
输入："/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。
```

**示例 2**:
```
输入："/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。
```

**示例 3**:
```
输入："/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
```

**示例 4**：
```
输入："/a/./b/../../c/"
输出："/c"
```

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 无重复字符的最长子串
[LeetCode链接](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1**:
```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2**:
```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3**:
```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 字符串转整数(atoi)
[LeetCode链接](https://leetcode-cn.com/problems/string-to-integer-atoi/)

请你来实现一个 `atoi` 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。

当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0。

**说明**：

假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2<sup>31</sup>, 2<sup>31</sup> − 1]。如果数值超过这个范围，请返回  INT_MAX (2<sup>31</sup> − 1) 或 INT_MIN (−2<sup>31</sup>) 。

**示例 1**:
```
输入: "42"
输出: 42
```

**示例 2**:
```
输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
```

**示例 3**:
```
输入: "4193 with words"
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
```

**示例 4**:
```
输入: "words and 987"
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。
```

**示例 5**:
```
输入: "-91283472332"
输出: -2147483648
解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 
     因此返回 INT_MIN 。
```

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++

```

## 最小覆盖子串
[LeetCode链接](https://leetcode-cn.com/problems/minimum-window-substring/)

给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。

**示例**：
```
输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"
```

**说明**：

* 如果 S 中不存这样的子串，则返回空字符串 `""`。
* 如果 S 中存在这样的子串，我们保证它是唯一的答案。

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++

```
