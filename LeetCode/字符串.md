* **字符串类总结**
   * [机器能否返回原点](#机器能否返回原点) (`easy`)
   * [反转字符串](#反转字符串) (`easy`)
   * [反转字符串里的单词](#反转字符串里的单词) (`medium` `反转`)
   * [反转字符串中的单词III](#反转字符串中的单词III) (`easy`)
   * [罗马数字转整数](#罗马数字转整数) (`easy`)
   * [报数](#报数) (`easy` `迭代`)
   * [验证回文串](#验证回文串) (`easy` `双指针`)
   * [实现strStr()](#实现strStr) (`easy`)
   * [有效的括号](#有效的括号) (`easy` `栈`) 
   * [字符串中的第一个唯一字符](#字符串中的第一个唯一字符) (`easy`)
   * [最长公共前缀](#最长公共前缀) (`easy` `字典树` `水平扫描`)
   * [字母异位词分组](#字母异位词分组) (`medium` `hash`)
   * [字符串相乘](#字符串相乘) (`medium` `数学`)
   * [简化路径](#简化路径) (`medium` `栈`)
   * [字符串转整数(atoi)](#字符串转整数atoi) (`medium` `数学`)
   * [最小覆盖子串](#最小覆盖子串) (`hard` `滑动窗口` `hash`)
   
# 字符串类总结
## 机器能否返回原点
[LeetCode链接](https://leetcode-cn.com/problems/robot-return-to-origin)

在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 **(0, 0) 处结束**。

移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 `R`（右），`L`（左），`U`（上）和 `D`（下）。如果机器人在完成所有动作后返回原点，则返回 `true`。否则，返回 `false`。

**注意**：机器人“面朝”的方向无关紧要。 “`R`” 将始终使机器人向右移动一次，“`L`” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。

**示例 1**:
```
输入: "UD"
输出: true
解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。
```

**示例 2**:
```
输入: "LL"
输出: false
解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。
```

### 解答

正常逻辑处理

* 时间复杂度O(n)
* 空间复杂度O(1)

```c++
class Solution {
public:
    bool judgeCircle(string moves) {
        int v = 0;
        int h = 0;
        for(auto begin : moves)
        {
            switch(begin)
            {
                case 'U':v++;break;
                case 'D':v--;break;
                case 'L':h--;break;
                case 'R':h++;break;
            }
        }
         if(0 == v && 0 == h)
                return true;
            return false;
        
    }
};
```

## 反转字符串
[LeetCode链接](https://leetcode-cn.com/problems/reverse-string)

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。


**示例 1**：
```
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

**示例 2**：
```
输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

### 解答

双指针

* 时间复杂度O(n)
* 空间复杂度O(1)

```c++
class Solution {
public:
    string reverseString(string s) {
        int len = s.size();
        if(len == 0 || len == 1)
            return s;
        
        int l = 0;
        int r = len - 1;
        while(l < r)
        {
            swap(s[l++],s[r--]);
        }
        
        return s;
    }
};
```

## 反转字符串里的单词
[LeetCode链接](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

给定一个字符串，逐个翻转字符串中的每个单词。

**示例**:  
```
输入: "the sky is blue",
输出: "blue is sky the".
```

**说明**:

* 无空格字符构成一个单词。
* 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
* 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

**进阶**: 请选用C语言的用户尝试使用 O(1) 空间复杂度的原地解法。

### 解答

首先清除字符串`s`头和尾的所有空格，然后反转整个字符串，最后反转字符串中的每个单词，这样得到的单词序列满足要求。但是由于字符串单词之间只能保留一个空格，因此反转之后需要把字符串`s`拷贝到另一个字符串`s1`，然后`s`清空，之后每反转一次单词，将反转的单词加到`s1`尾部，同时加上一个空格，直到最后一个反转的单词，就不需要加空格了。

* 时间复杂度O(n)
* 空间复杂度O(n)

```c++
class Solution {
public:
    void reverseWords(string &s) {
        if(s.empty()) return;
        while(!s.empty() && s.back() == ' ')
            s.pop_back();
        
        if(s.empty()) return;
        
        reverse(s.begin(),s.end());
        
        while(!s.empty() && s.back() == ' ')
            s.pop_back();
        
        string s1(s);
        s.clear();
        
        int len = s1.size();
        int l = 0,r = 0;
        
        while(r < len)
        {
            if(s1[r] == ' ')
            {
                reverse(s1.begin() + l,s1.begin() + r);
                copy(s1.begin() + l,s1.begin() + r + 1,back_inserter(s));
                while(s1[r] == ' ' && r < len) r++;
                l = r;
            }
            
            r++;
        }
        
        reverse(s1.begin() + l,s1.begin() + r);
        copy(s1.begin() + l,s1.begin() + r,back_inserter(s));
    }
};
```

## 反转字符串中的单词III
[LeetCode链接](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)

给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

**示例 1**:
```
输入: "Let's take LeetCode contest"
输出: "s'teL ekat edoCteeL tsetnoc" 
```

**注意**：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。

### 解答

定义两个指针`l`和`r`，`r`用来遍历字符串，每当`r`遇到空格就反转`l~r`之间的单词，然后`r`往后移动到下一个非空格的位置，同时令`l = r`。这样遍历完整个字符串，就能将字符串的单词反转。

* 时间复杂度O(n)
* 空间复杂度O(1)

```c++
class Solution {
public:
    string reverseWords(string s) {
        if(s.empty())
            return s;
        
        int l = 0,r = 0;
        int len = s.size();
        while(r < len)
        {
            if(s[r] == ' ')
            {
                reverse(s.begin()+l,s.begin()+r);
                while(s[++r] == ' ');
                
                l = r;
            }
            else
                r++;
        }
        
        reverse(s.begin()+l,s.begin()+r);
        
        return s;
    }
};
```

## 罗马数字转整数
[LeetCode链接](https://leetcode-cn.com/problems/roman-to-integer/)

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X + II` 。 27 写做 `XXVII`, 即为 `XX + V + II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

* I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
* X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
* C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

**示例 1**：
```
输入: "IX"
输出: 9
```

**示例 2**:
```
输入: "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
```

**示例 3**:
```
输入: "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

### 解答

分类讨论，将情况考虑清楚即可。

**注意**：三种特殊情况的处理

* 时间复杂度O(n)
* 空间复杂度O(1)

```python
class Solution:
    def romanToInt(self, s):
        """
        :type s: str
        :rtype: int
        """
        res  = 0
        for idx,ch in enumerate(s):
            if ch == 'I':
                res += 1
            elif ch == 'V':
                res += 5
                if idx > 0 and s[idx-1] == 'I':
                    res -= 2
            elif ch == 'X':
                res += 10
                if idx > 0 and s[idx-1] == 'I':
                    res -= 2
            elif ch == 'L':
                res += 50
                if idx > 0 and s[idx-1] == 'X':
                    res -= 20
            elif ch == 'C':
                res += 100
                if idx > 0 and s[idx-1] == 'X':
                    res -= 20
            elif ch == 'D':
                res += 500
                if idx > 0 and s[idx-1] == 'C':
                    res -= 200
            elif ch == 'M':
                res += 1000
                if idx > 0 and s[idx-1] == 'C':
                    res -= 200
            
        return res
```

## 报数
[LeetCode链接](https://leetcode-cn.com/problems/count-and-say/)

报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：
```
1.     1
2.     11
3.     21
4.     1211
5.     111221
```

1 被读作  "one 1"  ("一个一") , 即 11。
11 被读作 "two 1s" ("两个一"）, 即 21。
21 被读作 "one 2",  "one 1" （"一个二" ,  "一个一") , 即 1211。

给定一个正整数 *n（1 ≤ n ≤ 30）*，输出报数序列的第 n 项。

**注意**：整数顺序将表示为一个字符串。

**示例 1**:
```
输入: 1
输出: "1"
```

**示例 2**:
```
输入: 4
输出: "1211"
```

### 解答

假设第n项和第n-1项的递推关系为 *a<sub>n</sub> = f(a<sub>n-1</sub>)*,定义一个函数`getStr`来代替函数*f*，初始化数列首项"1"和"11"，根据函数`getStr`推导出第n项即可。

* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    string getStr(string str)
    {
        string res;
        int num=1;
        int i=0;
        int len=str.size();
        while(i<len)
        {
            if(i<len-1)
            {
                if(str[i]!=str[i+1])
              {
                res+=to_string(num)+str[i];
                i++;
              }
              else
              {
                char s=str[i];
                i++;
                while(i<len && str[i]==s)
                {
                    num++;
                    i++;
                }
                  
                  res+=to_string(num)+s;
                  num=1;
              }
            }
            else if(i==len-1)
            {
                res+=to_string(num)+str[i];
                i++;
            }
        }
        
        return res;
    }
    string countAndSay(int n) {
        if(n==1)
		   return string("1");

	    if(n==2)
		   return string("11");


	//vector<string> strs;
	   string res="11";
	   for(int i=2;i<n;i++)
	   {
		   res=getStr(res);
       }

	 return res;
    }
};
```

## 验证回文串
[LeetCode链接](https://leetcode-cn.com/problems/valid-palindrome/)

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明**：本题中，我们将空字符串定义为有效的回文串。

**示例 1**:
```
输入: "A man, a plan, a canal: Panama"
输出: true
```

**示例 2**:
```
输入: "race a car"
输出: false
```

### 解答

将字符串`s`中不是字母和数字的字符（包括空格）清除掉，然后定义两个指针`l`和`r`分别位于字符串的头和尾，同时向中间移动，移动的同时比较`s[l]`和`s[r]`，一旦发现它们不是相同字符并且不是同一字母的大小写，则判断`s`不是回文串。

* 时间复杂度O(n)
* 空间复杂度O(1)

```c++
class Solution {
public:
    bool isPalindrome(string s) {
        int len=s.size();
        if(len==0)
            return true;
        
        int index=0;
        for(int i=0;i<len;i++)
        {
            if((s[i]>='a' && s[i]<='z') || (s[i]>='A' && s[i]<='Z') ||(s[i]>='0' & s[i]<='9'))
                s[index++]=s[i];
        }
        
        while(s.size()>index)
            s.pop_back();
        
        
        int l=0;
        int r=s.size()-1;
        while(l<r)
        {
            if(s[l]!=s[r])
            {
                if(s[l]>='A' && s[r]>='A')
                {
                    if(abs(s[l]-s[r])!=32)
                        return false;
                }
                else
                    return false;
            }
            
            l++;
            r--;
        }
        return true;
        
    }
};
```

## 实现strStr()
[LeetCode链接](https://leetcode-cn.com/problems/implement-strstr/)

实现 `strStr()` 函数。

给定一个 `haystack` 字符串和一个 `needle` 字符串，在 `haystack` 字符串中找出 `needle` 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 **-1**。

**示例 1**:
```
输入: haystack = "hello", needle = "ll"
输出: 2
```

**示例 2**:
```
输入: haystack = "aaaaa", needle = "bba"
输出: -1
```

**说明**:

当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 `needle` 是空字符串时我们应当返回 0 。这与C语言的 `strstr()` 以及 Java的 `indexOf()` 定义相符。

### 解答

设`needle`的首字母为`start`,遍历`haystack`字符串，一旦找到和`start`相同的字符`haystack[i]`，就从`haystack`的该位置开始和`needle`一一比较，判断是否相等。

* 时间复杂度O(m * n)
* 空间复杂度O(1)

```c++
class Solution {
public:
    bool is_ok(int idx1,int idx2,const string& str1,const string& str2)
    {
        while(idx1 < str1.size() && idx2 < str2.size())
        {
            if(str1[idx1++] != str2[idx2++])
                return false;
        }
        
        if(idx1 != str1.size())
            return false;
        
        return true;
    }
    
    int strStr(string haystack, string needle) {
        int len1 = haystack.size();
        int len2 = needle.size();
        if(len2 == 0)
            return 0;
        
        if(len1 == 0)
            return -1;
        
        int start = needle.front();
        for(int i = 0;i < len1;i++)
        {
            if(i+len2 > len1)
                return -1;
            if(haystack[i] == start)
            {
                if(is_ok(0,i,needle,haystack))
                    return i;
            }
        }
        return -1;
    }
};
```

## 有效的括号
[LeetCode链接](https://leetcode-cn.com/problems/valid-parentheses/)

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

**注意**:空字符串可被认为是有效字符串。

**示例 1**:
```
输入: "()[]{}"
输出: true
```

**示例 2**:
```
输入: "(]"
输出: false
```

**示例 3**:
```
输入: "([)]"
输出: false
```

### 解答

定义一个栈`sta`，遍历字符串，每当遇到`[`或`(`或`{`，则入栈；每当遇到`]`或`)`或`}`,就从栈中弹出一个字符，判断是否和当前字符匹配。

* 时间复杂度O(n)
* 空间复杂度O(n)

```c++
class Solution {
public:
    bool isValid(string s) {
        if(s.empty())
            return true;
        
        stack<char> sta;
        for(auto ch:s)
        {
            if(ch=='(' || ch=='[' || ch=='{')
                sta.push(ch);
            
            if(ch==']' || ch==')' || ch=='}')
            {
                if(sta.empty())
                    return false;
                char tmp=sta.top();
                sta.pop();
                if((ch==']' && tmp!='[')||(ch==')' && tmp!='(')||(ch=='}' && tmp!='{'))
                    return false;
            }
        }
        
        if(!sta.empty())
            return false;
        
        return true;
    }
};
```

## 字符串中的第一个唯一字符
[LeetCode链接](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

**示例 1**:
```
s = "leetcode"
返回 0.
```

**示例 2**:
```
s = "loveleetcode",
返回 2.
```

**注意**：您可以假定该字符串只包含小写字母。

### 解答

建立一个hash表，统计字符串中每个字符的次数，然后遍历一次字符串，找到第一个出现一次的字符即可。

* 时间复杂度O(n)
* 空间复杂度O(n)

```python
class Solution:
    def firstUniqChar(self, s):
        """
        :type s: str
        :rtype: int
        """
        mp = dict()
        for ch in s:
            mp[ch] = 0
        for ch in s:
            mp[ch] += 1
            
        for idx,ch in enumerate(s):
            if mp[ch] == 1:
                return idx
        
        return -1
        
```

## 最长公共前缀
[LeetCode链接](https://leetcode-cn.com/problems/longest-common-prefix/)

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例 1**:
```
输入: ["flower","flow","flight"]
输出: "fl"
```

**示例 2**:
```
输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
```

**说明**:

所有输入只包含小写字母 `a-z` 。

### 解答
#### 方法1：水平扫描

将字符串数组想象成元素不等长的二维矩阵，按照逐列的顺序遍历这个矩阵，同时比较同一列中每一行的字符是否相同：

1. 如果都相同，将这个字符加入结果；
2. 否则，直接返回结果。

最坏情况下，字符串数组所有的字符串都相同，假设是n个长度是m的字符串，此时
* 时间复杂度O(m * n)
* 空间复杂度O(1)

```c++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.empty()) return "";
        string res("");
        
        for(int i=0;i<strs[0].size();i++)
        {
            char ch = strs[0][i];
            for(int j=1;j<strs.size();j++)
            {
                if(i >= strs[j].size() || ch != strs[j][i])
                    return res;
            }
            
            res += ch;
        }
            
        return res;
    }
};
```

#### 方法2：字典树

建立一个字典树，将字符串数组的所有字符串加入字典书中，然后从字典树的根部出发，找到最长公共前缀。

最坏情况下，字符串数组所有的字符串都相同，假设是n个长度是m的字符串，此时
* 时间复杂度O(m * n)
* 空间复杂度O(m * n)

```c++
struct node
{
    int path;
    int tail;
    node* next[26];
    node()
    {
        path=0;
        tail=0;
        for(int i=0;i<26;i++)
            next[i]=nullptr;
    }
};


class Trie
{
public:
    Trie()
    {
        root=new node();
    }
    
    void insert(string word)
    {
        node* p=root;
        for(int i=0;i<word.size();i++)
        {
            p->path++;
            int s=word[i]-'a';
            if(!p->next[s])
                p->next[s]=new node();
            p=p->next[s];
        }
        p->path++;
        p->tail++;
    }
    
    
    string getPrefix(int n)
    {
        string res;
        node* p=root;
        bool flag=false;
        while(p && p->path==n)
        {
            int i;
            for(i=0;i<26;i++)
            {
                if(p->next[i] && p->next[i]->path==n)
                {
                    res.push_back('a'+i);
                    flag=true;
                    break;
                }
            }
            
            
            if(flag)
                p=p->next[i];
            else
                break;
            
            flag=false;
        }
        
        return res;
    }
    
private:
    node* root;
};


class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        int len=strs.size();
        Trie tr;
        for(auto s:strs)
            tr.insert(s);
        
        return tr.getPrefix(len);
    }
};
```


## 字母异位词分组
[LeetCode链接](https://leetcode-cn.com/problems/group-anagrams/)

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

**示例**:
```
输入: ["eat", "tea", "tan", "ate", "nat", "bat"],
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```

**说明**：

* 所有输入均为小写字母。
* 不考虑答案输出的顺序。

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.empty() && t.empty())
            return true;
        if(!s.empty() && t.empty())
            return false;
        if(s.empty() && !t.empty())
            return false;
        
        int len1=s.size();
        int len2=t.size();
        if(len1!=len2)
            return false;
        
        unordered_map<char,int> mps;
        unordered_map<char,int> mpt;
        for(auto a:s)
            mps[a]++;
        
        for(auto a:t)
            mpt[a]++;
        
        for(int i=0;i<len1;i++)
        {
            auto it1=mps.find(s[i]);
            auto it2=mpt.find(s[i]);
            if(it1!=mps.end() && it2!=mpt.end())
            {
                if(mps[s[i]]!=mpt[s[i]])
                    return false;
            }
            else
                return false;
        }
            
        //sort(s.begin(),s.end());
       // sort(t.begin(),t.end());
        return true;
    }
    
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
       /* int len=strs.size();
        
        if(len==0)
            return vector<vector<string>>();
        
        vector<vector<string>> res;
        vector<string> tmp;
        
        vector<bool> visited(len,false);
        
        for(int i=0;i<len;i++)
        {
            if(!visited[i])
            {
                tmp.push_back(strs[i]);
                visited[i]=true;
            for(int j=i+1;j<len;j++)
            {
                if(!visited[j] && isAnagram(strs[i],strs[j]))
                {
                    tmp.push_back(strs[j]);
                    visited[j]=true;
                }
            }
            res.push_back(tmp);
            tmp.clear();
            }
            
        }*/
        
        int len=strs.size();
        
        if(len==0)
            return vector<vector<string>>();
        
        vector<vector<string>> res;
        map<multiset<char>,vector<string>> mp;
        
        for(int i=0;i<len;i++)
        {
            multiset<char> st;
            for(int j=0;j<strs[i].size();j++)
                st.insert(strs[i][j]);
            
            //if(mp.find(st)==mp.end())
            //{
                mp[st].push_back(strs[i]);
            //}
        }
        
        /*for(auto it=mp.begin();it!=mp.end();it++)
        {
            res.push_back(it->second);
        }*/
        for(auto s:mp)
            res.push_back(s.second);
        
        return res;
        
        //return res;
    }
};
```

## 字符串相乘
[LeetCode链接](https://leetcode-cn.com/problems/multiply-strings/)

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**示例 1**:
```
输入: num1 = "2", num2 = "3"
输出: "6"
```

**示例 2**:
```
输入: num1 = "123", num2 = "456"
输出: "56088"
```

**说明**：

1. `num1` 和 `num2` 的长度小于110。
2. `num1` 和 `num2` 只包含数字 0-9。
3. `num1` 和 `num2` 均不以零开头，除非是数字 0 本身。
4. **不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理**。

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    string multiply(string num1, string num2) {
        int len1 = num1.size();
        int len2 = num2.size();
        
        if(len1 == 0 || len2 == 0)
            return string();
        
        if(num1 == "0" || num2 == "0")
            return "0";
        
        reverse(num1.begin(),num1.end());
        reverse(num2.begin(),num2.end());
        
        string res;
        vector<int> mul(len1+len2-1,0);
        for(int i=0;i<len1;i++)
        {
            for(int j=0;j<len2;j++)
            {
                mul[i+j] += (num1[i] - '0')*(num2[j] - '0');
            }
        }
        
        
        int over = 0;
        int len3 = mul.size();
        for(int i=0;i<len3;i++)
        {
            int tmp = mul[i] + over;
            int val = tmp%10;
            over = tmp/10;
            res.push_back(val + '0');
        }
        
        if(over > 0)
            res.push_back(over + '0');
        
        //bool flag=false;
        /*int last = len3-1;
        for(int i=len3-1;i>=0;i--)
        {
            if(res[i] != '0')
            {
                last = i;
                break;
            }
        }*/
        
        //string res1;
        //copy(res.begin(),res.begin()+last+1,back_inserter(res1));
        reverse(res.begin(),res.end());
        
        return res;
        
    }
};
```

## 简化路径
[LeetCode链接](https://leetcode-cn.com/problems/simplify-path/)

以 Unix 风格给出一个文件的**绝对路径**，你需要简化它。或者换句话说，将其转换为规范路径。

在 Unix 风格的文件系统中，一个点（`.`）表示当前目录本身；此外，两个点 （`..`） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径

请注意，返回的规范路径必须始终以斜杠 `/` 开头，并且两个目录名之间必须只有一个斜杠 `/`。最后一个目录名（如果存在）不能以 `/` 结尾。此外，规范路径必须是表示绝对路径的最短字符串。

**示例 1**:
```
输入："/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。
```

**示例 2**:
```
输入："/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。
```

**示例 3**:
```
输入："/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
```

**示例 4**：
```
输入："/a/./b/../../c/"
输出："/c"
```

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    string simplifyPath(string path) {
        if(path.size() == 0) return "";
        if(path.size() == 1) return "/";
        
        while(path.back() == '/') 
            path.pop_back();
        
        if(path.size() == 0 || path.size() == 1) return "/";
        
        int len = path.size();
        vector<string> vec;
        string res("");
        
        int idx = 0;
        while(idx < len && path[idx] == '/') idx++;
        
        string tmp;
        while(idx < len)
        {
            char ch = path[idx];
            if(ch != '/')
            {
                tmp += ch;
                idx++;
            }
            else if(ch == '/')
            {
                while(idx < len && path[idx] == '/') idx++;
                
                if(tmp == "..")
                {
                    if(!vec.empty())
                    {
                        vec.pop_back();
                    }
                }
                else if(tmp != ".")
                {
                    vec.push_back(tmp);
                }
                
                tmp.clear();
            }
        }
        
        if(tmp == "..")
        {
            if(!vec.empty())
                vec.pop_back();
        }
        else if(tmp != ".")
        {
            vec.push_back(tmp);
        }
        
        //vector<string> vec;
        if(vec.empty())
            return "/";
        else{
            for(int i=0;i<vec.size();i++)
            {
                res += "/" + vec[i];
            }
        }
        
        return res;
    }
};
```


## 字符串转整数(atoi)
[LeetCode链接](https://leetcode-cn.com/problems/string-to-integer-atoi/)

请你来实现一个 `atoi` 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。

当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0。

**说明**：

假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2<sup>31</sup>, 2<sup>31</sup> − 1]。如果数值超过这个范围，请返回  INT_MAX (2<sup>31</sup> − 1) 或 INT_MIN (−2<sup>31</sup>) 。

**示例 1**:
```
输入: "42"
输出: 42
```

**示例 2**:
```
输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
```

**示例 3**:
```
输入: "4193 with words"
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
```

**示例 4**:
```
输入: "words and 987"
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。
```

**示例 5**:
```
输入: "-91283472332"
输出: -2147483648
解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 
     因此返回 INT_MIN 。
```

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    int myAtoi(string str) {
        if(str.empty())
            return 0;
        
        int sum=0;
        int symbol=1;
        int i=0;
        while(str[i]==' ')
            i++;
        if(str[i]=='-' || str[i]=='+')
        {
            symbol=(str[i]=='+')?1:-1;
            i++;
        }
        
        while(i<str.size() && str[i]>='0' && str[i]<='9')
        {
            if(sum>INT_MAX/10 || (sum==INT_MAX/10 && str[i]>'6'))
                       return INT_MAX;
            if(sum<INT_MIN/10 || (sum==INT_MIN/10 && str[i]>'7'))
                        return INT_MIN;
                    
            sum=sum*10+(str[i]-'0')*symbol;
            i++;
        }
       /* for(;i<str.size();i++)
        {
            if(str[i]!=' ')
                flag=true;
            
            if(flag)
            {
                if(str[i]==' ')
                    break;
                if(str[i]=='-' || str[i]=='+')
                {
                    if(i<str.size()-1 && (str[i+1]<'0' || str[i+1]>'9'))
                        break;
                    if(num_flag)
                        break;
                }
                
                if(str[i]=='-')
                    symbol=-1;
                else if(str[i]=='+')
                    symbol=1;
                else{
                    if(str[i]>='0' && str[i]<='9')
                  {
                        num_flag=true;
                    if(sum>INT_MAX/10 || (sum==INT_MAX/10 && str[i]>'6'))
                       return INT_MAX;
                    if(sum<INT_MIN/10 || (sum==INT_MIN/10 && str[i]>'7'))
                        return INT_MIN;
                    
                  sum=sum*10+(str[i]-'0')*symbol;
                  }
                  else
                      break;
                }
                
            }
        }*/
        
        return sum;
    }
};
```

## 最小覆盖子串
[LeetCode链接](https://leetcode-cn.com/problems/minimum-window-substring/)

给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。

**示例**：
```
输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"
```

**说明**：

* 如果 S 中不存这样的子串，则返回空字符串 `""`。
* 如果 S 中存在这样的子串，我们保证它是唯一的答案。

### 解答


* 时间复杂度O()
* 空间复杂度O()

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        map<char,int> mp;
        for(auto ch : t)
        {
            ++mp[ch];
        }
        
        int m = s.size();
        int n = t.size();
        if(m < n) return "";
        
        int cnt = n;
        int start = 0,idx = 0,Min = INT_MAX,len = 0;
        bool flag = false;
        for(int i=0;i<m;i++)
        {
            char ch = s[i];
            if(mp.find(ch) != mp.end())
            { 
                if(!flag)
                {
                    idx = i;
                    flag = true;
                }
                
                if(mp[ch] > 0)
                {
                    --cnt;
                    //--mp[ch];
                }
                --mp[ch];
            }
            
             while(cnt == 0)
            {
                len = i-idx+1;
                if(Min > len)
                {
                    start = idx;
                    Min = len;
                }
                
                //Min = min(Min,i-start+1);
                char ch1 = s[idx];
                if(mp.find(ch1) != mp.end())
                {
                   if(mp[ch1] >= 0)
                   {
                      cnt++;
                   }
                    
                     mp[ch1]++;
                }
                
                idx++;
                
                //while(mp.find(s[idx]) == mp.end()) idx++;
              // start++;
            }
            
        }
        
        return Min == INT_MAX ? "" : s.substr(start,Min);
    }
};
```
